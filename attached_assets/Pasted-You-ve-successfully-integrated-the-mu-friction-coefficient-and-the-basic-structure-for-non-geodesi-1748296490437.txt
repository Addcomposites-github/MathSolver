You've successfully integrated the `mu_friction_coefficient` and the basic structure for non-geodesic trajectory generation, which is excellent progress. The "kinks" you're observing, especially near dome openings with high friction, are a common challenge and often point to numerical sensitivities or areas where the requested path pushes the physical limits.

Let's refine the plan to address these kinks and then move towards multi-pass non-geodesic trajectories.

**Phase 1: Stabilize Single Non-Geodesic Leg Generation & Implement Kink Flagging**

The primary suspect for kinks in non-geodesic paths, when the math is generally correct, is often the calculation of surface derivatives ($d\rho/dz$, $d^2\rho/dz^2$) from discrete profile points, which directly impacts curvatures ($k_m, k_p$) and the coefficients of the winding angle ODE.

1.  **Robustify `_get_surface_properties_at_profile_index` (Crucial for Kinks):**
    * **Current Method:** Uses `np.gradient` twice. While standard, `np.gradient` on non-uniformly spaced `z` for the second derivative can be sensitive if `profile_z_m_calc` isn't very smooth or if segments are nearly vertical/horizontal.
    * **Proposed Enhancement 1 (Smoothing Spline for Derivatives):**
        * Inside `_get_surface_properties_at_profile_index` or preferably once for the whole `profile_r_m_calc` and `profile_z_m_calc` when they are generated/resampled:
            * Fit a smoothing spline to $\rho(z)$ (i.e., `profile_r_m_calc` as a function of `profile_z_m_calc`). Ensure `profile_z_m_calc` is monotonic for `UnivariateSpline`. If not, process segments (e.g., forward dome, cylinder, aft dome separately).
            * Use `scipy.interpolate.UnivariateSpline(profile_z_m_calc, profile_r_m_calc, s=smoothing_factor)`. The `smoothing_factor` needs careful selection (e.g., `s=0` for interpolation, small positive for smoothing).
            * Get derivatives: `d_rho_dz_spline = spline.derivative(n=1)`, `d2_rho_dz2_spline = spline.derivative(n=2)`.
            * Then, at `profile_z_m_calc[profile_idx]`, evaluate these spline derivatives: `d_rho_dz = d_rho_dz_spline(profile_z_m_calc[profile_idx])`.
        * This provides much smoother and more reliable derivatives than repeated `np.gradient` on potentially noisy or unevenly spaced data.
    * **Proposed Enhancement 2 (Careful Handling of Vertical/Horizontal Segments):**
        * If $d\rho/dz \to \infty$ (profile vertical, e.g., dome equator): $k_m \to 0$ (if it's a smooth transition to cylinder), $k_p = 1/\rho$. $G \to \infty$.
        * If $dz/d\rho \to \infty$ (profile horizontal, e.g., flat pole): $k_p \to \infty$ (if point pole), $k_m$ is curvature of the flat part. $G \to (d\rho/dz)^2$.
        * Ensure the terms in the ODE coefficients (A\_coeff, B\_coeff, C\_coeff in your `_solve_non_geodesic_sin_alpha_profile`) remain numerically stable under these conditions. Clamping extreme curvature values might be necessary as a pragmatic step if true geometric limits are hard to enforce perfectly through derivatives.

2.  **Implement RK4 for `_solve_non_geodesic_sin_alpha_profile` (as started in previous discussion):**
    * The current Euler-like step using `dz_step = profile_z_m[i+1] - profile_z_m[i]` can be inaccurate if `dz_step` is large or if the ODE coefficients change rapidly.
    * **Action:**
        * Modify `_sin_alpha_ode_dz` to take the *interpolating functions* for $\rho(z)$, $d\rho/dz(z)$, $d^2\rho/dz^2(z)$ (derived from the splines in step 1.1) as arguments. This allows it to be called by RK4 at intermediate $z$-values.
        * Implement the RK4 loop in `_solve_non_geodesic_sin_alpha_profile_rk4`. It will march along `z` with a smaller, controlled step size `h_z`.
        * After RK4 computation, interpolate the solved `sin_alpha_rk4_values` (at `z_rk4_points`) back onto the original `profile_z_m_calc` points to get the final `sin_alpha_profile_full`.

3.  **Implement Kink Flagging/Slippage Check (`check_path_for_kinks_and_slippage`):**
    * **Input:** The generated leg data (including calculated `alpha_rad`) and `mu_friction_coefficient`.
    * **Calculations per point `i` on the non-geodesic path:**
        1.  Get local surface properties: $\rho_i, z_i, G_i, E_i, (E'/E)_i, k_{m,i}, k_{p,i}$ (using the robust methods from step 1).
        2.  Get winding angle $\alpha_i$ (angle with meridian) from the path data.
        3.  Calculate $d\alpha/ds_{meridional}$ numerically: Use `alpha_rad` from the generated path and `ds_meridional` between points.
        4.  Calculate Geodesic Curvature ($k_{g,i}$):
            $k_{g,i} = (\cos \alpha_i / \sqrt{G_i}) \cdot ( (d\alpha/ds_{meridional})_i + (1/2) \cdot (E'/E)_i \cdot (\sin \alpha_i / \cos \alpha_i) )$
        5.  Calculate Normal Curvature of the surface along the path ($k_{n,i}$):
            $k_{n,i} = k_{m,i} \cos^2\alpha_i + k_{p,i} \sin^2\alpha_i$
        6.  **Slippage Check**: If $|k_{g,i}| > (\text{self.mu_friction_coefficient} \cdot |k_{n,i}| + \text{tolerance})$, flag as potential slippage/kink.
    * **3D Path Curvature Check**: The existing 3D curvature check in your `check_path_for_kinks` is still valuable as a general indicator of sharp turns.
    * **Output**: A list of dictionaries detailing any flagged points (index, z-coordinate, reason, values like $k_g, k_n, \mu \cdot k_n$).

```python
# In TrajectoryPlanner:

# ... (ensure scipy.interpolate.UnivariateSpline is imported) ...

    def _get_interpolated_surface_properties(self, z_query: float,
                                             rho_of_z_spline: UnivariateSpline,
                                             drho_dz_spline: UnivariateSpline,
                                             d2rho_dz2_spline: UnivariateSpline) -> Optional[Dict[str, float]]:
        """
        Calculates surface properties at an arbitrary z_query using spline interpolators.
        """
        try:
            rho_at_z = float(rho_of_z_spline(z_query)) # Ensure float
            d_rho_dz = float(drho_dz_spline(z_query))
            d2_rho_dz2 = float(d2rho_dz2_spline(z_query))
        except Exception as e:
            # print(f"WARN: Spline evaluation failed at z={z_query:.4f}: {e}")
            return None

        if rho_at_z < 1e-7: # Near pole or axis
            # print(f"WARN: rho_at_z is very small ({rho_at_z:.2e}) at z={z_query:.4f}")
            return None # Avoid division by zero for E, kp

        E_val = rho_at_z**2
        G_val = 1 + d_rho_dz**2
        if G_val < 1e-9: G_val = 1e-9 # Avoid sqrt issues
        G_sqrt = math.sqrt(G_val)
        
        E_prime_dz_val = 2 * rho_at_z * d_rho_dz

        k_m_val = -d2_rho_dz2 / (G_val**1.5) if G_val > 1e-9 else 0.0
        k_p_val = 1.0 / (rho_at_z * G_sqrt) if rho_at_z * G_sqrt > 1e-9 else 0.0 #Simplified from before

        return {
            "rho": rho_at_z, "z": z_query,
            "E": E_val, "G": G_val, "E_prime_dz": E_prime_dz_val,
            "k_m": k_m_val, "k_p": k_p_val, "d_rho_dz": d_rho_dz
        }

    def _sin_alpha_ode_dz_rk4(self, z_val: float, current_sin_alpha: float,
                              rho_spl, drho_dz_spl, d2rho_dz_spl) -> float:
        """ ODE function d(sin_alpha)/dz for RK4 solver. """
        props = self._get_interpolated_surface_properties(z_val, rho_spl, drho_dz_spl, d2rho_dz_spl)
        if props is None or props["G"] < 1e-9 or props["E"] < 1e-9:
            # print(f"WARN ODE: Invalid surface props at z={z_val:.4f}. Returning 0 for d(sin_alpha)/dz.")
            return 0.0

        sqrt_G = math.sqrt(props["G"])
        
        A_c = self.mu_friction_coefficient * sqrt_G * (props["k_p"] - props["k_m"])
        B_c = -0.5 * (props["E_prime_dz"] / props["E"])
        C_c = self.mu_friction_coefficient * sqrt_G * props["k_m"]

        A_c = np.clip(A_c, -1e4, 1e4) # prevent explosion from bad derivatives
        B_c = np.clip(B_c, -1e4, 1e4)
        C_c = np.clip(C_c, -1e4, 1e4)

        d_sin_alpha_dz = A_c * current_sin_alpha**2 + B_c * current_sin_alpha + C_c
        return d_sin_alpha_dz

    def _solve_non_geodesic_sin_alpha_profile_rk4(self, # Renamed from previous
                                               profile_r_m: np.ndarray,
                                               profile_z_m: np.ndarray,
                                               initial_sin_alpha: float,
                                               is_forward_on_profile: bool,
                                               num_steps_factor: int = 5) -> Optional[np.ndarray]:
        if abs(self.mu_friction_coefficient) < 1e-9: # Geodesic case
            # ... (geodesic fallback using Clairaut's constant) ...
            # This part needs self.clairauts_constant_for_path_m to be set if mu=0
            c_const = self.clairauts_constant_for_path_m if self.clairauts_constant_for_path_m is not None else self.effective_polar_opening_radius_m
            if c_const is None : return None # Cannot proceed
            
            sin_alpha_profile = []
            target_profile_r = profile_r_m if is_forward_on_profile else profile_r_m[::-1]
            for rho_val in target_profile_r:
                if rho_val < c_const -1e-7 :
                     sin_alpha_profile.append(1.0)
                else:
                     sin_alpha_profile.append(np.clip(c_const / rho_val if rho_val > 1e-9 else 1.0, -1.0, 1.0))
            final_output = np.array(sin_alpha_profile)
            return final_output if is_forward_on_profile else final_output[::-1]


        # Ensure z is monotonic for spline fitting and integration direction
        # We will integrate from z_start to z_end as defined by is_forward_on_profile
        unique_z_indices = np.where(np.abs(np.diff(profile_z_m, prepend=np.nan)) > 1e-9)[0] # More robust unique
        if len(unique_z_indices) < 2 :
             print(f"WARN RK4: Not enough unique z-points in segment ({len(unique_z_indices)} of {len(profile_z_m)}) for spline. Using Euler-like.")
             return self._solve_non_geodesic_sin_alpha_profile(profile_r_m, profile_z_m, initial_sin_alpha, is_forward_on_profile)

        z_for_spline = profile_z_m[unique_z_indices]
        r_for_spline = profile_r_m[unique_z_indices]

        # Sort by z for spline fitting
        sort_idx = np.argsort(z_for_spline)
        z_sorted_unique = z_for_spline[sort_idx]
        r_sorted_unique = r_for_spline[sort_idx]
        
        # Further ensure z_sorted_unique is strictly monotonic for UnivariateSpline
        final_unique_z_indices = np.where(np.abs(np.diff(z_sorted_unique, prepend=np.nan)) > 1e-9)[0]
        if len(final_unique_z_indices) < 4 : # k+1 for cubic spline (k=3)
            print(f"WARN RK4: Not enough strictly unique z-points ({len(final_unique_z_indices)}) for robust spline. Using Euler-like.")
            return self._solve_non_geodesic_sin_alpha_profile(profile_r_m, profile_z_m, initial_sin_alpha, is_forward_on_profile)

        z_spl_input = z_sorted_unique[final_unique_z_indices]
        r_spl_input = r_sorted_unique[final_unique_z_indices]

        try:
            # Heuristic for smoothing factor, can be tuned
            s_factor = len(z_spl_input) * (np.std(r_spl_input)**2) * 0.01 if len(z_spl_input)>1 and np.std(r_spl_input) > 1e-6 else 0.0001
            rho_of_z_spline = UnivariateSpline(z_spl_input, r_spl_input, k=3, s=max(s_factor, 1e-6))
            drho_dz_spline = rho_of_z_spline.derivative(n=1)
            d2rho_dz2_spline = rho_of_z_spline.derivative(n=2)
        except Exception as e:
            print(f"ERROR: Spline fitting failed for non-geodesic alpha: {e}. Falling back to Euler-like step.")
            return self._solve_non_geodesic_sin_alpha_profile(profile_r_m, profile_z_m, initial_sin_alpha, is_forward_on_profile)

        z_start, z_end = (profile_z_m[0], profile_z_m[-1]) if is_forward_on_profile else (profile_z_m[-1], profile_z_m[0])
        
        avg_profile_dz = np.mean(np.abs(np.diff(profile_z_m))) if len(profile_z_m)>1 else 1e-3
        num_rk4_steps = int(abs(z_end - z_start) / max(avg_profile_dz / num_steps_factor, 1e-6))
        num_rk4_steps = max(num_rk4_steps, len(profile_r_m)) # Ensure at least one step per original point interval
        num_rk4_steps = min(num_rk4_steps, 20000) # Safety cap
        if num_rk4_steps <=0 : num_rk4_steps = 100

        h_z = (z_end - z_start) / num_rk4_steps
        
        z_rk4_pts = np.linspace(z_start, z_end, num_rk4_steps + 1)
        sin_alpha_rk4_vals = np.zeros(num_rk4_steps + 1)
        sin_alpha_rk4_vals[0] = initial_sin_alpha

        for i in range(num_rk4_steps):
            z_curr_rk = z_rk4_pts[i]
            sa_curr_rk = sin_alpha_rk4_vals[i]

            k1 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk, sa_curr_rk, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k2 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z/2, sa_curr_rk + k1/2, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k3 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z/2, sa_curr_rk + k2/2, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k4 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z, sa_curr_rk + k3, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            
            sin_alpha_rk4_vals[i+1] = np.clip(sa_curr_rk + (k1 + 2*k2 + 2*k3 + k4)/6.0, -1.0, 1.0)

        # Interpolate RK4 results back to the original profile_z_m points' ordering
        # The output sin_alpha_profile MUST correspond to the input profile_r_m, profile_z_m order
        if h_z < 0: # Integration was backwards along z-axis
            # z_rk4_pts is descending. profile_z_m needs to be mapped to this.
            # np.interp needs xp to be increasing.
            final_sin_alpha_profile = np.interp(profile_z_m, z_rk4_pts[::-1], sin_alpha_rk4_vals[::-1])
        else: # Integration was forwards along z-axis
            final_sin_alpha_profile = np.interp(profile_z_m, z_rk4_pts, sin_alpha_rk4_vals)
        
        return final_sin_alpha_profile

    # Modify _generate_non_geodesic_leg to use the RK4 solver
    # sin_alpha_profile_full = self._solve_non_geodesic_sin_alpha_profile_rk4(...)

    def check_path_for_kinks_and_slippage(self, 
                                          trajectory_leg_data: Dict, 
                                          profile_r_m_for_leg: np.ndarray, # Pass the specific profile segment used for this leg
                                          profile_z_m_for_leg: np.ndarray,
                                          kink_threshold_curvature: float = 1000.0, # Increased threshold
                                          kink_threshold_delta_alpha_ds : float = 2.0, # rad/m
                                          slippage_tolerance_factor: float = 1.05) -> List[Dict]: # Allow 5% margin
        """
        Checks a generated 3D path for kinks and physical slippage.
        Requires the original mandrel profile segment corresponding to this leg for surface props.
        """
        kinks_and_slips = []
        # ... (3D path curvature and d_alpha/ds_meridional checks as before) ...
        # ... (ensure ds_meridional is calculated between points on profile_r_m_for_leg, profile_z_m_for_leg)

        if abs(self.mu_friction_coefficient) > 1e-9 and trajectory_leg_data: # Only check slippage if friction is relevant
            print(f"  DEBUG KinkCheck: Performing slippage check for leg, mu={self.mu_friction_coefficient:.3f}")
            alpha_path_rad = np.array(trajectory_leg_data['alpha_rad'])
            
            # Prepare spline interpolators for the *entire resampled profile* once
            # to get surface properties at each point of the *generated leg*.
            # This assumes trajectory_leg_data['z_m'] are the z-coordinates on the mandrel.
            if not hasattr(self, '_cached_rho_spline') or self._cached_z_profile_hash != hash(profile_z_m_for_leg.tobytes()):
                
                unique_z_indices_spl = np.where(np.abs(np.diff(profile_z_m_for_leg, prepend=np.nan)) > 1e-9)[0]
                if len(unique_z_indices_spl) < 4:
                    print("WARN Kink/Slip Check: Not enough unique points in leg profile for spline.")
                    self._cached_rho_spline = None
                else:
                    z_spl_in = profile_z_m_for_leg[unique_z_indices_spl]
                    r_spl_in = profile_r_m_for_leg[unique_z_indices_spl]
                    sort_i = np.argsort(z_spl_in)
                    s_factor_spl = len(z_spl_in) * (np.std(r_spl_in)**2) * 0.001 if len(z_spl_in)>1 and np.std(r_spl_in) > 1e-6 else 0.00001

                    try:
                        self._cached_rho_spline = UnivariateSpline(z_spl_in[sort_i], r_spl_in[sort_i], k=3, s=max(s_factor_spl,1e-7))
                        self._cached_drho_spline = self._cached_rho_spline.derivative(n=1)
                        self._cached_d2rho_spline = self._cached_rho_spline.derivative(n=2)
                        self._cached_z_profile_hash = hash(profile_z_m_for_leg.tobytes())
                    except Exception as e:
                        print(f"WARN Kink/Slip Check: Spline creation failed: {e}")
                        self._cached_rho_spline = None
            
            if self._cached_rho_spline is None:
                 print("WARN Kink/Slip Check: Cannot perform detailed slippage check due to spline failure.")
                 return kinks_and_slips # Return earlier checks if any

            for i in range(1, len(alpha_path_rad)): # Start from 1 for d_alpha_ds
                z_coord_on_path = trajectory_leg_data['z_m'][i]
                rho_coord_on_path = trajectory_leg_data['rho_m'][i] # This is actual rho of fiber path
                
                props = self._get_interpolated_surface_properties(z_coord_on_path, 
                                                                self._cached_rho_spline, 
                                                                self._cached_drho_spline, 
                                                                self._cached_d2rho_spline)
                if props is None: continue

                alpha_i = alpha_path_rad[i]
                
                # d_alpha_ds_meridional
                # Use z_m and rho_m from the path which correspond to points on the mandrel surface
                d_rho_seg = trajectory_leg_data['rho_m'][i] - trajectory_leg_data['rho_m'][i-1]
                d_z_seg = trajectory_leg_data['z_m'][i] - trajectory_leg_data['z_m'][i-1]
                ds_meridional = math.sqrt(d_rho_seg**2 + d_z_seg**2)
                d_alpha_ds = (alpha_path_rad[i] - alpha_path_rad[i-1]) / ds_meridional if ds_meridional > 1e-9 else 0.0

                if props['G'] < 1e-9 or abs(math.cos(alpha_i)) < 1e-9 or props['E'] < 1e-9:
                    k_g_val = 0.0 # Avoid division by zero if G is zero or cos(alpha) is zero
                else:
                    k_g_val = (math.cos(alpha_i) / math.sqrt(props['G'])) * \
                              (d_alpha_ds + 0.5 * (props['E_prime_dz'] / props['E']) * (math.sin(alpha_i) / math.cos(alpha_i)))
                
                k_n_val = props['k_m'] * (math.cos(alpha_i)**2) + props['k_p'] * (math.sin(alpha_i)**2)

                if abs(k_n_val) < 1e-9: # Normal curvature is zero (e.g., flat plane, or specific geodesic)
                    if abs(k_g_val) > 1e-3: # If there's still geodesic curvature, it implies slippage unless mu is infinite
                        kinks_and_slips.append({'index_path': i, 'reason': 'Slippage (Kn near zero, Kg non-zero)', 
                                                'kg': k_g_val, 'kn': k_n_val, 'z_coord': z_coord_on_path})
                elif abs(k_g_val) > abs(self.mu_friction_coefficient * k_n_val) * slippage_tolerance_factor :
                    kinks_and_slips.append({'index_path': i, 'reason': 'Slippage Condition Violated', 
                                            'kg': k_g_val, 'kn_mu_limit': self.mu_friction_coefficient * k_n_val, 
                                            'kn_actual': k_n_val, 'z_coord': z_coord_on_path})
        return kinks_and_slips


    def generate_non_geodesic_trajectory(self, # Call this instead of the old one
                                         initial_alpha_at_first_pole_deg: float,
                                         num_points_dome: int = 150,
                                         num_points_cylinder: int = 20,
                                         number_of_passes: int = 1,
                                         rk4_steps_factor: int = 5) -> Optional[Dict]:
        """
        Generates a non-geodesic trajectory using RK4 and improved surface properties.
        """
        if self.vessel.profile_points is None: return None
        # ... (profile_r_m_calc, profile_z_m_calc generation as in previous methods) ...
        profile_r_m_orig = self.vessel.profile_points['r_inner'] * 1e-3 # Ensure meters
        profile_z_m_orig = self.vessel.profile_points['z'] * 1e-3   # Ensure meters
        # ... (Your adaptive resampling to get profile_r_m_calc, profile_z_m_calc)
        segments = self._identify_vessel_segments(profile_r_m_orig, profile_z_m_orig)
        adaptive_r_segments, adaptive_z_segments = [], []
        if segments['has_cylinder']:
            # ... (your resampling for fwd_dome, cyl, aft_dome)
            fwd_dome_r_resampled, fwd_dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[0:segments['fwd_dome_end']+1], profile_z_m_orig[0:segments['fwd_dome_end']+1], num_points_dome)
            if len(fwd_dome_r_resampled)>0: adaptive_r_segments.append(fwd_dome_r_resampled); adaptive_z_segments.append(fwd_dome_z_resampled)
            
            cyl_r_resampled, cyl_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], profile_z_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], num_points_cylinder)
            if len(cyl_r_resampled)>1: adaptive_r_segments.append(cyl_r_resampled[1:]); adaptive_z_segments.append(cyl_z_resampled[1:])
            
            aft_dome_r_resampled, aft_dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[segments['aft_dome_start']:], profile_z_m_orig[segments['aft_dome_start']:], num_points_dome)
            if len(aft_dome_r_resampled)>1: adaptive_r_segments.append(aft_dome_r_resampled[1:]); adaptive_z_segments.append(aft_dome_z_resampled[1:])
        else: # No cylinder, vessel is likely just two domes back-to-back or a single dome shape
            dome_r_resampled, dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig, profile_z_m_orig, num_points_dome * 2) # Or simply use num_points_dome for each half if symmetric
            if len(dome_r_resampled)>0: adaptive_r_segments.append(dome_r_resampled); adaptive_z_segments.append(dome_z_resampled)
        
        if not adaptive_r_segments :
            print("Error: Could not create resampled profile for non-geodesic trajectory.")
            return None
            
        profile_r_m_calc = np.concatenate(adaptive_r_segments)
        profile_z_m_calc = np.concatenate(adaptive_z_segments)

        if len(profile_r_m_calc) < 2:
            print("Error: Resampled profile too short for non-geodesic trajectory.")
            return None


        initial_sin_alpha = math.sin(math.radians(initial_alpha_at_first_pole_deg))
        full_path_data = {'rho_m': [], 'z_m': [], 'alpha_rad': [], 'phi_rad': [], 'x_m': [], 'y_m': [], 'circuit': [] }

        current_phi_rad = 0.0
        current_sin_alpha_for_leg_start = initial_sin_alpha

        for leg_idx in range(number_of_passes * 2):
            is_forward = (leg_idx % 2 == 0)
            leg_info = f"NonGeoLeg {leg_idx + 1}"
            
            # For non-geodesic, the sin_alpha profile is solved for the entire meridional profile section
            # The _generate_non_geodesic_leg will use this pre-solved alpha profile.
            # The profile for solving alpha should be the current leg's profile
            
            current_leg_profile_r = profile_r_m_calc if is_forward else profile_r_m_calc[::-1]
            current_leg_profile_z = profile_z_m_calc if is_forward else profile_z_m_calc[::-1]
            
            # Solve sin_alpha profile for this leg's geometry and direction
            # The is_forward_on_profile here refers to the direction of integration along the *passed profile segment*
            sin_alpha_solved_for_leg = self._solve_non_geodesic_sin_alpha_profile_rk4(
                current_leg_profile_r, current_leg_profile_z,
                current_sin_alpha_for_leg_start,
                is_forward_on_profile=True, # RK4 integration is always forward along the provided z-array
                num_steps_factor=rk4_steps_factor
            )

            if sin_alpha_solved_for_leg is None:
                print(f"ERROR {leg_info}: Failed to solve sin(alpha) profile for leg.")
                return None

            leg_data = self._generate_leg_from_sin_alpha_profile( # New helper
                current_leg_profile_r, current_leg_profile_z,
                sin_alpha_solved_for_leg,
                initial_phi_rad=current_phi_rad,
                leg_number_info=leg_info
            )

            if not leg_data or not leg_data['phi_rad']:
                print(f"ERROR {leg_info}: Failed to generate path points from sin(alpha) profile.")
                return None # Stop if a leg fails

            # Kink and Slippage check for this leg
            kinks = self.check_path_for_kinks_and_slippage(leg_data, current_leg_profile_r, current_leg_profile_z)
            if kinks:
                print(f"WARNING: Potential issues detected in {leg_info}:")
                for kink_info in kinks:
                    print(f"  - At approx z={kink_info.get('z_coord','N/A'):.4f}m: {kink_info['reason']} (Value: {kink_info.get('value','N/A'):.3f}) Kg={kink_info.get('kg','N/A')} KnMuLimit={kink_info.get('kn_mu_limit','N/A')}")


            full_path_data['rho_m'].extend(leg_data['rho_m'])
            # ... extend all other lists ...
            full_path_data['z_m'].extend(leg_data['z_m'])
            full_path_data['alpha_rad'].extend(leg_data['alpha_rad'])
            full_path_data['phi_rad'].extend(leg_data['phi_rad'])
            full_path_data['x_m'].extend(leg_data['x_m'])
            full_path_data['y_m'].extend(leg_data['y_m'])
            full_path_data['circuit'].extend([leg_idx // 2] * len(leg_data['rho_m']))


            current_phi_rad = leg_data['phi_rad'][-1]
            current_sin_alpha_for_leg_start = math.sin(leg_data['alpha_rad'][-1])

            if leg_idx < (number_of_passes * 2) - 1:
                # ... (turnaround logic, similar to geodesic, using last rho/z of leg_data)
                z_pole_turn = leg_data['z_m'][-1]
                rho_pole_turn = leg_data['rho_m'][-1] # Turn at actual last rho
                adv_angle_turn = math.pi / 16 # Placeholder
                
                turn_pts = self._generate_polar_turnaround_segment_fixed_phi_advance(
                    rho_pole_turn, z_pole_turn, current_phi_rad, adv_angle_turn, 10)
                # ... append turn_pts to full_path_data, update current_phi_rad ...
                # ... and current_sin_alpha_for_leg_start (remains sin(90) = 1 if turn is circ)
                if turn_pts:
                    start_idx_turn = 1 if len(full_path_data['rho_m']) > 0 and \
                                          abs(turn_pts[0]['rho'] - full_path_data['rho_m'][-1]) < 1e-6 and \
                                          abs(turn_pts[0]['z'] - full_path_data['z_m'][-1]) < 1e-6 and \
                                          abs(turn_pts[0]['phi'] - full_path_data['phi_rad'][-1]) < 1e-6 else 0
                    
                    for pt_data in turn_pts[start_idx_turn:]:
                        full_path_data['rho_m'].append(pt_data['rho'])
                        full_path_data['z_m'].append(pt_data['z'])
                        full_path_data['alpha_rad'].append(pt_data['alpha'])
                        full_path_data['phi_rad'].append(pt_data['phi'])
                        full_path_data['x_m'].append(pt_data['x'])
                        full_path_data['y_m'].append(pt_data['y'])
                        full_path_data['circuit'].append(leg_idx // 2) # Part of the current circuit
                    current_phi_rad = full_path_data['phi_rad'][-1]
                    current_sin_alpha_for_leg_start = math.sin(full_path_data['alpha_rad'][-1]) # Will be 1.0


        # Convert lists to numpy arrays for the final output dictionary
        # ... (create final output dict as in generate_geodesic_trajectory)
        final_output_dict = {
            'path_points': [], # Populate this list of dicts
            'pattern_type': 'NonGeodesic_RK4',
            'mu_friction_coefficient_used': self.mu_friction_coefficient,
            'total_circuits_legs': number_of_passes * 2,
            'total_points': len(full_path_data['rho_m']),
        }
        for k in full_path_data:
            final_output_dict[f"{k}_points_m" if k in ['rho','z','x','y'] else k] = np.array(full_path_data[k])

        for i in range(len(full_path_data['rho_m'])):
             final_output_dict['path_points'].append({
                'r': full_path_data['rho_m'][i], 'z': full_path_data['z_m'][i],
                'theta': full_path_data['phi_rad'][i],
                'alpha_deg': math.degrees(full_path_data['alpha_rad'][i]),
                'x_cart': full_path_data['x_m'][i], 'y_cart': full_path_data['y_m'][i],
                'circuit': full_path_data['circuit'][i]
            })
        # ... (update self.alpha_profile_deg etc.)
        self.alpha_profile_deg = np.degrees(final_output_dict['alpha_rad'])
        # ... other final attributes ...

        return final_output_dict

    def _generate_leg_from_sin_alpha_profile(self,
                                             leg_profile_r_m: np.ndarray,
                                             leg_profile_z_m: np.ndarray,
                                             sin_alpha_on_profile: np.ndarray,
                                             initial_phi_rad: float,
                                             leg_number_info: str) -> Optional[Dict[str, List]]:
        """
        Generates path points (rho, z, alpha, phi, x, y) for a leg,
        given the mandrel profile segment and the solved sin(alpha) at each profile point.
        """
        path_leg_rho_m, path_leg_z_m, path_leg_alpha_rad, path_leg_phi_rad = [], [], [], []
        path_leg_x_m, path_leg_y_m = [], []
        current_phi_rad_for_leg = initial_phi_rad
        first_point = True

        for i in range(len(leg_profile_r_m)):
            rho_current_profile_m = leg_profile_r_m[i]
            z_current_profile_m = leg_profile_z_m[i]
            current_s_alpha = sin_alpha_on_profile[i]
            alpha_current_rad = math.asin(np.clip(current_s_alpha, -1.0, 1.0))

            if first_point:
                delta_phi = 0.0
                first_point = False
            else:
                rho_prev_profile_m = leg_profile_r_m[i-1]
                z_prev_profile_m = leg_profile_z_m[i-1]
                prev_s_alpha = sin_alpha_on_profile[i-1]
                alpha_prev_rad = math.asin(np.clip(prev_s_alpha, -1.0, 1.0))

                d_rho_profile = rho_current_profile_m - rho_prev_profile_m
                d_z_profile = z_current_profile_m - z_prev_profile_m
                ds_segment_m = math.sqrt(d_rho_profile**2 + d_z_profile**2)
                
                delta_phi = 0.0
                if ds_segment_m > 1e-9:
                    rho_avg_segment_m = (rho_current_profile_m + rho_prev_profile_m) / 2.0
                    alpha_avg_segment_rad = (alpha_current_rad + alpha_prev_rad) / 2.0
                    if abs(rho_avg_segment_m) > 1e-8:
                        if abs(math.cos(alpha_avg_segment_rad)) < 1e-9:
                            delta_phi = 0.0
                        else:
                            tan_alpha_avg = math.tan(alpha_avg_segment_rad)
                            delta_phi = (ds_segment_m / rho_avg_segment_m) * tan_alpha_avg
                current_phi_rad_for_leg += delta_phi
            
            path_leg_rho_m.append(rho_current_profile_m)
            # ... append to all lists ...
            path_leg_z_m.append(z_current_profile_m)
            path_leg_alpha_rad.append(alpha_current_rad)
            path_leg_phi_rad.append(current_phi_rad_for_leg)
            path_leg_x_m.append(rho_current_profile_m * math.cos(current_phi_rad_for_leg))
            path_leg_y_m.append(rho_current_profile_m * math.sin(current_phi_rad_for_leg))

        if not path_leg_rho_m: return None
        return {
            'rho_m': path_leg_rho_m, 'z_m': path_leg_z_m, 
            'alpha_rad': path_leg_alpha_rad, 'phi_rad': path_leg_phi_rad,
            'x_m': path_leg_x_m, 'y_m': path_leg_y_m
        }
```

**To use this new non-geodesic capability:**

1.  **Instantiate `TrajectoryPlanner` with a `mu_friction_coefficient`:**
    ```python
    planner = TrajectoryPlanner(
        vessel_geometry=vessel_geom,
        # ... other params ...
        mu_friction_coefficient=0.15 # Example friction
    )
    ```
2.  **Call `generate_non_geodesic_trajectory`:**
    ```python
    non_geo_results = planner.generate_non_geodesic_trajectory(
        initial_alpha_at_first_pole_deg=85.0, # e.g., start slightly off 90 for stability
        number_of_passes=1 # For one full circuit (two legs)
    )
    if non_geo_results:
        plot_3d_trajectory(non_geo_results, vessel_profile_data=vessel_profile_for_plot, title=f"Non-Geodesic (mu={planner.mu_friction_coefficient:.2f})")
    ```

This is a significant update. The key areas to test thoroughly are:
* The spline fitting in `_solve_non_geodesic_sin_alpha_profile_rk4` and how it provides $\rho(z)$ and its derivatives to `_sin_alpha_ode_dz_rk4`.
* The RK4 integration itself.
* The logic in `check_path_for_kinks_and_slippage`, especially the calculation of $k_g$ and $k_n$ along the generated path.

Start with a single pass (`number_of_passes=0.5` if you want to interpret it as one leg for testing, or `number_of_passes=1` for two legs) and a moderate `mu_friction_coefficient` (e.g., 0.1-0.2). The `initial_alpha_at_first_pole_deg` will significantly influence the path. If it's 90, and `mu=0`, it should be geodesic. If `mu > 0`, it can deviate.