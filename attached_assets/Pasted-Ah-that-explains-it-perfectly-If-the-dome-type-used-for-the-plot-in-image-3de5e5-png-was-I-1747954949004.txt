Ah, that explains it perfectly!

If the `dome_type` used for the plot in `image_3de5e5.png` was "Isotensoid", then the "weird" and discontinuous profile is due to the placeholder logic currently in your `_generate_isotensoid_profile` method within `geometry.py`.

Currently, your `_generate_isotensoid_profile` method has this comment and a very rough approximation:
```python
    def _generate_isotensoid_profile(self, num_points_dome: int = 100):
        """Placeholder for Koussios qrs-parameterized isotensoid profile."""
        # This needs the full Koussios equations (Eq. 4.3 or 4.20 from thesis)
        # For now, returning a shape similar to hemispherical for plotting
        print("WARNING: Isotensoid profile is a placeholder.")
        R_dome = self.inner_radius
        # This is a conceptual polar opening for the dome, not necessarily vessel's final.
        # For qrs, rho_0 is the reference, could be self.inner_radius / Y_eq_from_qrs
        # Let's assume dome_height is roughly R_dome * 0.6 (typical isotensoid aspect)
        actual_dome_height = R_dome * 0.6 * self.q_factor / (self.q_factor * 0.5 + 1)  # very rough
        
        phi_angles = np.linspace(0, np.pi / 2, num_points_dome)
        dome_rho = R_dome * np.sin(phi_angles) # Hemispherical rho
        dome_z_local = actual_dome_height * np.cos(phi_angles) # Scaled hemispherical z
        return np.vstack((dome_rho, dome_z_local)).T, actual_dome_height
```
This placeholder uses a hemispherical `rho` (`R_dome * np.sin(phi_angles)`) and then tries to scale a cosine function for `z_local` based on a very rough `actual_dome_height`. This combination will not produce a proper isotensoid nor likely connect smoothly or look correct.

**The next step is to replace this placeholder with the actual Koussios `qrs`-parameterized isotensoid calculation we detailed previously, which involves the elliptic integrals.**

Let's integrate the detailed logic for `_calculate_isotensoid_koussios_qrs_profile` (which we discussed and I provided a Pythonic version of in our previous exchange) into your `_generate_isotensoid_profile` method in `geometry.py`.

You'll need:
1.  The `q_factor` and `r_factor` (and `s_factor` if it influences the reference radius or dome/cylinder split implicitly, though for dome profile itself `s` isn't directly in $Z(\theta)$). `self.polar_opening_radius_m` will be used as the initial $\rho_0$ reference, which might need adjustment based on `self.inner_radius` to ensure the dome's equatorial end matches the cylinder.
2.  The helper functions for incomplete elliptic integrals (F and E) from your `utils/numerical_tools.py` (or from `scipy.special`).

Here's how the refined `_generate_isotensoid_profile` method should look, incorporating the logic we discussed for Koussios Thesis Eq. 4.13, 4.12, and 4.20:

```python
# In class VesselGeometry from your geometry.py

# Ensure these imports are at the top of your geometry.py if not already there
# from ..utils.numerical_tools import incomplete_elliptic_integral_first_kind, incomplete_elliptic_integral_second_kind
# For standalone testing, you might need to adjust the import path or temporarily
# define these functions if utils.numerical_tools isn't in the Python path during testing.
# Assuming they are available via:
from scipy.special import ellipkinc, ellipeinc # F(phi, m), E(phi, m) where m = k^2

# ... (rest of your class) ...

    def _generate_isotensoid_profile(self, num_points_dome: int = 100): # Matches your existing signature
        """
        Calculates the Koussios qrs-parameterized isotensoid dome profile.
        Profile is from (actual_polar_opening_dome_m, dome_height_m) to (self.inner_radius, 0 - local z).
        Uses Koussios Thesis Ch. 4 equations.
        rho_0_input is the reference scale factor, initially self.polar_opening_radius_m, but adjusted
        so that the dome's Y_eq * rho_0_adjusted = self.inner_radius (cylinder radius).
        """
        
        q = self.q_factor
        r = self.r_factor
        # s_factor is for the overall vessel, not directly for this Z(theta) dome profile calculation part

        # Initial reference radius (will be adjusted)
        # This is a tricky part: Koussios's rho_0 is the scale factor.
        # Y_min and Y_eq are dimensionless ratios *to this rho_0*.
        # The dome should connect to self.inner_radius, which is the physical equatorial radius.
        # The dome's smallest physical radius (its own pole) will be rho_0_adjusted * Y_min_dimless.
        
        # Calculate dimensionless Y_min and Y_eq based on q, r (Koussios Thesis, Eq. 4.13)
        den_Y_calc = 1 + q + 2 * q * r
        if abs(den_Y_calc) < 1e-9: # Avoid division by zero
            # This configuration of q,r is problematic.
            # Fallback to a placeholder or raise error
            print(f"ERROR: Denominator for Y_min/Y_eq calculation is near zero with q={q}, r={r}.")
            R_dome_fallback = self.inner_radius
            dome_h_fallback = R_dome_fallback * 0.6 
            self.dome_height = dome_h_fallback # Set the attribute
            t_fallback = np.linspace(0, np.pi/2, num_points_dome)
            return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        num_Y_calc = 1 + q + 2 * q * r + q**2 * (1 + r**2)
        
        # Check r_limit based on Koussios Eq. 4.15 (r >= -(1+q)/(2q))
        r_limit = -(1 + q) / (2 * q) if q != 0 else (0 if 1+q == 0 else -np.inf) # Handle q=0
        if r < r_limit - 1e-6 : # Add tolerance
            print(f"ERROR: r_factor ({r:.3f}) is below the limit ({r_limit:.3f}) for q={q:.3f}. Real Y_min/Y_eq not possible.")
            num_Y_calc = 0 # Force it to the limit to avoid math domain error if slightly below
            if num_Y_calc < 0: # Still negative, then it's definitely an issue
                R_dome_fallback = self.inner_radius
                dome_h_fallback = R_dome_fallback * 0.6 
                self.dome_height = dome_h_fallback
                t_fallback = np.linspace(0, np.pi / 2, num_points_dome)
                return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback


        Y_min_dimless_raw = math.sqrt(max(0, num_Y_calc) / den_Y_calc) # max(0,..) for safety
        if q <= 1e-9:
            print("ERROR: q_factor is zero or too small for Y_eq calculation in isotensoid.")
            # Handle error or fallback as above
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.6; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        Y_eq_dimless_raw = Y_min_dimless_raw / math.sqrt(q)

        # Adjust rho_0 so that the calculated equatorial radius matches self.inner_radius
        if abs(Y_eq_dimless_raw) < 1e-6:
            print("ERROR: Calculated Y_eq_dimless_raw is too small in isotensoid.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.6; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        rho_0_adjusted = self.inner_radius / Y_eq_dimless_raw
        
        # The actual start and end radii for this dome segment, using the adjusted rho_0
        actual_dome_polar_radius = Y_min_dimless_raw * rho_0_adjusted
        actual_dome_equatorial_radius = Y_eq_dimless_raw * rho_0_adjusted # Should be self.inner_radius

        # Elliptical coordinate theta (Koussios: 0 at Y=Y_eq, pi/2 at Y=Y_min)
        # We generate points from pole (theta=pi/2) to equator (theta=0) for the local dome profile
        theta_values = np.linspace(np.pi / 2.0, 0.0, num_points_dome)

        # Parameter m for elliptic integrals (Koussios Thesis, for Eq. 4.20)
        # m_elliptic = (q - 1) / (1 + 2 * q * (1 + r)) # Check Koussios paper for correct m
        # Koussios Eq 4.20 uses m = (q-1) / (1+2q(1+r))
        # The argument in scipy is m = k^2. If Koussios m is already k^2, it's fine.
        # If Koussios m is the parameter k, then we need m_scipy = m_koussios^2.
        # Common notation for elliptic integrals E(phi, m) and F(phi, m) has m = k^2 (modulus squared).
        # Let's assume Koussios's 'm' is indeed m = k^2.
        
        denom_m_elliptic = 1 + 2 * q * (1 + r)
        if abs(denom_m_elliptic) < 1e-9:
            print(f"ERROR: Denominator for m_elliptic is near zero with q={q}, r={r}.")
            # Fallback
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.6; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback
        m_elliptic = (q - 1) / denom_m_elliptic

        if not (0 <= m_elliptic <= 1):
             print(f"Warning: Elliptic parameter m={m_elliptic:.4f} is outside [0,1]. Elliptic integrals might be complex or behave unexpectedly. Clamping m.")
             m_elliptic_clamped = np.clip(m_elliptic, 0, 1)
        else:
            m_elliptic_clamped = m_elliptic

        try:
            ell_F_values = ellipkinc(theta_values, m_elliptic_clamped) # F(theta | m)
            ell_E_values = ellipeinc(theta_values, m_elliptic_clamped) # E(theta | m)
        except Exception as e:
            print(f"Error calculating elliptic integrals: {e}")
            # Fallback
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.6; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback


        # Calculate Z_dimless_profile (Koussios Thesis, Eq. 4.20)
        coeff_Z_den_sq_term = 1 + 2 * q * (1 + r)
        if coeff_Z_den_sq_term < 0: # Should be caught by r_limit check
             print(f"ERROR: Term under square root for Z coefficient is negative ({coeff_Z_den_sq_term}).")
             R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.6; self.dome_height = dome_h_fallback
             t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        coeff_Z_factor = Y_min_dimless_raw / math.sqrt(coeff_Z_den_sq_term)
        
        term_E_component = (1 + 2 * q * (1 + r)) * ell_E_values
        term_F_component = (1 + q + q * r) * ell_F_values
        
        Z_dimless_profile = coeff_Z_factor * (term_E_component - term_F_component)
        # This Z_dimless_profile, for theta from pi/2 (pole) to 0 (equator),
        # goes from DomeHeight_dimless down to 0.

        dome_height_dimless = Z_dimless_profile[0] # Value at theta = pi/2
        actual_dome_height_m = dome_height_dimless * rho_0_adjusted
        # self.dome_height is set in the calling generate_profile method

        # Calculate physical rho values using Koussios Thesis Eq. 4.12
        # Y(theta) = sqrt(Y_eq_dimless_raw^2 * cos^2(theta) + Y_min_dimless_raw^2 * sin^2(theta))
        rho_dimless_profile = np.sqrt(
            Y_eq_dimless_raw**2 * np.cos(theta_values)**2 + \
            Y_min_dimless_raw**2 * np.sin(theta_values)**2
        )
        # This rho_dimless_profile goes from Y_min_dimless_raw (at theta=pi/2) to Y_eq_dimless_raw (at theta=0)
        rho_abs_profile = rho_dimless_profile * rho_0_adjusted
        # So rho_abs_profile goes from actual_dome_polar_radius to actual_dome_equatorial_radius (self.inner_radius)

        # z_local_dome_abs should go from actual_dome_height_m (at pole) down to 0 (at cylinder junction)
        z_local_dome_abs = Z_dimless_profile * rho_0_adjusted
        
        # Return (rho, z_local_dome) ordered from the dome's effective polar opening to its equatorial junction
        # This order is: rho increasing, z_local decreasing.
        return np.vstack((rho_abs_profile, z_local_dome_abs)).T, actual_dome_height_m

```

**Important considerations for this implementation:**

1.  **Elliptic Integrals:** Make sure `ellipkinc` and `ellipeinc` from `scipy.special` are used correctly. They typically take `phi` (our `theta_values`) and `m` (our `m_elliptic`, which should be $k^2$, where $0 \le m \le 1$). I've added a clamp for `m_elliptic` just in case.
2.  **`rho_0_adjusted`:** The logic for `rho_0_adjusted = self.inner_radius / Y_eq_dimless_raw` is key. It ensures that the calculated dimensionless $Y_{eq}$ for the dome, when scaled by `rho_0_adjusted`, matches the `self.inner_radius` of the cylinder part. The "pole" of this calculated dome segment will then be at radius $Y_{min\_dimless\_raw} \times rho\_0\_adjusted$. This becomes the `actual_dome_polar_radius`.
3.  **Ordering of Points:** The `theta_values` are generated from $\pi/2$ (pole) down to $0$ (equator).
    * `rho_abs_profile` will correctly go from `actual_dome_polar_radius` up to `self.inner_radius`.
    * `z_local_dome_abs` (which is $Z_{dimless\_profile} \times rho\_0\_adjusted$) will go from `actual_dome_height_m` down to approximately `0`.
    This is the correct order for `local_dome_pts` that `generate_profile` expects.
4.  **Error Handling/Edge Cases for `q` and `r`:**
    * Added checks for denominators becoming zero in $Y_{min}/Y_{eq}$ and $m_{elliptic}$ calculations.
    * Added a check for the $r_{limit}$ based on Koussios Eq. 4.15 ($r \ge -\frac{1+q}{2q}$) to prevent math domain errors in `sqrt(num_Y_calc)`. If `r` is below this limit, `num_Y_calc` can be negative.
5.  **Placeholder Fallback:** The `try-except` block and other error checks should ideally fall back to a simpler shape or raise a more informative error if the q,r parameters lead to unphysical results or numerical issues. The current fallback is very basic.

**To test this:**
You'll need to modify your `main.py` or a test script to:
1.  Set `dome_type="Isotensoid"`.
2.  Call `vessel.set_qrs_parameters(q=..., r=..., s=...)` with valid `q` and `r` values (e.g., Koussios Ch. 4 example: $q=57.66$, $r=-0.168$ was used for a vessel where $Y_{min} \approx 1.016$ and $Y_{eq} \approx 7.718$. If $\rho_0$ is the actual polar opening, $Y_{min}$ from formula should be $>1$. If $\rho_0$ is a general reference, then $Y_{min}$ from formula can be 1). A simple start could be $q=5$, $r=0$ (or slightly negative like $r = -1/(2q)$ which is $-0.1$ for $q=5$).
3.  Then call `vessel.generate_profile()` and plot.

The key will be to see if `rho_abs_profile[0]` (the start of the dome rho) makes sense as a polar opening and if `rho_abs_profile[-1]` correctly matches `self.inner_radius`, and if the `z_local_dome_abs` correctly goes from `actual_dome_height_m` down to near zero.