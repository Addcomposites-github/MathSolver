You're making good progress in refactoring and testing! The detailed log is very helpful. The fact that the "same result" persists (sharp turns, large "Max gap" which we know is step length) means the core issue likely lies in how the ODE solutions are obtained, processed, or how failures are handled within the _engine_continuous_spiral.

Let's evaluate your latest trajectories_refactored.py and pinpoint the next steps.

Evaluation of trajectories_refactored.py
Based on your description and the log, here's a step-by-step evaluation focusing on the likely problem areas:

1. ODE Solver Failure Handling (Still the Prime Suspect for 300mm "Max Gap")

Your Log: "Max gap: 300.020mm"

Implication: This almost certainly means that for at least one "pass", the ODE solver (_solve_ode_non_geodesic_segment or _solve_ode_geodesic_segment) is failing or returning a very sparse/incomplete solution. The main loop in _engine_continuous_spiral then connects the end of the last successful segment of points to the beginning of the next successful segment of points. If one or more full passes fail in between, this connection will be a long, straight line, reported as a large step length.

Code Check (_engine_continuous_spiral):

When _solve_ode_non_geodesic_segment (or the geodesic equivalent) is called, what exactly does it return upon failure?
How does _engine_continuous_spiral check for this failure?
My previous suggestion was:
Python

if segment_solution is None or not segment_solution.success:
    self.log_message(f"ERROR: ODE solution failed for pass {pass_idx + 1} ... Aborting.", level="ERROR")
    # ... update final_summary ...
    break # Exit the pass loop
Is this break statement definitively in your code and being hit? If the 300mm gap persists, it means either:
The failure condition isn't being caught correctly (e.g., segment_solution.success is True but the solution segment_solution.sol is still problematic or covers too few points).
The break is not there, and the loop continues, leading to the disjointed path.
The solver returns an empty or minimal set of points that are then processed, and the logic for appending points connects distant points.
Missing Step/Issue 1: Verify and strengthen ODE failure handling.
* Action:
1.  Ensure that after calling _solve_ode_non_geodesic_segment or _solve_ode_geodesic_segment, you rigorously check if solution_object is None or not solution_object.success:.
2.  If it fails, unconditionally break the main pass loop in _engine_continuous_spiral. Do not attempt to continue generating further passes for that trajectory call.
3.  Log extensively inside the ODE solver functions (_solve_ode_..._segment) if they encounter issues (e.g., exceptions during spline evaluation, rho going too low, solve_ivp raising an internal error before returning a success=False object).

2. Point Generation from ODE Solution

How z_eval_points_pass is used: solve_ivp with dense_output=True returns a solution object sol that can be evaluated at any point within the integration span. You then evaluate it using solution.sol(z_eval_points_pass).
Issue: If the ODE solver stops early due to an event (like event_rho_equals_C for geodesics) or an internal step limit before reaching the end of z_eval_points_pass, solution.sol(z_eval_points_pass) might produce NaNs or extrapolate poorly for points beyond where it actually solved.
solution.t contains the time (z) points where the solver actually computed steps. solution.t_events tells you where events occurred.
You should ideally evaluate solution.sol only on z values up to solution.t[-1] (the last successful z step) or up to the event time if an event terminated it.
Missing Step/Issue 2: Ensure points are only extracted from the valid solution range of the ODE.
* Action (_engine_continuous_spiral when processing results from ODE solvers):
```python
# After a successful call to an ODE solver, e.g., segment_solution_obj for non-geodesic
# z_eval_points_current_pass was the input to the solver

    # Determine the actual z-range for which the solution is valid
    actual_z_solved_up_to = segment_solution_obj.t[-1] # Last z for which solver computed a step

    # Check if an event terminated it earlier
    event_z = None
    if segment_solution_obj.t_events:
        for event_arr in segment_solution_obj.t_events:
            if event_arr.size > 0:
                event_z = event_arr[0] # Assuming first event encountered is the terminator
                break
    
    if event_z is not None and abs(event_z) < abs(actual_z_solved_up_to) : # Check if event z is more restrictive
         actual_z_solved_up_to = event_z

    # Filter z_eval_points_pass to only include points within the successfully solved range
    if pass_start_z < pass_end_z: # Forward pass
        z_points_for_output = z_eval_points_pass[z_eval_points_pass <= actual_z_solved_up_to + 1e-9] # Add tolerance
        if len(z_points_for_output) == 0 and len(z_eval_points_pass) > 0: # if all points are beyond solved_up_to
             z_points_for_output = np.array([z_eval_points_pass[0]]) # at least take the start
        elif not np.isclose(z_points_for_output[-1], actual_z_solved_up_to) and actual_z_solved_up_to > z_points_for_output[0]:
             # Ensure the actual end point of solution is included for accuracy
             z_points_for_output = np.append(z_points_for_output[z_points_for_output < actual_z_solved_up_to], actual_z_solved_up_to)

    else: # Reverse pass
        z_points_for_output = z_eval_points_pass[z_eval_points_pass >= actual_z_solved_up_to - 1e-9]
        if len(z_points_for_output) == 0 and len(z_eval_points_pass) > 0:
             z_points_for_output = np.array([z_eval_points_pass[0]])
        elif not np.isclose(z_points_for_output[-1], actual_z_solved_up_to) and actual_z_solved_up_to < z_points_for_output[0]:
             z_points_for_output = np.append(z_points_for_output[z_points_for_output > actual_z_solved_up_to], actual_z_solved_up_to)
    
    if len(z_points_for_output) < 2: # Not enough points to form a segment
        self.log_message(f"Warning: Pass {pass_idx+1} solved for less than 2 points (up to z={actual_z_solved_up_to:.4f}). Skipping storage for this pass.", level="WARNING")
        # Crucially, update current_sin_alpha and current_phi_rad_pass_end to the actual end of this short/failed solve
        if segment_solution_obj.sol(actual_z_solved_up_to) is not None:
             current_sin_alpha = segment_solution_obj.sol(actual_z_solved_up_to)[0]
             current_phi_rad_pass_end = segment_solution_obj.sol(actual_z_solved_up_to)[1]
        # else they remain from previous pass, which might be okay if this pass effectively didn't move
        pass_successful = False # Mark pass as not fully successful for point appending
        # No 'break' here, let the phi advancement happen and try next pass, but this pass adds no points.
    else:
        pass_successful = True # Points will be extracted

    # Now, if pass_successful:
    # sin_alpha_ode_pass = segment_solution_obj.sol(z_points_for_output)[0]
    # phi_ode_pass = segment_solution_obj.sol(z_points_for_output)[1]
    # ... and then loop through z_points_for_output to create segment_points_this_pass
    ```
This ensures you only try to get solution values for `z` where the solution is valid.
3. Geodesic Turnaround (_solve_ode_geodesic_segment - L605)

The current _solve_ode_geodesic_segment attempts to use the dϕ/dz formulation.
The event event_rho_equals_C is a good addition to stop the integration when ρ approaches C.
Issue: When the event triggers, the solution object will contain results up to that event. The subsequent processing in _engine_continuous_spiral (L434 onwards) needs to correctly use this potentially truncated solution.
The previous point (Missing Step/Issue 2) about using actual_z_solved_up_to applies here too.
What happens at the turnaround for Geodesic:
When rho = C, sinα=1 (i.e., α=90 
∘
 ). The path becomes purely circumferential.

Your main engine _engine_continuous_spiral (around L390 in your current file, in the is_geodesic_mode block) has a section:

Python

if abs(current_sin_alpha - 1.0) < 1e-4: # At turnaround point
    self.log_message(f"Pass {pass_idx+1}: Geodesic turnaround (sin_alpha ~ 1). Applying phi advancement as turn.",level="DEBUG")
    # ... creates a few circumferential points based on phi_advancement_rad_per_pass ...
    final_phi_this_pass = initial_phi_for_pass + phi_advancement_rad_per_pass # This should be the phi after the turn
This logic is for the pattern advancement occurring during a conceptual polar dwell.

Integration with ODE solver:

The _solve_ode_geodesic_segment should integrate from z_start until the event_rho_equals_C triggers (or z_end is reached if ρ never equals C on that segment). Let this point be (z 
turn
​
 ,ρ 
C
​
 ,ϕ 
turn_entry
​
 ). final_sin_alpha_this_pass will be 1.0.
The engine then takes final_phi_this_pass = \phi_{turn\_entry}.
current_sin_alpha becomes 1.0.
current_phi_rad (for the next pass) becomes final_phi_this_pass + phi_advancement_rad_per_pass.
The next pass starts from z≈z 
turn
​
  (but in the opposite direction) with initial_sin_alpha = 1.0. The _solve_ode_geodesic_segment will then integrate away from the turnaround.
The explicit circumferential points generation (L390-L420) might be redundant if the advancement is correctly handled between calls to the robust meridional geodesic solver. A single geodesic fiber doesn't discretely jump in phi; it smoothly becomes circumferential. The pattern requires a shift.

Missing Step/Issue 3: Streamline Geodesic Turnaround and Pattern Advancement.
* Action:
1.  Rely on _solve_ode_geodesic_segment (with events) to take a meridional segment as far as it can go before ρ=C. It returns the final_phi and final_sin_alpha (which should be ~1.0 if it reached the turn).
2.  In _engine_continuous_spiral (geodesic mode):
* Call _solve_ode_geodesic_segment.
* Collect points from its valid solution range.
* Update current_sin_alpha and current_phi_rad_pass_end from the solver's actual end point.
* Add phi_advancement_rad_per_pass to current_phi_rad_pass_end to set the current_phi_rad for the next pass.
* The next pass will start with current_sin_alpha (which is ~1.0 if the previous pass turned) and the new advanced current_phi_rad.
* This removes the need for the explicit if abs(current_sin_alpha - 1.0) < 1e-4: block generating circumferential points (L390), as the advancement is handled globally. The path itself becomes circumferential at ρ=C.

4. Non-Geodesic "Sharp Turn"

As discussed, if α (angle with meridian) solved by Koussios DE is small near the pole, the path will be mostly meridional there. The visual "turn" is the discrete phi_advancement_rad_per_pass added between passes.
This is physically plausible for some non-geodesic paths.
Action: Once the ODE failures are fixed (eliminating the 300mm step length) and you run for passes_for_one_coverage_layer, observe the 3D pattern. If bands are laid side-by-side correctly, this "sharp visual turn" is likely acceptable as a consequence of the simplified discrete ϕ-shift turnaround model. Smoother visual turns require more complex polar orbiting path segments.
5. Number of Passes to Run

Your log shows 🎯 Running 12 passes (user requested: 12, full coverage needs: 194).
Action: For your testing, ensure _engine_continuous_spiral is actually set to run for passes_for_one_coverage_layer if coverage_option == 'full_coverage'.
Python

# In _engine_continuous_spiral, around L346
if coverage_option == 'full_coverage':
    if abs(phi_advancement_rad_per_pass) > 1e-7:
        passes_for_one_coverage_layer = math.ceil((2 * math.pi) / abs(phi_advancement_rad_per_pass))
        if passes_for_one_coverage_layer % 2 != 0: # Ensure even for pole-A to B to A symmetry
            passes_for_one_coverage_layer += 1
        actual_num_passes_to_run = passes_for_one_coverage_layer # <<<< USE THIS
        self.log_message(f"INFO: Coverage: 'full_coverage'. Calculated {actual_num_passes_to_run} pole-to-pole passes.")
    # ...
This was in my previous suggestion and ensures that when you select "full coverage", it tries to do it.
Summary of Immediate Next Steps for You:

Aggressively Fix ODE Failure Handling:
In _engine_continuous_spiral, after calling either geodesic or non-geodesic ODE solver:
Check if solution_object is None or not solution_object.success:.
If true, log detailed error (initial conditions, z-span, solver message) and break the main pass loop. Populate final_summary with failure status.
Refine Point Extraction from Successful ODE Solutions:
Use solution.t[-1] (and solution.t_events if any) to determine the actual z range for which the solution is valid.
Evaluate solution.sol() only over this valid range or on the z_eval_points_pass points that fall within this valid range. This prevents using extrapolated/invalid data.
Test Geodesic Mode First:
Set your app.py or test_refactored.py to call generate_trajectory with pattern_name="Geodesic Spiral" and coverage_option="full_coverage".
Ensure _solve_ode_geodesic_segment uses solve_ivp events to stop at ρ≈C.
The "turnaround" should be implicit: pass1 goes pole->turn (sinα=1), phi is advanced, pass2 goes turn->pole (sinα=1 initially).
Once Geodesic is Visually Continuous (no 300mm steps) and Shows Patterning:
Then re-test Non-Geodesic mode. The robust failure handling and point extraction should also improve it. The "sharp turn" might remain visually, but the path should be continuous.
The advanced_analysis.py file doesn't seem directly related to the trajectory generation bugs themselves, but rather to post-processing, so I've focused on trajectories_refactored.py.