The error message "Error: No valid trajectory points generated" combined with your earlier debug logs indicates that the `generate_geodesic_trajectory` method is likely failing because it cannot find a sufficient segment of the vessel profile where the condition $\rho \ge c_{eff}$ (local radius is greater than or equal to the effective polar opening radius) is met.

This usually happens if:
1.  The calculated `c_eff` is too large, potentially larger than the vessel's maximum radius (e.g., the cylinder radius).
2.  The vessel's geometric profile itself is very small relative to the roving dimensions, leading to a large `c_eff`.

Your `_calculate_effective_polar_opening()` method prints the calculated `c_eff`. Let's look at that output along with the profile dimensions.

**Please provide the full debug output from your script when you run the trajectory calculation, specifically including:**

1.  The debug lines from `VesselGeometry.generate_profile()` (if it's called again).
2.  The debug lines from `TrajectoryPlanner.__init__()`.
3.  The debug lines from `TrajectoryPlanner._calculate_effective_polar_opening()`, especially:
    * `Debug _calc_eff_polar: rho_geom_pole_m=..., dz_drho_pole=..., c_eff=... m`
4.  The debug lines from the beginning of `TrajectoryPlanner.generate_geodesic_trajectory()`, especially:
    * `DEBUG generate_geodesic_trajectory: Using c_eff = ... m`
    * `DEBUG: Original profile Z range: ...m to ...m`
    * `DEBUG: Original profile R range: ...m to ...m`
5.  And then any subsequent error messages or the point where it prints "Error: Not enough windable profile points found..." or "Error: No valid trajectory points generated...".

**Key things we are looking for in that output:**

* **Value of `c_eff`**: Is it reasonable? For your vessel with a 100mm (0.1m) cylinder radius and a 0mm geometric pole, `c_eff` should ideally be small, positive, and certainly less than 0.1m.
* **Comparison of `c_eff` with `profile_r_m_orig`**: If `c_eff` is greater than the maximum radius in your profile, then `windable_indices` will be empty, and the function will exit with the error you see. The code already has a print statement for this specific case:
    ```python
    if len(windable_indices) < 2:
        print(f"Error: Not enough windable profile points found (rho >= c_eff={c_eff:.4f}m). Max rho in profile: {np.max(profile_r_m_orig):.4f}m")
        if len(profile_r_m_orig) > 0 and c_eff > np.max(profile_r_m_orig):
             print(f"  Reason: c_eff ({c_eff:.4f}m) is larger than max profile radius ({np.max(profile_r_m_orig):.4f}m).")
        return None
    ```
    If you see this "Reason: c_eff ... is larger than max profile radius", that's the direct cause.

**Potential issues in `_calculate_effective_polar_opening()` leading to a large `c_eff`:**

* **`dz_drho_pole` calculation:** If the slope `dz_drho_pole` is very large (or `np.inf` if not handled carefully) and the logic for infinite slope in `c_eff` calculation is problematic, it might inflate `c_eff`. The current code for `np.inf` slope is:
    ```python
    effective_slope_term = (b_m / 2.0) * abs(dz_drho_pole) if np.isinf(dz_drho_pole) else (b_m / 2.0) * math.sqrt(1 + dz_drho_pole**2)
    thickness_term_effect = (t_rov_m / 2.0) * dz_drho_pole if not np.isinf(dz_drho_pole) else (t_rov_m / 2.0) * np.sign(dz_drho_pole) * 1e6
    ```
    If `dz_drho_pole` is a very large positive number (e.g., $10^8$), then `effective_slope_term` and `thickness_term_effect` can become huge. For a dome closing towards the pole, `dz/drho` should be negative if z increases towards the pole and rho decreases, or positive if z decreases towards the pole. The actual first segment of your elliptical dome `r_inner=[0, 3.2], z=[250, 249.94]` gives $dz/dr \approx (249.94-250)/(3.2-0) = -0.06/3.2 \approx -0.01875$. This is a small, finite negative slope.
* **Units:** Double-check units passed to `TrajectoryPlanner` for roving width, thickness, eccentricity. My last suggested `__init__` for `TrajectoryPlanner` assumes these are passed in *meters*. If you are passing them in `mm` and they are not converted before being used with `rho_geom_pole_m` (which *is* converted to meters), this will cause `c_eff` to be enormous.

Let's verify the units passed to `TrajectoryPlanner` when you instantiate it.
Example:
```python
planner = TrajectoryPlanner(
    vessel_geometry=vessel_geom,
    dry_roving_width_m=0.006,  # 6mm in METERS
    dry_roving_thickness_m=0.0003, # 0.3mm in METERS
    roving_eccentricity_at_pole_m=0.0 # in METERS
)
```
If these are passed as, e.g., `6` instead of `0.006`, then `c_eff` would be far too large.

Once we see the debug output including the `c_eff` value and the profile ranges, we can pinpoint the cause of the "No valid trajectory points generated" error.