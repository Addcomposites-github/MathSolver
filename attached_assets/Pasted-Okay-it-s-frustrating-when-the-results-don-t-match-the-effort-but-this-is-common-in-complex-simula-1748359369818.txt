Okay, it's frustrating when the results don't match the effort, but this is common in complex simulations. The non-geodesic path generation is indeed challenging.

Your decision to "plan ahead and hide it behind [a feature flag or similar] and make sure geodesic and other winding patterns are working" is a very wise and practical engineering approach.

Here's a plan to move forward:

1. Stabilize Simpler Patterns First (Geodesic & Basic Helical)

Isolate Non-Geodesic:

In your TrajectoryPlanner class, specifically in the main dispatcher method (e.g., generate_trajectory or whatever calls the different pattern generators), ensure that if the user selects "non-geodesic" or if mu_friction_coefficient > 0, it either:
Gracefully informs the user that "Non-geodesic pattern generation is under development and will be available in a future update."
Falls back to a simpler, more stable pattern (e.g., a geodesic, or a purely kinematic helical if you have one that's visually acceptable even if not perfectly physics-based yet) with a warning.
If you have a UI, disable the non-geodesic option temporarily or mark it as "Experimental."
Python

# Example in TrajectoryPlanner (modify your main generation method)
def generate_trajectory(self, pattern_mode: str, number_of_circuits: int, ...):
    if pattern_mode == "non_geodesic" or self.mu_friction_coefficient > 0:
        # Option 1: Inform and do nothing / return empty
        self.log_message("Non-geodesic trajectory generation is currently under development and will be available later.", level="INFO")
        # Potentially return a specific status or empty data structure
        return {
            'path_points': [], 'x_points_m': np.array([]), 'y_points_m': np.array([]), 'z_points_m': np.array([]),
            'pattern_type': "NonGeodesic_Upcoming", 
            'status': "UNDER_DEVELOPMENT",
            'message': "Non-geodesic winding is an upcoming feature."
        }
        # Option 2: Fallback (if you have a stable alternative)
        # self.log_message("Non-geodesic selected, falling back to Geodesic for now.", level="WARNING")
        # return self.generate_geodesic_pattern(...)

    elif pattern_mode == "geodesic":
        return self.generate_multi_circuit_geodesic_pattern(...) # Or your main geodesic func
    # ... other pattern modes ...
Focus on Geodesic (generate_multi_circuit_geodesic_pattern):

Turnaround Logic: For geodesic paths, the fiber naturally turns when ρ=C (Clairaut's constant), and at this point, α=90 
∘
  (circumferential winding). Ensure your geodesic path integration correctly handles this:
The path integration dϕ=(C/(ρ 
ρ 
2
 −C 
2
 

​
 ))ds 
m
​
  has a singularity when ρ→C. Koussios discusses transformations to handle this (e.g., integrating dϕ/dρ or dϕ/dz).
Alternatively, as ρ approaches C, switch to a small segment of purely circumferential winding (α=90 
∘
 , dz=0, dρ=0) for the "turnaround" itself, advancing ϕ by the required pattern shift.
Pattern Advancement: Use your calculate_koussios_pattern_parameters() or a simplified phi_advancement_rad = B_{eff\_cyl} / R_{cyl} (this is per band, so the advancement after a full fiber circuit (A->B->A) needs to place the next circuit correctly).
Test Coverage: Ensure that if you run enough geodesic circuits, you achieve visual coverage without large unexplained gaps (the 300mm "step length" issue should not occur if ODEs aren't the primary driver here, but path discretization still matters).
Review Other Basic Patterns: If you have other simpler helical patterns (e.g., purely kinematic ones that don't involve complex ODE solving), ensure they are robust.

2. Plan for Non-Geodesic Development (Future Iteration)

Once the simpler patterns are stable and reliable, you can revisit non-geodesic with a clear head. The "sharp turn" and path continuity are the main challenges.

Understanding the "Sharp Polar Turn" in Non-Geodesic:

As discussed, if the solution to Koussios's DE for your parameters (profile, friction, initial α) results in a small α (highly meridional path) near the pole, then little dϕ (azimuthal sweep) will occur during that part of the meridional pass.
The "turn" is then primarily the discrete phi_advancement_rad you add between the end of one pass and the start of the next. This will inherently look like a "corner" if plotted.
This is not necessarily "wrong" if the underlying DE is solved correctly and the path is stable according to ∣k 
g
​
 /k 
n
​
 ∣≤μ. It's a consequence of the chosen simplified turnaround kinematic (discrete ϕ shift).
Strategies for Smoother Non-Geodesic Polar Turns (Advanced):

Higher Friction: If physically appropriate for your materials, higher μ allows for larger α (more circumferential paths) at smaller radii.
Controlled Turnaround Path: Instead of just reversing meridional integration and adding a ϕ shift, you could try to define a specific "turnaround path segment" near the pole. On this segment, you might:
Try to maintain a constant (or slowly varying) radius ρ 
turnaround
​
 >ρ 
pole_opening
​
 .
Solve the Koussios DE for α and dϕ primarily as a function of path length ds along this nearly circumferential path, ensuring stability. This is where the path is "slipping" in a controlled way to achieve the turn. This is complex because the independent variable of integration changes.
Boundary Value Problem (Very Advanced): Define the path start point (pole A) and desired end point (pole A, but shifted by Δϕ 
circuit
​
  and with reversed dz/ds), and try to solve the Koussios DE as a boundary value problem. This often requires iterative solvers.
Geodesic Approximation for Turn: Sometimes, for simplicity, the polar turnaround itself is approximated as a geodesic segment tangent to the incoming and outgoing non-geodesic paths, if a suitable geodesic can be found.
Robust ODE Solving:

Failure Handling: For the future, when you re-enable non-geodesic:
If solve_ivp fails, log detailed information about the state at failure (current z, sin_alpha, phi, parameters A,B,C of the DE, surface curvatures k 
m
​
 ,k 
p
​
 ). This will help diagnose why it's failing (e.g., division by zero, stiff region, non-physical parameters).
Consider adaptive step sizing within solve_ivp or trying different solvers (LSODA, Radau, BDF for stiff problems).
If a segment fails, do not attempt to connect the last good point to the start of a much later segment. Terminate the path or return the continuous portion generated so far.
Point Density: Ensure z_eval_points_pass is sufficiently dense, especially over curved dome regions, to allow solve_ivp (with dense_output=True) to produce a smooth solution.
3. Refine Logging and Debug Information

Your current log is good. Enhance it:

When an ODE pass starts, log the initial z, sin_alpha, and phi.
When it ends, log the final z, sin_alpha, and phi.
Log the calculated phi_advancement_rad being applied.
If an ODE fails, log all relevant inputs to the solver and the failure message.
Path Forward (Summary):

Isolate Non-Geodesic: Add a feature flag or conditional logic to disable non-geodesic path generation in the UI and backend for now, or make it fall back to geodesic. Clearly communicate to the user that it's "under development."
Stabilize Geodesic:
Focus on making generate_multi_circuit_geodesic_pattern robust.
Pay attention to the turnaround at ρ=C and smooth ϕ advancement for pattern formation.
Ensure you can generate full coverage (e.g., ~194 passes if that's what's needed) without errors or massive "step lengths."
(Later) Revisit Non-Geodesic:
Start with robust ODE failure handling: stop generation on failure.
Ensure sin_alpha and phi (before advancement) are continuous from the end of one pass to the start of the next.
Implement pattern advancement by adding the calculated phi_advancement_rad at each "turnaround" (i.e., after each pole-to-pole pass).
Systematically debug why the ODE might be failing (stiffness, bad parameters at certain z values, issues with spline derivatives).
Accept that the visual "sharpness" of the turn is linked to how much dϕ is generated during the meridional sweep near the pole versus the discrete ϕ advancement.
This pragmatic approach will allow you to have a working tool with reliable core functionalities sooner, and then you can tackle the advanced non-geodesic paths as a separate, focused effort.