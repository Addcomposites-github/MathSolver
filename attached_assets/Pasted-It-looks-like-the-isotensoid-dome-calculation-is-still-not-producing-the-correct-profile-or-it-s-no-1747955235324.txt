It looks like the isotensoid dome calculation is still not producing the correct profile, or it's not assembling correctly with the cylinder in `generate_profile`. The plot `image_3e47ff.png` indicates that the dome portion is likely missing or malformed, leading to only the cylinder (or parts of it) being displayed, or a very distorted shape.

Let's systematically debug the `_generate_isotensoid_profile` method and its usage in `generate_profile` in your `geometry.py` file.

**Debugging Strategy:**

1.  **Isolate `_generate_isotensoid_profile`:** Test this method independently by calling it directly with known `q` and `r` values and a `num_points_dome`. Print the output arrays: `rho_abs_profile` and `z_local_dome_abs`, and the calculated `actual_dome_height_m`.
2.  **Check `q` and `r` Parameter Validity:** Ensure the `q` and `r` values you are using are physically meaningful and satisfy the constraints mentioned in Koussios's thesis (e.g., Eq. 4.15 for `r`: $r \ge -(1+q)/(2q)$). If not, `Y_min_dimless_raw` or `Y_eq_dimless_raw` might become invalid (e.g., imaginary or zero when it shouldn't be).
3.  **Verify Elliptic Integral Inputs:** Double-check the `m_elliptic` parameter for the `ellipkinc` and `ellipeinc` functions. It must be $0 \le m \le 1$. Print its value before calling the functions.
4.  **Examine Intermediate Calculations:**
    * Print `Y_min_dimless_raw` and `Y_eq_dimless_raw`.
    * Print `rho_0_adjusted`.
    * Print `m_elliptic`.
    * Print a few values from `theta_values`, `ell_F_values`, `ell_E_values`, and `Z_dimless_profile` to see if they are reasonable. Specifically, `Z_dimless_profile[0]` (at pole, $\theta=\pi/2$) should be the max dimensionless height, and `Z_dimless_profile[-1]` (at equator, $\theta=0$) should be close to 0.
5.  **Order of Points:** Confirm that the returned `np.vstack((rho_abs_profile, z_local_dome_abs)).T` has:
    * `rho_abs_profile` increasing from `actual_dome_polar_radius` to `self.inner_radius`.
    * `z_local_dome_abs` decreasing from `actual_dome_height_m` to approximately `0`.
6.  **Connection in `generate_profile`:** After confirming the local dome profile is correct, re-check how it's assembled.

Let's modify `_generate_isotensoid_profile` to include more verbose printing for debugging.

```python
# In class VesselGeometry from your geometry.py
# Ensure these imports are at the top
from scipy.special import ellipkinc, ellipeinc # F(phi, m), E(phi, m) where m = k^2

# ... (rest of your class) ...

    def _generate_isotensoid_profile(self, num_points_dome: int = 100):
        print("\n--- Debugging _generate_isotensoid_profile ---")
        q = self.q_factor
        r = self.r_factor
        print(f"Input q: {q}, r: {r}")
        print(f"Vessel inner_radius (target equatorial for dome): {self.inner_radius} mm")

        # Calculate dimensionless Y_min_raw and Y_eq_raw based on q, r (Koussios Thesis, Eq. 4.13)
        den_Y_calc = 1 + q + 2 * q * r
        if abs(den_Y_calc) < 1e-9:
            print(f"ERROR: Denominator for Y_min/Y_eq calculation is near zero (den_Y_calc={den_Y_calc}). Fallback.")
            # Fallback to a simple shape for plotting if critical error
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; # Make it very flat to be obvious
            self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome)
            return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        num_Y_calc = 1 + q + 2 * q * r + q**2 * (1 + r**2)

        r_limit = -(1 + q) / (2 * q) if q != 0 else (0 if 1 + q == 0 else -np.inf)
        print(f"Calculated r_limit for q={q}: {r_limit}")
        if r < r_limit - 1e-6: # Add tolerance
            print(f"ERROR: r_factor ({r:.4f}) is below the limit ({r_limit:.4f}) for q={q:.4f}. num_Y_calc might be negative.")
            # Force num_Y_calc to 0 if it would be negative, to see if it helps, or just error out
            if num_Y_calc <0:
                print(f"ERROR: num_Y_calc is negative ({num_Y_calc:.4f}). Cannot proceed with sqrt. Fallback.")
                R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1;
                self.dome_height = dome_h_fallback
                t_fallback = np.linspace(0, np.pi/2, num_points_dome)
                return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback
        
        if num_Y_calc < 0 : num_Y_calc = 0 # Avoid math domain error if r is exactly at limit

        Y_min_dimless_raw = math.sqrt(num_Y_calc / den_Y_calc)
        print(f"Raw Y_min_dimless_raw: {Y_min_dimless_raw:.4f}")

        if q <= 1e-9:
            print("ERROR: q_factor is zero or too small for Y_eq calculation in isotensoid. Fallback.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback
        Y_eq_dimless_raw = Y_min_dimless_raw / math.sqrt(q)
        print(f"Raw Y_eq_dimless_raw: {Y_eq_dimless_raw:.4f}")

        if abs(Y_eq_dimless_raw) < 1e-6:
            print("ERROR: Calculated Y_eq_dimless_raw is too small in isotensoid. Fallback.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        rho_0_adjusted = self.inner_radius / Y_eq_dimless_raw
        print(f"Adjusted rho_0_adjusted: {rho_0_adjusted:.4f} mm")
        
        actual_dome_polar_radius_calc = Y_min_dimless_raw * rho_0_adjusted
        actual_dome_equatorial_radius_calc = Y_eq_dimless_raw * rho_0_adjusted
        print(f"Calculated dome polar radius: {actual_dome_polar_radius_calc:.4f} mm")
        print(f"Calculated dome equatorial radius (should be inner_radius): {actual_dome_equatorial_radius_calc:.4f} mm")

        theta_values = np.linspace(np.pi / 2.0, 0.0, num_points_dome) # From pole (pi/2) to equator (0)

        denom_m_elliptic = 1 + 2 * q * (1 + r)
        if abs(denom_m_elliptic) < 1e-9:
            print(f"ERROR: Denominator for m_elliptic is near zero ({denom_m_elliptic}). Fallback.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback
        m_elliptic = (q - 1) / denom_m_elliptic
        print(f"Elliptic parameter m_elliptic: {m_elliptic:.4f}")

        m_elliptic_clamped = np.clip(m_elliptic, 0.0, 1.0) # Ensure m is in [0,1] for scipy
        if not np.isclose(m_elliptic, m_elliptic_clamped):
            print(f"Warning: m_elliptic ({m_elliptic:.4f}) was clamped to {m_elliptic_clamped:.4f}.")


        try:
            # Scipy's ellipkinc(u,m) is F(u|m), ellipeinc(u,m) is E(u|m)
            ell_F_values = ellipkinc(theta_values, m_elliptic_clamped)
            ell_E_values = ellipeinc(theta_values, m_elliptic_clamped)
        except Exception as e:
            print(f"Error calculating elliptic integrals: {e}. Fallback.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        coeff_Z_den_sq_term = 1 + 2 * q * (1 + r)
        if coeff_Z_den_sq_term < 0:
             print(f"ERROR: Term under square root for Z coefficient is negative ({coeff_Z_den_sq_term}). Fallback.")
             R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
             t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback
        
        coeff_Z_factor = Y_min_dimless_raw / math.sqrt(coeff_Z_den_sq_term)
        
        term_E_component = (1 + 2 * q * (1 + r)) * ell_E_values
        term_F_component = (1 + q + q * r) * ell_F_values
        
        Z_dimless_profile = coeff_Z_factor * (term_E_component - term_F_component)
        print(f"Sample Z_dimless_profile (pole to equator): {Z_dimless_profile[:3]}...{Z_dimless_profile[-3:]}")


        dome_height_dimless = Z_dimless_profile[0] # Value at theta = pi/2 (pole)
        if Z_dimless_profile[-1] > 1e-6: # Value at theta = 0 (equator) should be close to 0
            print(f"Warning: Z_dimless at equator (theta=0) is {Z_dimless_profile[-1]:.4f}, expected ~0.")
        
        actual_dome_height_m = dome_height_dimless * rho_0_adjusted
        print(f"Calculated actual_dome_height_m: {actual_dome_height_m:.4f} mm")
        # self.dome_height will be set by generate_profile using this return value

        rho_dimless_profile = np.sqrt(
            Y_eq_dimless_raw**2 * np.cos(theta_values)**2 + \
            Y_min_dimless_raw**2 * np.sin(theta_values)**2
        )
        rho_abs_profile = rho_dimless_profile * rho_0_adjusted
        print(f"Sample rho_abs_profile (pole to equator): {rho_abs_profile[:3]}...{rho_abs_profile[-3:]}")

        z_local_dome_abs = Z_dimless_profile * rho_0_adjusted # From dome_height at pole, to 0 at equator
        print(f"Sample z_local_dome_abs (pole to equator): {z_local_dome_abs[:3]}...{z_local_dome_abs[-3:]}")
        
        if actual_dome_height_m < 1e-3 or np.any(np.isnan(rho_abs_profile)) or np.any(np.isnan(z_local_dome_abs)):
            print("ERROR: Calculated dome height is too small or NaN in profile. Fallback.")
            R_dome_fallback = self.inner_radius; dome_h_fallback = R_dome_fallback * 0.1; self.dome_height = dome_h_fallback
            t_fallback = np.linspace(0, np.pi/2, num_points_dome); return np.vstack((R_dome_fallback * np.sin(t_fallback), dome_h_fallback * np.cos(t_fallback))).T, dome_h_fallback

        print("--- End Debugging _generate_isotensoid_profile ---\n")
        return np.vstack((rho_abs_profile, z_local_dome_abs)).T, actual_dome_height_m

```

**Key areas to check with the print statements:**

1.  **`q` and `r` validity:** The `r_limit` check is important.
2.  **`Y_min_dimless_raw`, `Y_eq_dimless_raw`:** Should be positive real numbers.
3.  **`rho_0_adjusted`:** This scales the dimensionless profile.
4.  **`actual_dome_polar_radius_calc` and `actual_dome_equatorial_radius_calc`:** The latter should match `self.inner_radius`. The former is the effective start of your dome.
5.  **`m_elliptic`:** Must be between 0 and 1 for `scipy.special.ellipkinc/ellipeinc`. If it's outside, the results of elliptic integrals might be NaN or complex, or SciPy might handle it in a specific way (e.g., clamping or error). I've added a clamp.
6.  **`Z_dimless_profile`:** The first value (pole) should be the max dimensionless height, the last value (equator) should be near 0.
7.  **`actual_dome_height_m`:** Should be a sensible positive value.
8.  **`rho_abs_profile`:** Should go from `actual_dome_polar_radius_calc` to `self.inner_radius`.
9.  **`z_local_dome_abs`:** Should go from `actual_dome_height_m` down to near 0.

Run your main script with `dome_type="Isotensoid"` and provide valid `q` and `r` parameters (e.g., `q=10, r=-0.05` as a starting point, since for $q=10, r_{limit} = -(1+10)/(2*10) = -11/20 = -0.55$. So $r=-0.05$ is valid).

Examine the printed debug output carefully. This should help pinpoint where the calculation is going wrong. The fallback to a very flat dome in case of errors will make it visually obvious if an error path was taken.