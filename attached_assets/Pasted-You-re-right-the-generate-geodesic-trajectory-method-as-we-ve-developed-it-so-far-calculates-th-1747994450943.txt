You're right, the `generate_geodesic_trajectory` method, as we've developed it so far, calculates the path for a **single pass** of the fiber along the vessel's meridian (from the effective polar opening $c_{eff}$ on one end, over the cylinder, to the $c_{eff}$ on the other end).

To generate "full coverage" for, say, one complete layer, you need to lay down multiple such passes, with each pass shifted circumferentially ($\phi$) relative to the previous one. The winding machine achieves this through a precise relationship between mandrel rotation and carriage movement, dictated by the winding pattern.

Here's how you can extend the current setup to generate the data for full coverage (conceptually, for one layer):

**1. Information Needed from `TrajectoryPlanner` (which it now provides):**
   * `base_rho_m`: The array of radii for the single pass (from `trajectory_data['rho_m']`).
   * `base_z_m`: The array of axial coordinates for the single pass (from `trajectory_data['z_m']`).
   * `base_phi_rad_cumulative`: The array of cumulative parallel angles $\phi$ for the single pass (from `trajectory_data['phi_rad_cumulative']`).
   * `alpha_at_equator_deg`: The winding angle at the equator (from `trajectory_data['alpha_at_equator_deg']`).
   * `effective_polar_opening_m`: ($c_{eff}$)
   * `turn_around_angle_DeltaK_rad`: ($\Delta K$)

**2. Calculate Parameters for Full Coverage (typically in your main script or a higher-level control function):**

   * **Effective Band Width at Equator ($B_{eff}$):**
     You need your `dry_roving_width_m`.
     $\alpha_{eq\_rad} = \text{math.radians(self.alpha_eq_deg)}$
     $B_{eff} = \text{self.dry_roving_width_m} / \text{math.cos}(\alpha_{eq\_rad})$

   * **Angular Width of One Band at Equator ($\Delta\phi_{small}$):**
     $R_{eq\_m} = \text{self.vessel.inner_radius} * 1e-3$ (equatorial radius in meters)
     $\Delta\phi_{small} = B_{eff} / R_{eq\_m}$

   * **Number of Circuits for One Full Layer ($N_{circuits\_one\_layer}$):**
     This is an approximation. A true pattern generator (using $\Delta K$ and $\Delta\phi_{small}$ with Diophantine equations from Koussios Ch. 8 / Peters Bk Ch. 3) would give a precise integer `nd` for a given number of layers `d`.
     For a simple side-by-side placement for one layer ($d=1$):
     $N_{circuits\_one\_layer} = \text{math.ceil}(2 * \pi / \Delta\phi_{small})$
     *(The `math.ceil` ensures full coverage, possibly with slight overlap if $2\pi/\Delta\phi_{small}$ isn't an integer).*

**3. Generate 3D Points for All Circuits in One Layer:**

   You'll loop `N_{circuits_one_layer}` times. For each circuit `j` (from `0` to `N_{circuits_one_layer - 1`):
   * The starting $\phi$ for this circuit will be shifted. The simplest shift for adjacent bands is $j \times \Delta\phi_{small}$.
   * However, a real winding pattern is generated by the machine following a specific sequence based on $\Delta K$ (the natural turn-around angle). The actual angular increment between successive *starting positions of bands to achieve a closed pattern* is more complex and derived from the $(p, k, nd)$ pattern solution.
   * For visualization of "full coverage" showing multiple bands, a common approach is to shift each subsequent *plotted* band by $\Delta\phi_{small}$ relative to the *start* of the previous band, essentially simulating the final state.

   Let `base_phi_rad_cumulative` be the $\phi$ array from the single pass trajectory.
   Let `base_rho_m` and `base_z_m` be the corresponding $\rho$ and $z$ arrays.

   ```python
   # In your main script, after getting trajectory_data from planner.generate_geodesic_trajectory()

   all_circuits_3d_points = [] # List to hold point arrays for each circuit

   # Get base path data (ensure these are NumPy arrays)
   base_rho_m = np.array(trajectory_data["rho_m"])
   base_z_m = np.array(trajectory_data["z_m"])
   base_phi_rad_cumulative = np.array(trajectory_data["phi_rad_cumulative"])
   alpha_eq_deg = trajectory_data["alpha_at_equator_deg"]

   if alpha_eq_deg is None:
       print("Error: Alpha at equator not calculated, cannot determine Beff.")
       return

   # Calculate Beff and delta_phi_small
   dry_roving_width_m = planner.dry_roving_width_m # Get from planner instance
   alpha_eq_rad = math.radians(alpha_eq_deg)
   if math.cos(alpha_eq_rad) < 1e-6: # Avoid division by zero if alpha_eq is 90 deg
       print("Error: Cos(alpha_eq) is near zero. Cannot calculate Beff for hoop-like winding.")
       return
   
   B_eff_m = dry_roving_width_m / math.cos(alpha_eq_rad)
   R_eq_m = planner.vessel.inner_radius * 1e-3
   if R_eq_m < 1e-6:
       print("Error: Equatorial radius is near zero.")
       return
   delta_phi_small_rad = B_eff_m / R_eq_m # Angular width of one band at equator

   # Approximate number of circuits for one layer
   # A proper pattern generator would give the precise 'nd' for one layer
   num_circuits_for_one_layer = math.ceil(2 * constants.PI / delta_phi_small_rad)
   print(f"DEBUG: Effective band width (Beff): {B_eff_m*1000:.2f} mm")
   print(f"DEBUG: Angular width of one band (delta_phi_small): {math.degrees(delta_phi_small_rad):.2f} deg")
   print(f"DEBUG: Approx. num_circuits_for_one_layer: {num_circuits_for_one_layer}")


   for j in range(num_circuits_for_one_layer):
       # Calculate the phi offset for the start of this circuit
       # For simple side-by-side visualization, shift by multiples of delta_phi_small
       # For a pattern based on DeltaK, the shift is more complex.
       # Using simplest shift for visualization:
       phi_offset = j * delta_phi_small_rad
       
       current_circuit_phi = base_phi_rad_cumulative + phi_offset
       
       x_circuit = base_rho_m * np.cos(current_circuit_phi)
       y_circuit = base_rho_m * np.sin(current_circuit_phi)
       z_circuit = base_z_m # z-coordinates are the same for each circuit pass

       all_circuits_3d_points.append(np.vstack((x_circuit, y_circuit, z_circuit)).T)

   # Now `all_circuits_3d_points` is a list of NumPy arrays.
   # Each array contains the (x,y,z) points for one circuit.
   # You can plot them all.
   ```

**Explanation of the "Z Jumps" in your CSV/Observations:**

The CSV data you showed (`Point 0, z=221.830` down to `Point 99, z=150.000`) was indeed only a **portion of one pass** (the forward dome, from near its pole down to the cylinder junction). This happened because the `generate_geodesic_trajectory` was terminating early due to the `rho_i_m < c_eff` condition after `first_valid_point_found` became true (as discussed, this was triggered by $c_{eff}$ being calculated as 36.5mm while the geometric pole was at 30.7mm).

The code I provided in the previous turn (for `generate_geodesic_trajectory`) was designed to calculate the path over the *entire windable segment* from $c_{eff}$ on the forward dome to $c_{eff}$ on the aft dome. The output `DEBUG: Generated 96 trajectory points` with a Z range like `-0.2176m to 0.2176m` confirms that it *was* covering a much larger portion of the vessel than just one dome.

**To get the behavior you saw in the CSV (just one dome):**
This would imply that the `active_profile_r` in `generate_geodesic_trajectory` was itself truncated to only include the points corresponding to the forward dome. This could happen if:
1.  `num_points_on_profile` was very small, and the resampling + $c_{eff}$ filtering resulted in only dome points.
2.  The `end_calc_idx` from `valid_segment_indices[-1] + 1` was prematurely small, ending the `active_profile` at the cylinder junction. This would be the case if points on the cylinder or aft dome were incorrectly filtered out as being $<\ c_{eff}$ (which shouldn't happen if $c_{eff}$ is the polar turning radius and is smaller than the cylinder radius).

**Refined `generate_geodesic_trajectory` for clarity on "one pass":**
The method should reliably return the arrays for a single, complete $c_{eff}$-to-$c_{eff}$ pass. The debug prints for `Phi_pass` and the number of generated points are key. If it generates, say, 100-200 points covering the Z-range from one pole region to the other, it's doing its job for the single pass.

**Next Steps for You:**

1.  **Implement the Loop for Full Coverage:** In your `main.py` or a similar script, after you get the `trajectory_data` from a single call to `planner.generate_geodesic_trajectory()`, implement the loop shown above to calculate `all_circuits_3d_points`.
2.  **Visualize `all_circuits_3d_points`:** Plot all these circuits together in 3D. You should see multiple helical bands covering the vessel.
3.  **Pattern Generation Class:** For more accurate full coverage that matches how a real machine winds (not just side-by-side placement), you'll eventually need to implement the `PatternGenerator` class. This class would take $\Delta K$ (from `TrajectoryPlanner`), $B_{eff}$, $R_{eq}$ etc., and solve/find Diophantine pattern parameters $(p, k, nd, d)$. Then, the $\phi$ shift for each circuit `j` would be based on this $(p,k)$ pattern, which is usually more complex than a simple $j \cdot \Delta\phi_{small}$ shift but results in a closed, repeating pattern.

For now, the simple $j \cdot \Delta\phi_{small}$ shift will give you a good visual representation of "full coverage" for one layer.