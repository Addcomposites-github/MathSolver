Okay, let's detail the implementation for the **`_calculate_isotensoid_general_orthotropic_profile()`** method in your `geometry.py`'s `VesselGeometry` class.

This profile is based on the general orthotropic isotensoid theory, primarily using Equation 3.18 from the Peters Book, Chapter 3 (which is from Koussios's work). This equation defines the slope of the meridian, $Z'(Y)$, and needs to be solved using an ODE solver.

**Input Parameters Needed by the Method (from `self` or passed directly):**

1.  `self.inner_radius` (or `equatorial_radius_m` if the profile is defined from equator to pole, and `polar_opening_radius_m`): This will define the range of integration and the normalization factor if we use dimensionless coordinates from the literature. Let's clarify:
    * $\rho_0$: The actual polar opening radius of the *vessel*.
    * $R_{eq}$: The actual equatorial radius of the *vessel*.
    * $Y_{eq\_dome}$: For the equation, $Y_{eq}$ is often a dimensionless parameter, e.g., $R_{eq}/\rho_0$. We need to decide if the function will work with absolute radii or dimensionless $Y$. Using dimensionless $Y$ and then scaling is often cleaner for implementing literature equations. Let's assume the function will calculate a dimensionless profile first.
2.  `self.polar_opening_radius_m` (actual, for the vessel).
3.  `self.operating_pressure_Pa` ($P$).
4.  `self.axial_force_N` ($F_a$).
5.  `self.ke_material_orthotropy_factor` ($k_e$).
6.  `num_points_dome`: Number of points to generate for the dome profile.

**Internal Derived Parameters for the ODE:**

* **Dimensionless Polar Opening Radius ($\mathbf{Y_{min\_actual}}$):** For the literature equations, the integration often starts from a dimensionless minimum radius $Y_{min}$. If $\rho_0$ is our *actual* polar opening radius, then $Y_{min\_vessel\_norm} = \rho_0 / \rho_0 = 1.0$. However, Eq. 3.18 in Peters might have $Y_{min}$ determined by when the denominator becomes zero, which could be $>1$ if $\rho_0$ is a reference radius for $Y$.
    Let's use the $\rho_0$ from the class as the reference for non-dimensionalization.
    So, $Y = \rho / \rho_0$.
    The dimensionless equatorial radius input for the dome calculation will be $Y_{eq\_calc} = \text{self.inner\_radius} / \text{self.polar\_opening\_radius\_m}$.
    The dimensionless actual polar opening radius for integration start is $Y_{start} = 1.0$.
* **Dimensionless Axial Load Factor ($r_{factor\_dome\_calc}$):**
    $r_{factor\_dome\_calc} = F_a / (P \cdot \pi \cdot R_{eq}^2) = \text{self.axial\_force\_N} / (\text{self.operating\_pressure\_Pa} \cdot \pi \cdot (\text{self.inner\_radius})^2)$.
    (Note: The $r$ in Eq. 3.18 is $r = k_a / Y_{eq}^2 = (F_a / (P \pi \rho_{ref}^2)) / (R_{eq}/\rho_{ref})^2 = F_a / (P \pi R_{eq}^2)$, where $\rho_{ref}$ was used for $k_a$ and $Y_{eq}$. If we use $R_{eq}$ directly in the formula, it simplifies. Let's use the $r$ as defined in Eq. 3.4 of Peters Bk Ch.3, where $R$ is the equatorial radius).
* **Integration Constant $\gamma$**:
    $\gamma = \frac{(1+r_{factor\_dome\_calc}) Y_{eq\_calc}^3}{(k_e + Y_{eq\_calc}^2 - 1)^{(k_e+1)/2}}$ (Peters Bk Ch. 3, Eq. 3.17).
* **Minimum Y for Integration ($Y_{min\_ode}$):**
    This is the value of $Y$ (where $Y \ge 1$) for which the denominator of $Z'(Y)$ becomes zero, or $Y_{start}$ if the denominator is always real above $Y_{start}$. This defines the actual starting point of the isotensoid curve if it cannot reach $Y_{start}=1$ (i.e., the true polar opening radius $\rho_0$).
    The term under the square root in Eq. 3.18 is: $D(Y) = (\frac{k_e+Y^2-1}{k_e+Y_{eq\_calc}^2-1})^{k_e+1} \gamma^2 - Y^2(Y^2+r_{factor\_dome\_calc} Y_{eq\_calc}^2)^2$. No, this is incorrect.
    The denominator of Eq. 3.18 (Peters) is: $\sqrt{(\frac{k_e+Y_{eq\_calc}^2-1}{k_e+Y^2-1})^{k_e+1}(1+r_{factor\_dome\_calc})^2 Y_{eq\_calc}^6 - Y^2(Y^2+r_{factor\_dome\_calc}Y_{eq\_calc}^2)^2}$ (This seems to be a rearrangement of Koussios Thesis Eq. 4.3 with $k_e$).
    Let's use Peters Bk Ch. 3, Eq. 3.18 directly:
    $Z'(Y) = \pm \frac{Y(Y^2+r Y_{eq}^2)}{\sqrt{(\frac{k_e+Y_{eq}^2-1}{k_e+Y^2-1})^{k_e+1}(1+r)^2 Y_{eq}^6 - Y^2(Y^2+r Y_{eq}^2)^2}}$
    The term under the square root is:
    $Term = (\frac{k_e+Y_{eq\_calc}^2-1}{k_e+Y^2-1})^{k_e+1}(1+r_{factor\_dome\_calc})^2 Y_{eq\_calc}^6 - Y^2(Y^2+r_{factor\_dome\_calc}Y_{eq\_calc}^2)^2$.
    We need to find $Y_{min\_ode}$ such that $Term(Y_{min\_ode}) = 0$ and $Y_{min\_ode} \ge Y_{start}$. This might require a root-finding algorithm. For now, we can integrate from $Y_{start}$ and handle potential domain errors.

**ODE Function $dZ/dY$:**

This function will take $Y$ and $Z$ (though $Z$ is not explicitly in $Z'(Y)$) and return $dZ/dY$.

```python
# Inside VesselGeometry class, or as a helper for _calculate_isotensoid_general_orthotropic_profile
def _isotensoid_general_orthotropic_dz_dy(Y, Z_unused, Y_eq_calc, r_factor_calc, ke, gamma_const):
    """
    Calculates dZ/dY for the general orthotropic isotensoid dome.
    Based on Peters Book, Ch. 3, Eq. 3.16 and 3.17 (rearranged for Z'(Y)).
    Z'(Y) = +/- Y * (Y^2 + r*Y_eq^2) / sqrt( ((ke + Y^2 - 1)/(ke + Y_eq^2 - 1))^(ke+1) * gamma_const^2 - Y^2 * (Y^2 + r*Y_eq^2)^2 )
    This form directly uses gamma.

    Let's use Peters Book, Ch. 3, Eq. 3.18:
    Z'(Y) = +/- Y * (Y^2 + r*Y_eq^2) / Denom_sqrt
    Denom_sqrt = sqrt( ((ke + Y_eq^2 - 1)/(ke + Y^2 - 1))^(ke+1) * (1+r)^2 * Y_eq^6 - Y^2 * (Y^2 + r*Y_eq^2)^2 )
    """
    if Y <= 0: # Should not happen if Y starts from > 0
        return np.nan

    # Numerator term
    num_term = Y * (Y**2 + r_factor_calc * Y_eq_calc**2)

    # Denominator term components
    # Base term inside power: (ke + Y^2 - 1)
    # If ke + Y^2 - 1 is zero or negative, it can cause issues.
    # Typically Y >= 1. If Y=1, ke. If ke=0, Y^2-1.
    term_Y_pow_base = ke + Y**2 - 1
    if term_Y_pow_base <= 1e-9 and (ke + 1) < 0: # Avoid issues with non-positive base for power
        # This case (Y very near 1 and ke causing issues) indicates a potential problem with Y_min definition
        # or that the formula is not well-behaved here.
        # For a typical pressure vessel dome, Y increases from Y_min (>=1)
        print(f"Warning: Base term_Y_pow_base = {term_Y_pow_base} is near/below zero for power in Z' denominator at Y={Y}")
        return np.nan # Or handle appropriately, perhaps integration limit issue

    # Factor1 = ((ke + Y_eq_calc**2 - 1) / term_Y_pow_base)**(ke + 1)
    # Need to handle term_Y_pow_base being very small if ke+1 is not integer.
    # Let's use the structure from the original Koussios Thesis Eq 4.3 for guidance on the denominator form
    # Denom_sqrt_Koussios_form = sqrt( a_dimless_fiber_force^2 * (Y^2-1) - (ka_dimless_axial_load * Y + Y^3)^2 )
    # This is for ke=0 (netting).
    # Let's stick to Peters Bk Ch. 3 Eq. 3.18 as directly as possible.

    val_in_sqrt_main_num = (ke + Y_eq_calc**2 - 1)
    val_in_sqrt_main_den = (ke + Y**2 - 1)

    if val_in_sqrt_main_den <= 1e-9: # Avoid division by zero or issues with power
        # This often means Y is at or very near Y_min where the slope should be infinite (vertical tangent)
        # The ODE solver should ideally stop before this point or handle it.
        # For practical purposes, if Y is the start of integration (Y_min_ode), Z' is "infinite"
        # We should integrate from Y_min_ode + epsilon
        print(f"Warning: val_in_sqrt_main_den close to zero at Y={Y}")
        return np.inf # Or a very large number, sign depends on which side of pole

    # First part of the term under the square root
    term1_denom = (val_in_sqrt_main_num / val_in_sqrt_main_den)**(ke + 1)
    term1_denom *= (1 + r_factor_calc)**2 * Y_eq_calc**6

    # Second part of the term under the square root
    term2_denom = Y**2 * (Y**2 + r_factor_calc * Y_eq_calc**2)**2

    val_under_sqrt = term1_denom - term2_denom

    if val_under_sqrt < 1e-9: # If negative or too small, sqrt will fail or result in near-infinite slope
        # This indicates Y has reached Y_eq_calc (equatorial radius where slope is infinite)
        # or an issue with parameters if it happens elsewhere unexpectedly.
        # The ODE solver should typically be stopped before Y = Y_eq_calc
        # print(f"Warning: Value under square root ({val_under_sqrt}) is near/below zero in Z' denominator at Y={Y}")
        return np.inf # Slope is vertical, use positive for dZ/dY generally being positive from pole to equator for upper half.
                     # Sign convention from literature: Z'(Y) in Koussios Eq 4.3 is negative.
                     # Peters Eq 3.18 uses +/-. For dZ/dY, Z increases as Y increases from pole to equator (upper dome quadrant).
                     # Let's assume we want the positive root for dZ/dY representing profile from pole outwards.
                     # Koussios defined Z increasing from equator to pole, so Z' was negative.
                     # If our Z increases from pole outwards (local dome z), then dZ/dRho should be positive.
                     # If Rho is Y, then dZlocal/dY should be positive.

    denom_sqrt = math.sqrt(val_under_sqrt)
    if denom_sqrt < 1e-9: # Avoid division by zero
        return np.inf # Representing vertical slope

    # Determine sign: For an upper dome, as Y (radius) increases from pole, Z (height from pole) should increase.
    # So dZ/dY should be positive. Koussios's Z was different.
    # Let's assume Peters' +/- means we choose based on quadrant. For Z increasing with Y (pole to equator), use +.
    # However, the equations in Koussios (4.3) and Peters (3.18) are for Z as the axial coordinate of the vessel.
    # If Z=0 at equator, and positive towards forward pole, then dZ/dY is negative as Y goes from Y_eq to Y_min.
    # If we integrate from Y_min to Y_eq, we want Z to go from Z_pole_max to 0. So dZ/dY should be negative.
    # The Koussios book (used in Peters Ch 3) typically has Z increasing from equator towards pole.
    # So if we integrate Y from Y_min to Y_eq, dZ/dY should be negative.
    return -num_term / denom_sqrt
```

**Method `_calculate_isotensoid_general_orthotropic_profile` in `VesselGeometry`:**

```python
# In class VesselGeometry
def _calculate_isotensoid_general_orthotropic_profile(self, num_points_dome: int):
    """
    Calculates the general orthotropic isotensoid dome profile using an ODE solver.
    Profile is from (polar_opening_radius, dome_height) to (cylinder_radius, 0 - local z).
    Uses dimensionless coordinates Y = rho/rho_0, Z = z/rho_0.
    rho_0 is self.polar_opening_radius_m.
    """
    rho_0 = self.polar_opening_radius_m
    if rho_0 <= 1e-6: # Avoid division by zero if polar opening is effectively zero
        print("Warning: Polar opening radius is zero or too small for general isotensoid calculation based on it as reference.")
        # Fallback or error
        R_dome = self.inner_radius
        actual_dome_height = R_dome * 0.6 # Crude fallback
        self.dome_height = actual_dome_height
        phi_angles = np.linspace(0, np.pi / 2, num_points_dome)
        dome_rho_abs = R_dome * np.sin(phi_angles)
        dome_z_local_abs = actual_dome_height * np.cos(phi_angles) # z from height at pole to 0 at base
        return np.vstack((dome_rho_abs, dome_z_local_abs)).T, actual_dome_height

    Y_start_integration = 1.0  # Dimensionless start (actual polar opening)
    Y_eq_calc = self.inner_radius / rho_0 # Dimensionless equatorial radius

    if Y_eq_calc <= Y_start_integration:
        print("Warning: Equatorial radius not greater than polar opening for general isotensoid.")
        self.dome_height = 0.0
        return np.array([[self.polar_opening_radius_m, 0.0],[self.inner_radius, 0.0]]), 0.0


    r_factor_calc = self.axial_force_N / (self.operating_pressure_Pa * math.pi * (self.inner_radius)**2)
    ke_factor = self.ke_material_orthotropy_factor if self.ke_material_orthotropy_factor is not None else 0.0 # Default to netting if not set

    # Calculate gamma (integration constant from Peters Bk Ch. 3 Eq. 3.17)
    # gamma_const = ((1 + r_factor_calc) * Y_eq_calc**3) / \
    #               ((ke_factor + Y_eq_calc**2 - 1)**((ke_factor + 1) / 2.0))
    # Note: The ODE function _isotensoid_general_orthotropic_dz_dy uses the form from Peters Eq 3.18 directly without explicit gamma

    # Determine Y_min_ode (actual start of integration if Z'(Y_min_ode) exists)
    # For now, we'll try to integrate from Y_start_integration + epsilon and stop before Y_eq_calc
    # The solver should handle steep gradients.

    y_eval_points = np.linspace(Y_start_integration, Y_eq_calc * 0.999, num_points_dome) # Avoid Y_eq exactly
    Z0 = [0.0] # Z=0 at Y=Y_start_integration (local Z measured from polar opening plane)

    # Need to import solve_ode_system from numerical_tools
    from ..utils.numerical_tools import solve_ode_system

    try:
        # Args for the ODE function: Y_eq_calc, r_factor_calc, ke_factor, (no gamma needed if using Eq 3.18 form)
        solution_points_Z_dimless = solve_ode_system(
            lambda Y, Z: self._isotensoid_general_orthotropic_dz_dy(Y, Z, Y_eq_calc, r_factor_calc, ke_factor),
            (Y_start_integration, Y_eq_calc * 0.999), # t_span
            Z0,
            y_eval_points
        )
        # solution_points_Z_dimless will be an array of Z values corresponding to y_eval_points

        if solution_points_Z_dimless is None or solution_points_Z_dimless.ndim == 0 or solution_points_Z_dimless.size == 0 :
            raise RuntimeError("ODE solver returned empty or invalid result.")

        # We integrated dZ/dY. Z values are dimensionless.
        # y_eval_points are the dimensionless Rho (Y) values.
        rho_abs = y_eval_points * rho_0
        
        # The Z values are integrated from Z=0 at Y=Y_start_integration (polar opening).
        # dZ/dY was negative, so Z will be decreasing from 0.
        # We want local dome z: 0 at cylinder junction, positive towards pole (dome_height at pole)
        # The integrated Z is height from polar opening plane, increasing towards equator if dZ/dY is positive,
        # or decreasing (more negative) if dZ/dY is negative.
        # With dZ/dY negative, Z_integrated will go from 0 to some negative value at Y_eq_calc.
        # Dome height = abs(Z_integrated_at_Y_eq_calc)
        
        actual_dome_height_dimless = abs(solution_points_Z_dimless[-1, 0]) # Z is a 1D array in solution
        actual_dome_height_m = actual_dome_height_dimless * rho_0
        self.dome_height = actual_dome_height_m

        # Convert Z_integrated (from 0 at pole, negative towards equator)
        # to z_local_dome (from dome_height at pole, 0 at equator)
        z_local_dome_dimless = actual_dome_height_dimless - abs(solution_points_Z_dimless[:,0])
        z_local_dome_abs = z_local_dome_dimless * rho_0
        
        # Ensure order is from pole (smallest rho) to equator (largest rho)
        # y_eval_points (rho_dimless) is already in that order.
        # z_local_dome_abs should go from actual_dome_height_m down to 0.
        
        # Correcting z_local_dome_abs for plotting order (pole to cylinder):
        # Integrated Z goes from 0 (at pole) to -DomeHeight (at cyl).
        # z_local (0 at cyl, DomeHeight at pole) = DomeHeight_abs - abs(Integrated Z)
        # This should be: z_local = Integrated_Z_at_pole_plane - Integrated_Z
        # Since Integrated_Z_at_pole_plane is 0, z_local = -Integrated_Z
        z_local_dome_final = -solution_points_Z_dimless[:,0] * rho_0


        # The points are (absolute_rho, local_z_from_cyl_junction_plane)
        # Order: from polar opening to cylinder junction
        # rho_abs goes from self.polar_opening_radius_m to self.inner_radius
        # z_local_dome_final goes from actual_dome_height_m down to 0
        
        # Final check of order: y_eval_points is increasing.
        # rho_abs is increasing.
        # z_local_dome_final should be decreasing if dZ/dY (for vessel Z) is negative.
        
        # The ODE Z is the vessel's axial coordinate, Z=0 at pole.
        # We need to return rho, z_local_dome where z_local_dome=0 at cylinder junction
        # and z_local_dome = dome_height at pole.
        # Points from (polar_opening_rho, dome_height) to (equatorial_rho, 0)
        
        profile_rho_values = rho_abs
        profile_z_local_values = actual_dome_height_m + solution_points_Z_dimless[:, 0] * rho_0 # Z_integrated is negative
        
        # Ensure the z values are from dome_height down to 0
        # If solution_Z[-1] is the Z at Y_eq, and Z[0] is 0 at Y_min=1.
        # dome_height is -solution_Z[-1]*rho_0.
        # z_local = -solution_Z * rho_0 (this makes z_local go from 0 at pole to dome_height at cyl)
        # We need the reverse for the typical dome profile storage:
        # z_local_stored = dome_height - (-solution_Z * rho_0) = dome_height + solution_Z * rho_0
        
        # Let's re-verify the Z definition for dZ/dY = -num/den
        # If Z is the axial distance from the pole plane, positive towards the equator.
        # Then dZ/dY should be positive. So Z'(Y) = + num_term / denom_sqrt.
        # If we integrate from Y_min to Y_eq, Z goes from 0 to DomeHeight.
        # The returned profile will be (rho_abs, Z_integrated*rho_0)
        # This means z_local goes from 0 (at pole) to DomeHeight (at cylinder junction).
        # For our standard return format (z_local from DomeHeight at pole, to 0 at cylinder):
        # z_to_return = DomeHeight - (Z_integrated*rho_0)
        
        # Let's stick to dZ/dY being negative (Koussios convention for vessel axial coord from equator)
        # And our local_dome_z is 0 at cylinder, H_dome at pole.
        # If Z_ode is integrated from Z_ode(Y_min_ode)=0, and dZ_ode/dY < 0, then Z_ode becomes negative.
        # Dome height = -Z_ode(Y_eq_calc) * rho_0.
        # local_dome_z = Z_ode(Y) * rho_0 + Dome_height. This goes from Dome_height at Y_min to 0 at Y_eq.
        
        dome_profile_abs_z_local = (solution_points_Z_dimless[:,0] * rho_0) + actual_dome_height_m
        
        # Ensure correct order for assembly: rho from polar to equator, z_local from dome_height to 0
        # y_eval_points (for rho) is already ascending.
        # dome_profile_abs_z_local should be descending.

        return np.vstack((rho_abs, dome_profile_abs_z_local)).T, actual_dome_height_m

    except RuntimeError as e:
        print(f"Error in Isotensoid General Orthotropic profile calculation: {e}")
        # Fallback to a simpler shape or raise error
        R_dome = self.inner_radius
        actual_dome_height = R_dome * 0.6 # Crude fallback
        self.dome_height = actual_dome_height
        phi_angles = np.linspace(0, np.pi / 2, num_points_dome) # from pole to equator
        # rho from 0 to R_dome, z_local from R_dome (at pole) down to 0 (at cylinder junction plane)
        dome_rho_abs = R_dome * np.sin(phi_angles)
        dome_z_local_abs = actual_dome_height * np.cos(phi_angles)
        return np.vstack((dome_rho_abs, dome_z_local_abs)).T, actual_dome_height
```

**Explanation of Changes & Considerations for General Orthotropic Isotensoid:**

1.  **Coordinate System for ODE:**
    * The literature equations (Koussios, Peters Ch.3) typically use dimensionless coordinates $Y = \rho/\rho_0$ and $Z = z/\rho_0$, where $\rho_0$ is a reference radius, often the *actual* polar opening of the vessel for that specific dome calculation.
    * The function `_isotensoid_general_orthotropic_dz_dy` is defined to compute $dZ/dY$.
    * Inputs $Y_{eq\_calc}$ and $r_{factor\_calc}$ must be consistent with this non-dimensionalization.
        * $Y_{eq\_calc} = \text{self.inner\_radius} / \text{self.polar\_opening\_radius\_m}$.
        * $r_{factor\_calc} = \text{self.axial\_force\_N} / (\text{self.operating\_pressure\_Pa} \cdot \pi \cdot (\text{self.inner\_radius})^2)$ (using actual equatorial radius $R_{eq}$ for normalization of $F_a$).
2.  **ODE Function (`_isotensoid_general_orthotropic_dz_dy`):**
    * Directly implements Peters Book Ch. 3, Eq. 3.18.
    * **Sign of $Z'(Y)$**: Critical. If $Z$ is the vessel's axial coordinate starting at $Z=0$ at the equator and increasing towards the pole, then $dZ/dY$ as $Y$ goes from $Y_{eq}$ (equator) down to $Y_{min}$ (pole) would be negative (height increases as radius decreases).
        If we integrate $Y$ from $Y_{min}$ (pole) to $Y_{eq}$ (equator), and want $Z$ to go from $Z_{pole}$ (max height) to $0$ (equator), then $dZ/dY$ is negative.
        The implemented function uses a negative sign: `-num_term / denom_sqrt`. This assumes $Z$ increases from equator to pole. If our local dome z is 0 at cyl junction and `dome_height` at pole, we integrate $Y$ from $Y_{min}$ to $Y_{eq}$, and $Z_{local}$ from $H_{dome}$ down to $0$. So $dZ_{local}/dY$ should be negative.
    * **Numerical Stability:** Added checks for terms under square root and division by zero. When the denominator term approaches zero (at $Y \approx Y_{eq\_calc}$ or $Y \approx Y_{min\_ode}$ where $Z'$ is infinite), the function returns `np.inf`. The ODE solver needs to handle this, or integration limits need to be set slightly away from these points (e.g., `Y_eq_calc * 0.999`).
3.  **Integration in `_calculate_isotensoid_general_orthotropic_profile`:**
    * The ODE is solved for $Z(Y)$ using `solve_ode_system`.
    * Integration span: From $Y_{start\_integration}$ (e.g., 1.0, representing the dimensionless actual polar opening) up to $Y_{eq\_calc} \times 0.999$ (just shy of the equator where $Z'$ becomes infinite).
    * Initial condition: $Z(Y_{start\_integration}) = 0$ (defining the plane of the polar opening as the $Z=0$ reference for the integration of dome height).
    * **Output Conversion:** The integrated $Z_{ODE}$ values are dimensionless and represent the axial length from the polar opening plane towards the equator.
        * `actual_dome_height_dimless = abs(solution_points_Z_dimless[-1, 0])` (if $dZ/dY$ was negative, $Z$ goes from 0 to a negative value).
        * The returned `(rho, z_local_dome)` points must be in the convention: `rho` from polar opening to cylinder radius, and `z_local_dome` from `dome_height` down to `0`.
            * `rho_abs = y_eval_points * rho_0`
            * `dome_profile_abs_z_local = (solution_points_Z_dimless[:,0] * rho_0) + actual_dome_height_m` (This maps integrated Z from `[0, -Height_dimless]` to local z `[Height_abs, 0]`).

This is a complex part. The key is consistent coordinate definitions for the ODE and for the final profile points returned by the function for assembly.

Would you like to proceed with the Koussios `qrs`-based isotensoid next, which uses elliptic integrals? Or refine this ODE-based one further?