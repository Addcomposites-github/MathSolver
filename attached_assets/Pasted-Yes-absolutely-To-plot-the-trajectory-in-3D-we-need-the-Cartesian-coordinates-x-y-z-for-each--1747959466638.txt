Yes, absolutely! To plot the trajectory in 3D, we need the Cartesian coordinates (x, y, z) for each point on the path.

The `generate_geodesic_trajectory` method in your `trajectories.py` currently calculates:
* `path_rho_m`: The radial distance from the z-axis for each point.
* `path_z_m`: The axial coordinate for each point (this is directly from the vessel's meridian profile).
* `path_phi_rad_cumulative`: The cumulative parallel angle (angle of revolution around the z-axis).

We can convert these $(\rho, z, \phi)$ cylindrical-type coordinates to Cartesian $(x, y, z)$ using:
* $x = \rho \cos(\phi)$
* $y = \rho \sin(\phi)$
* $z = z_{meridian}$ (which is `path_z_m`)

Let's modify the `generate_geodesic_trajectory` method in your `trajectories.py` to include the calculation of these x, y, z points and return them.

```python
# copv_design_tool/winding/trajectory.py
import numpy as np
import math
from typing import Dict, Tuple, List, Optional
try:
    from ..core.vessel_geometry import VesselGeometry
    from ..utils.numerical_tools import numerical_integrate_samples
    from .. import constants
except ImportError:
    import sys
    import os
    sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
    from core.vessel_geometry import VesselGeometry
    from utils.numerical_tools import numerical_integrate_samples
    import constants

class TrajectoryPlanner:
    def __init__(self,
                 vessel_geometry: VesselGeometry,
                 dry_roving_width_m: float, # Expecting meters
                 dry_roving_thickness_m: float, # Expecting meters
                 roving_eccentricity_at_pole_m: float = 0.0): # Expecting meters
        
        print("\nDEBUG trajectories.py: Entering TrajectoryPlanner.__init__")
        self.vessel = vessel_geometry

        print("DEBUG trajectories.py: Vessel object received.")
        print(f"  Vessel dome_type: {self.vessel.dome_type}")
        # print(f"  Vessel initial profile_points: {self.vessel.profile_points}") # Can be very long

        if self.vessel.profile_points is None:
            print("DEBUG trajectories.py: Vessel profile_points is None, calling self.vessel.generate_profile().")
            self.vessel.generate_profile() 
            if self.vessel.profile_points is None:
                raise ValueError("Vessel profile_points is STILL None after calling generate_profile() in TrajectoryPlanner.")
            else:
                print("DEBUG trajectories.py: self.vessel.generate_profile() CALLED from TrajectoryPlanner.")
        
        # print(f"DEBUG trajectories.py: After potential generate_profile call in TrajectoryPlanner init:")
        # print(f"  self.vessel.profile_points type: {type(self.vessel.profile_points)}")
        # if isinstance(self.vessel.profile_points, dict):
        #     print(f"  Keys in self.vessel.profile_points: {list(self.vessel.profile_points.keys())}")
        #     if 'r_inner' not in self.vessel.profile_points:
        #         print("  CRITICAL DEBUG trajectories.py: 'r_inner' key IS MISSING from self.vessel.profile_points dict HERE!")
        #     elif not hasattr(self.vessel.profile_points['r_inner'], '__len__') or len(self.vessel.profile_points['r_inner']) == 0 :
        #         print("  CRITICAL DEBUG trajectories.py: 'r_inner' IS EMPTY or not array-like in self.vessel.profile_points!")
        #     else:
        #          print(f"  'r_inner' key FOUND. Length: {len(self.vessel.profile_points['r_inner'])}")
        # else:
        #     print(f"  CRITICAL DEBUG trajectories.py: self.vessel.profile_points is NOT a dict HERE! It is: {self.vessel.profile_points}")
        #     raise TypeError("Vessel profile_points is not a dictionary as expected in TrajectoryPlanner.")

        self.dry_roving_width_m = dry_roving_width_m
        self.dry_roving_thickness_m = dry_roving_thickness_m
        self.roving_eccentricity_at_pole_m = roving_eccentricity_at_pole_m

        self.effective_polar_opening_radius_m = None
        self.alpha_profile_deg = None
        self.phi_profile_rad_cumulative = None # Renamed for clarity
        self.turn_around_angle_rad_DeltaK = None
        self.alpha_eq_deg = None
        self.trajectory_3d_points_m = None # To store (x,y,z)

        self._calculate_effective_polar_opening()
        print("DEBUG trajectories.py: TrajectoryPlanner.__init__ completed.")


    def _get_slope_dz_drho_at_rho(self, rho_target_m: float) -> float:
        # print(f"\nDEBUG trajectories.py: --- INSIDE _get_slope_dz_drho_at_rho ---")
        # print(f"  rho_target_m for slope calculation: {rho_target_m}")
        # print(f"  Type of self.vessel.profile_points at this point: {type(self.vessel.profile_points)}")
        # if isinstance(self.vessel.profile_points, dict):
        #     print(f"  Keys in self.vessel.profile_points at this point: {list(self.vessel.profile_points.keys())}")
        #     if 'r_inner' not in self.vessel.profile_points:
        #         print("  CRITICAL ERROR _get_slope: 'r_inner' IS MISSING when _get_slope_dz_drho_at_rho is entered!")
        #         raise KeyError("'r_inner' not found in profile_points inside _get_slope_dz_drho_at_rho")
        #     elif len(self.vessel.profile_points['r_inner']) == 0:
        #         print("  CRITICAL ERROR _get_slope: 'r_inner' is empty!")
        #         raise ValueError("'r_inner' is empty in _get_slope_dz_drho_at_rho")
        #     # else:
        #     #     print(f"  _get_slope: 'r_inner' IS PRESENT. Length: {len(self.vessel.profile_points['r_inner'])}")
        # else:
        #     print(f"  CRITICAL ERROR _get_slope: self.vessel.profile_points is NOT a dict here! It is: {self.vessel.profile_points}")
        #     raise TypeError("_get_slope_dz_drho_at_rho: profile_points is not a dictionary.")

        rho_profile_m = self.vessel.profile_points['r_inner'] * 1e-3
        z_profile_m = self.vessel.profile_points['z'] * 1e-3
        
        if len(rho_profile_m) < 2:
            print("Warning: Profile has less than 2 points in _get_slope_dz_drho_at_rho. Cannot calculate slope. Returning 0.")
            return 0.0
       
        if np.isclose(rho_target_m, rho_profile_m[0]):
            if not np.isclose(rho_profile_m[1] - rho_profile_m[0], 0):
                slope = (z_profile_m[1] - z_profile_m[0]) / (rho_profile_m[1] - rho_profile_m[0])
                return slope
            else: 
                return np.inf # Vertical tangent for rho (horizontal for z at this point on profile)
        
        # Fallback for other points (current use is for pole only)
        idx = np.argmin(np.abs(rho_profile_m - rho_target_m))
        if idx == 0:
             if not np.isclose(rho_profile_m[1] - rho_profile_m[0],0): return (z_profile_m[1] - z_profile_m[0]) / (rho_profile_m[1] - rho_profile_m[0])
             return np.inf
        elif idx == len(rho_profile_m) - 1:
             if not np.isclose(rho_profile_m[idx] - rho_profile_m[idx-1],0): return (z_profile_m[idx] - z_profile_m[idx-1]) / (rho_profile_m[idx] - rho_profile_m[idx-1])
             return np.inf
        else:
             if not np.isclose(rho_profile_m[idx+1] - rho_profile_m[idx-1],0): return (z_profile_m[idx+1] - z_profile_m[idx-1]) / (rho_profile_m[idx+1] - rho_profile_m[idx-1])
             return np.inf

    def _calculate_effective_polar_opening(self):
        if self.vessel.profile_points is None or 'r_inner' not in self.vessel.profile_points or len(self.vessel.profile_points['r_inner'])==0:
            print("Error: Vessel profile points not available for calculating effective polar opening.")
            self.effective_polar_opening_radius_m = self.vessel.polar_opening_radius_m * 1e-3 # Fallback to geometric converted to m
            return self.effective_polar_opening_radius_m

        rho_geom_pole_m = self.vessel.profile_points['r_inner'][0] * 1e-3
        
        ecc_0_m = self.roving_eccentricity_at_pole_m
        b_m = self.dry_roving_width_m
        t_rov_m = self.dry_roving_thickness_m

        dz_drho_pole = self._get_slope_dz_drho_at_rho(rho_geom_pole_m)
        
        if np.isinf(dz_drho_pole):
            # If meridian is vertical at the geometric pole (dz/drho -> inf)
            # sqrt(1+(dz/drho)^2) approx |dz/drho|
            # term_width approx (b_m/2) * |dz_drho_pole|
            # term_thickness approx (t_rov_m/2) * dz_drho_pole
            # c_eff = rho_geom_pole_m + ecc_0_m + (b_m/2 - t_rov_m/2 * np.sign(dz_drho_pole)) * abs(dz_drho_pole)
            # This can still be very large. For a flat end cap (dz/drho = 0), the formula is simple.
            # If it's a true point pole for a smooth dome, dz/drho is inf if tangent is along z there.
            # Let's assume for a practical opening, the slope is finite or very large.
            # If slope is extremely large, treat sqrt(1+slope^2) as |slope|
            term_width = (b_m / 2.0) * abs(dz_drho_pole) # Approximation
            term_thickness = (t_rov_m / 2.0) * dz_drho_pole
            print(f"Warning: dz/drho at pole is infinite ({dz_drho_pole}). Using approximation for c_eff terms.")
        else:
            term_width = (b_m / 2.0) * math.sqrt(1 + dz_drho_pole**2)
            term_thickness = (t_rov_m / 2.0) * dz_drho_pole
            
        self.effective_polar_opening_radius_m = rho_geom_pole_m + ecc_0_m + term_width - term_thickness
        
        if self.effective_polar_opening_radius_m <= 1e-7: # Cannot be zero or negative
            print(f"Warning: Calculated effective_polar_opening_radius_m is {self.effective_polar_opening_radius_m:.3e} m. Setting to small positive.")
            self.effective_polar_opening_radius_m = 1e-6 
            
        # Vessel inner radius is in mm, convert to m for comparison
        vessel_inner_radius_m = self.vessel.inner_radius * 1e-3
        if self.effective_polar_opening_radius_m > vessel_inner_radius_m:
            print(f"Warning: Effective polar opening ({self.effective_polar_opening_radius_m:.4f}m) "
                  f"is greater than cylinder radius ({vessel_inner_radius_m:.4f}m). Geodesic path might not turn.")
        print(f"Debug _calc_eff_polar: rho_geom_pole_m={rho_geom_pole_m:.4f}, dz_drho_pole={dz_drho_pole:.4f}, c_eff={self.effective_polar_opening_radius_m:.4f} m")
        return self.effective_polar_opening_radius_m

    def calculate_geodesic_alpha_at_rho(self, rho_m: float) -> Optional[float]:
        if self.effective_polar_opening_radius_m is None:
            self._calculate_effective_polar_opening()
        
        c_eff = self.effective_polar_opening_radius_m
        if c_eff is None or rho_m < c_eff - 1e-9 : # rho_m must be >= c_eff
            # print(f"Warning: Target rho_m ({rho_m:.4f}) < c_eff ({c_eff:.4f}). Geodesic alpha undefined.")
            return None 
        if abs(rho_m) < 1e-9: # Avoid division by zero if rho_m is effectively zero
            return constants.PI / 2.0 if np.isclose(c_eff, 0.0) else None

        asin_arg = c_eff / rho_m
        if asin_arg > 1.0: asin_arg = 1.0
        elif asin_arg < -1.0: asin_arg = -1.0 # Should not happen for positive radii
            
        try:
            alpha_rad = math.asin(asin_arg)
            return alpha_rad
        except ValueError:
            print(f"Error: math.asin arg {asin_arg} out of range for rho={rho_m}, c_eff={c_eff}")
            return None

    def generate_geodesic_trajectory(self, num_points_on_profile: Optional[int] = None):
        """
        Generates geodesic path points (rho, z, alpha, phi_cumulative, x, y) 
        for one pass along the vessel meridian (e.g., forward pole to aft pole).
        """
        if self.vessel.profile_points is None or 'r_inner' not in self.vessel.profile_points:
            print("Error: Vessel profile not generated or invalid. Call vessel.generate_profile() first.")
            return None
        if self.effective_polar_opening_radius_m is None:
            self._calculate_effective_polar_opening()
            if self.effective_polar_opening_radius_m is None:
                print("Error: Effective polar opening could not be calculated.")
                return None
        
        # Use vessel's inner profile points (in meters)
        profile_r_m = self.vessel.profile_points['r_inner'] * 1e-3
        profile_z_m = self.vessel.profile_points['z'] * 1e-3

        if num_points_on_profile and len(profile_r_m) > num_points_on_profile :
            # Resample profile to have num_points_on_profile for trajectory calculation
            # This helps in controlling density of trajectory points if original profile is too dense
            indices = np.linspace(0, len(profile_r_m) - 1, num_points_on_profile, dtype=int)
            profile_r_m = profile_r_m[indices]
            profile_z_m = profile_z_m[indices]
        
        if len(profile_r_m) < 2:
            print("Error: Not enough profile points for trajectory calculation.")
            return None

        path_rho_m = []
        path_z_m = []
        path_alpha_rad = []
        path_phi_rad_cumulative = []
        path_x_m = []
        path_y_m = []
        
        current_phi_rad = 0.0

        # First point
        rho_start_m = profile_r_m[0]
        alpha_start_rad = self.calculate_geodesic_alpha_at_rho(rho_start_m)
        
        if alpha_start_rad is None:
            if np.isclose(rho_start_m, self.effective_polar_opening_radius_m):
                alpha_start_rad = constants.PI / 2.0
            else:
                print(f"Critical Error: Cannot determine initial alpha at rho_start={rho_start_m} with c_eff={self.effective_polar_opening_radius_m}")
                return None # Cannot proceed
        
        path_rho_m.append(rho_start_m)
        path_z_m.append(profile_z_m[0])
        path_alpha_rad.append(alpha_start_rad)
        path_phi_rad_cumulative.append(current_phi_rad)
        path_x_m.append(rho_start_m * math.cos(current_phi_rad))
        path_y_m.append(rho_start_m * math.sin(current_phi_rad))

        for i in range(1, len(profile_r_m)):
            rho_i_m = profile_r_m[i]
            z_i_m = profile_z_m[i]
            alpha_i_rad = self.calculate_geodesic_alpha_at_rho(rho_i_m)

            if alpha_i_rad is None:
                alpha_i_rad = path_alpha_rad[-1] 
                # print(f"Warning: Using previous alpha for rho={rho_i_m} as geodesic is undefined.")

            # Calculate delta_phi for the segment from point i-1 to i
            rho_prev_m = path_rho_m[-1] # Last added rho
            z_prev_m = path_z_m[-1]   # Last added z
            alpha_prev_rad = path_alpha_rad[-1]

            d_rho = rho_i_m - rho_prev_m
            d_z = z_i_m - z_prev_m
            ds_segment_m = math.sqrt(d_rho**2 + d_z**2)
            
            delta_phi = 0.0
            if ds_segment_m > 1e-9: # Only if there's actual movement along meridian
                rho_avg_segment_m = (rho_i_m + rho_prev_m) / 2.0
                alpha_avg_segment_rad = (alpha_i_rad + alpha_prev_rad) / 2.0
                
                if abs(rho_avg_segment_m) > 1e-7 and not math.isclose(math.cos(alpha_avg_segment_rad), 0.0):
                    try:
                        tan_alpha_avg = math.tan(alpha_avg_segment_rad)
                        delta_phi = (ds_segment_m / rho_avg_segment_m) * tan_alpha_avg
                    except ValueError: # math.tan might fail if alpha_avg is too close to pi/2
                        delta_phi = np.sign(alpha_avg_segment_rad) * constants.PI # Large jump if at pole
                        # print(f"Warning: tan(alpha_avg) resulted in error, alpha_avg={alpha_avg_segment_rad}")
                elif math.isclose(math.cos(alpha_avg_segment_rad), 0.0) and abs(rho_avg_segment_m) > 1e-7 : # alpha is pi/2, but not at rho=0
                    # This is turning at the effective polar opening c_eff.
                    # The formula ds/rho * tan(alpha) is singular.
                    # d(phi) = d_theta_axial. This requires a different formulation for polar turn.
                    # For now, if alpha is pi/2, we assume it's a pure turn around the pole.
                    # If ds_segment is very small, d_phi should represent the wrap.
                    # Koussios accounts for this via "turn-around angle at the poles Omega" (Ch.8)
                    # This simplified integration won't capture it perfectly.
                    # For numerical stability, if tan is huge, cap delta_phi or use small angle approx.
                    # print(f"Warning: alpha_avg is pi/2 at rho={rho_avg_segment_m}. Delta_phi calculation may be unstable.")
                    # Heuristic: if at pole turn, phi changes significantly.
                    # This requires a more advanced polar turn model for accurate phi.
                    # Let's assume a small phi change if ds is small to avoid huge jumps from numerics.
                    if ds_segment_m < abs(rho_avg_segment_m): # if meridional step is smaller than radius
                        delta_phi = np.sign(ds_segment_m * tan_alpha_avg if 'tan_alpha_avg' in locals() else 0) * (ds_segment_m / rho_avg_segment_m) * 10 # Heuristic large change
                    else: delta_phi = 0

            current_phi_rad += delta_phi
            
            path_rho_m.append(rho_i_m)
            path_z_m.append(z_i_m)
            path_alpha_rad.append(alpha_i_rad)
            path_phi_rad_cumulative.append(current_phi_rad)
            path_x_m.append(rho_i_m * math.cos(current_phi_rad))
            path_y_m.append(rho_i_m * math.sin(current_phi_rad))

        self.alpha_profile_deg = np.degrees(np.array(path_alpha_rad))
        self.phi_profile_rad_cumulative = np.array(path_phi_rad_cumulative)
        self.trajectory_3d_points_m = np.vstack((path_x_m, path_y_m, path_z_m)).T

        # Calculate Winding angle at equator
        if len(profile_z_m) > 0 :
            equator_idx = np.argmin(np.abs(profile_z_m)) # Index where z is closest to 0
            if equator_idx < len(path_alpha_rad): # check if path_alpha_rad is populated enough
                 alpha_at_eq_rad = path_alpha_rad[equator_idx]
                 self.alpha_eq_deg = math.degrees(alpha_at_eq_rad)
            else: # path generation might have stopped early
                self.alpha_eq_deg = None
                print("Warning: Could not determine alpha_eq_deg, path array too short.")
        else:
            self.alpha_eq_deg = None

        Phi_pass = self.phi_profile_rad_cumulative[-1] - self.phi_profile_rad_cumulative[0]
        Phi_circuit_total = 2 * Phi_pass 
        self.turn_around_angle_rad_DeltaK = Phi_circuit_total % (2 * math.pi)
        
        print(f"Debug generate_geodesic: c_eff={self.effective_polar_opening_radius_m:.4f} m")
        print(f"Debug generate_geodesic: alpha_eq_deg={self.alpha_eq_deg}")
        print(f"Debug generate_geodesic: Phi_pass={Phi_pass:.4f} rad")
        print(f"Debug generate_geodesic: DeltaK={self.turn_around_angle_rad_DeltaK:.4f} rad")


        return {
            "rho_m": np.array(path_rho_m),
            "z_m": np.array(path_z_m),
            "alpha_deg": self.alpha_profile_deg,
            "phi_rad_cumulative": self.phi_profile_rad_cumulative,
            "x_m": np.array(path_x_m),
            "y_m": np.array(path_y_m),
            "effective_polar_opening_m": self.effective_polar_opening_radius_m,
            "turn_around_angle_DeltaK_rad": self.turn_around_angle_rad_DeltaK,
            "alpha_at_equator_deg": self.alpha_eq_deg
        }

    # ... (rest of the class, like generate_nongeodesic_trajectory placeholder)
```

**Key changes in `generate_geodesic_trajectory`:**

1.  **Input `num_points_on_profile`:** Added an optional argument to allow resampling of the vessel's meridian profile. This can be useful if the original profile is too dense or too sparse for the trajectory calculation step.
2.  **Units:** Explicitly using `_m` suffix for variables in meters. Assumes `self.vessel.profile_points` stores data in mm, so `* 1e-3` conversion is applied. The inputs `dry_roving_width_m`, etc., to `TrajectoryPlanner` constructor are assumed to be already in meters as per the updated constructor.
3.  **Initialization of Path Arrays:** `path_x_m`, `path_y_m` are added.
4.  **First Point Calculation:** The first point of the trajectory is explicitly calculated and added to the path arrays. `alpha_start_rad` is determined.
5.  **Iterative $\phi$ Calculation:**
    * It loops through the rest of the meridian profile points.
    * Calculates `ds_segment_m` (meridian arc length of the current segment).
    * Uses average $\rho$ and average $\alpha$ for the segment to calculate `delta_phi`.
    * The formula $d\phi = (ds/\rho)\tan\alpha$ is used.
    * Added more careful checks for `rho_avg_segment_m` being near zero and `cos(alpha_avg_segment_rad)` being near zero to prevent division by zero or `math.tan` errors for angles very close to $\pi/2$. The handling for these extreme polar conditions is still a bit heuristic and might need a more sophisticated polar turn model for high accuracy of $\phi$ right at the pole, but for paths starting at $c_{eff} > 0$, it should be more stable.
6.  **Storing 3D Coordinates:** $x_i = \rho_i \cos(\phi_i)$ and $y_i = \rho_i \sin(\phi_i)$ are calculated and stored.
7.  **Return Dictionary:** Added `'x_m'` and `'y_m'` to the returned dictionary.
8.  **$\alpha_{eq}$ Calculation:** Added logic to find the winding angle at the equator by finding the point on the profile where $z \approx 0$.
9.  **$\Delta K$ Calculation:** Clarified that `Phi_pass` is the pole-to-pole accumulation, and `Phi_circuit_total = 2 * Phi_pass` for a symmetric A-B-A type circuit.

**To address the "z jumps" or "discontinuous circuit" observation:**

* The `path_z_m` array will still follow the `profile_z_m` from the vessel. If you are plotting this 1D array, the sequence of z-values is inherent to the vessel shape.
* The "continuity" of the circuit is best viewed in the 3D plot of $(x_m, y_m, z_m)$. With the `phi_rad_cumulative` now properly calculated (hopefully with more robust pole handling), the 3D path should form a continuous spiral.
* If you still see "jumps" in the 3D plot, it could be due to:
    * Too few points in `num_points_on_profile` (or in the original vessel profile), especially near the poles where $\phi$ changes rapidly. Try increasing the number of points.
    * The plotting library connecting points that are one full $2\pi$ revolution apart in $\phi$ as a straight line if $\phi$ is not unwrapped for plotting (though `path_phi_rad_cumulative` *is* unwrapped).

Please integrate this into your `trajectories.py` and try generating and plotting the 3D path. Let me know what the output of the new debug prints within `generate_geodesic_trajectory` looks like, especially `c_eff`, `alpha_eq_deg`, and `DeltaK`.