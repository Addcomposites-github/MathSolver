You're hitting on some very nuanced and important aspects of trajectory planning, especially for non-geodesic paths and multi-circuit patterns! It sounds like the core non-geodesic math for a single leg is largely working but the "jumps" or discontinuities at the poles when trying to string multiple circuits together are the main issue. This often points to how the *state* (especially the winding angle `alpha` and the azimuthal angle `phi`) is handed off and re-initialized between a helical leg, a turnaround, and the subsequent helical leg.

Let's break down the problem and propose solutions.

**Understanding the "Jump" Problem in Multi-Circuit Non-Geodesic Paths:**

1.  **Natural Path vs. Patterned Path:**
    * A single non-geodesic leg, solved with the ODE, will have a "natural" starting and ending winding angle (`alpha`) and a "natural" azimuthal sweep (`delta_phi_leg`).
    * A "pattern" for full coverage requires a specific, predictable net azimuthal shift per full circuit (`Delta_Phi_pattern_rad`).
    * The "jump" likely occurs because the end state of one leg (plus a simple turnaround) doesn't naturally lead to the *exact* required starting state (phi and alpha) for the next leg that would maintain pattern continuity *and* the non-geodesic evolution dictated by friction.

2.  **Turnaround's Role:**
    * In your current `_generate_polar_turnaround_segment_fixed_phi_advance`, the fiber path is purely circumferential ($\alpha = 90^\circ$). This is a strong assumption.
    * When exiting this circumferential turnaround, the next helical leg starts with $\alpha = 90^\circ$. The non-geodesic ODE solver then calculates how $\alpha$ evolves from $90^\circ$ based on $\mu$ and the local geometry.
    * The "jump" might mean that the `phi` position after the turnaround, combined with starting the next leg at $\alpha=90^\circ$, doesn't align with where the *continuous solution of the ODE from the previous leg would have gone* if it could have somehow "turned the corner" non-geodesically without a forced circumferential segment.

3.  **Discontinuity in Winding Angle (`alpha`) for Non-Geodesic Multi-Pass:**
    * If Leg 1 ends at Pole B with $\alpha_{end\_leg1}$, and the turnaround is circumferential, Leg 2 (Pole B to Pole A) starts its ODE solution with $\alpha_{start\_leg2} = 90^\circ$.
    * This forced reset to $90^\circ$ at the start of each helical segment after a turnaround *is* a discontinuity in the *helical part* of the winding angle evolution. However, it's a common simplification for modeling turnarounds. The physical fiber does become (nearly) circumferential.
    * The "jump" in visualization might be because the `phi` angle after the turnaround leads to a starting $(x,y,z)$ for the next leg that is far from the previous leg if the `phi_span_for_each_turnaround_rad` isn't correctly calculated to ensure pattern coherence.

**Proposed Next Steps to Fix Multi-Circuit Non-Geodesic Continuity:**

The primary goal is to make the start of each "pass" (helical leg) correctly positioned in 3D space to follow the desired pattern.

**1. Verify and Refine `advancement_per_full_circuit_rad` and `phi_span_for_each_turnaround_rad` for Non-Geodesic Patterns:**

* **The Challenge:** For non-geodesic paths, the natural azimuthal sweep of a leg (Pole A to Pole B) is *not* the same as for a geodesic path with a fixed Clairaut's constant. It depends on the evolving $\alpha(s)$ profile, which in turn depends on $\mu$.
* **Accurate `Delta_Phi_pattern_rad`:**
    * This value dictates where the *start* of circuit `N+1` should be relative to the start of circuit `N` (in terms of `phi`).
    * For now, continue with your simplified `advancement_per_full_circuit_rad = (2 * math.pi / num_target_circuits_for_pattern_closure) * pattern_skip_factor`. This defines the *target*.
* **Calculating `phi_span_for_each_turnaround_rad` More Carefully:**
    * Let `phi_sweep_leg1_actual` be the actual $\Delta\phi$ produced by `_generate_non_geodesic_leg` for the first leg (e.g., Pole A to B).
    * Let `phi_sweep_leg2_actual` be the actual $\Delta\phi$ for the second leg (e.g., Pole B to A).
    * The sum of the two turnaround spans (`2 * phi_span_for_each_turnaround_rad` if symmetric) must compensate for the difference between the natural sweep and the target pattern advance:
        `phi_sweep_leg1_actual + span_turnaround1 + phi_sweep_leg2_actual + span_turnaround2 = advancement_per_full_circuit_rad` (all modulo $2\pi$, or considered as net change if advancement > $2\pi$).
    * This means `span_turnaround1 + span_turnaround2 = advancement_per_full_circuit_rad - (phi_sweep_leg1_actual + phi_sweep_leg2_actual)`.
    * You could distribute this required additional shift: `phi_span_for_each_turnaround_rad = (advancement_per_full_circuit_rad - (phi_sweep_leg1_actual + phi_sweep_leg2_actual)) / 2.0`.
    * **Important Caveat**: The `phi_span_for_each_turnaround_rad` *must be positive* (or at least represent a forward progression of phi). If the natural sweep of the non-geodesic legs is already greater than the desired pattern advancement, this simple distribution won't work. True pattern closure often relies on the `Delta_Phi_total` from Koussios which is the *actual resulting angular advancement of one full circuit given a starting condition and geometry*.
    * **For now, let's stick to the simpler:** `phi_span_for_each_turnaround_rad = advancement_per_full_circuit_rad / 2.0`. This means we are *forcing* the turnarounds to cover a specific angular distance to achieve the pattern. The visualization will show if this looks reasonable or creates too much circumferential winding.

**2. Ensure Correct State Initialization for Each Leg in `generate_multi_circuit_non_geodesic_trajectory`:**

* `current_overall_phi_rad`: This should be the `phi` at the end of the previous segment (leg or turnaround). This seems to be handled correctly.
* `current_sin_alpha_for_upcoming_leg`:
    * For the very first leg of the *entire process*: Use `math.sin(math.radians(initial_alpha_at_first_pole_deg))`.
    * For any leg that *starts after a circumferential turnaround*: `initial_sin_alpha` for the ODE solver should be `1.0` (i.e., $\alpha = 90^\circ$). This is what your last version correctly implements.

**3. Debugging the "Jump" in Visualization:**

If the visualization connects the end of one pass (e.g., end of Turnaround 1 at Pole B) to a visually distant start of the next pass (e.g., start of Leg 2 at Pole B), it means the $(x,y,z)$ coordinates are not lining up.

* **Check `rho_at_turnaround` and `z_at_turnaround`**:
    * The `_generate_polar_turnaround_segment_fixed_phi_advance` is called with `c_eff=rho_at_turnaroundX` and `z_pole=z_at_turnaroundX`. These are the `rho` and `z` from the *last point of the preceding helical leg*. This is correct. The turnaround path should then be on a circle of radius `rho_at_turnaroundX` at axial position `z_at_turnaroundX`.
* **Start of Next Leg**:
    * The first point of the *next* helical leg (`_generate_non_geodesic_leg`) must also start at this *same* `(rho_at_turnaroundX, z_at_turnaroundX)` but with its `phi` value being the `phi_after_turnaroundX`.
    * The `_generate_non_geodesic_leg` uses the `profile_r_m_calc` and `profile_z_m_calc`. If `is_forward_on_profile_for_leg_gen=True`, it starts from `profile_..._calc[0]`. If `False`, it starts from `profile_..._calc[-1]`.
    * **This is a likely source of discontinuity for non-geodesic paths**: The *actual* radius `rho_at_turnaroundX` where the non-geodesic leg ended (and where $\alpha$ might have naturally hit $90^\circ$, or where we decided to end the helical segment) might *not* perfectly coincide with `profile_r_m_calc[0]` or `profile_r_m_calc[-1]` of the standard profile.
    * **Solution Idea**:
        1.  When a non-geodesic leg ends (either $\alpha \to 90^\circ$ or it reaches the end of the defined profile section for that leg), record its actual final $(\rho, z, \alpha, \phi)$.
        2.  The turnaround path is generated at this final $(\rho, z)$.
        3.  The *next* non-geodesic leg's ODE solution must *start* from these exact $(\rho, z)$ coordinates on the mandrel surface, with an initial $\sin\alpha = 1.0$. The `profile_r_m_calc` and `profile_z_m_calc` are used by the ODE solver to get $k_m, k_p$, etc. The solver needs to find the correct starting *index* or $z$-value on the `profile_..._calc` that corresponds to the `z_at_turnaroundX`.

**Refined Logic for `generate_multi_circuit_non_geodesic_trajectory` (Conceptual focus on transitions):**

```python
# In TrajectoryPlanner
    def generate_multi_circuit_non_geodesic_trajectory(self, ...):
        # ... (initial setup, profile resampling, pattern advancement calc as before) ...
        
        current_overall_phi_rad = 0.0
        # For the VERY FIRST leg of the entire process
        current_sin_alpha_for_upcoming_leg = math.sin(math.radians(initial_alpha_at_first_pole_deg))
        
        # Determine which end of the full profile corresponds to "Pole A" (start)
        # This depends on how your profile_z_m_calc is oriented (e.g., min z to max z)
        z_pole_A = profile_z_m_calc[0] # Assuming profile starts at Pole A
        rho_pole_A = profile_r_m_calc[0]
        z_pole_B = profile_z_m_calc[-1] # Assuming profile ends at Pole B
        rho_pole_B = profile_r_m_calc[-1]

        last_leg_end_rho = rho_pole_A # Initialize for the first leg's start
        last_leg_end_z = z_pole_A   # Initialize

        for circuit_idx in range(num_circuits_to_generate_for_vis):
            # ... (print circuit info) ...

            # --- LEG 1 (e.g., from Pole A towards Pole B) ---
            # The profile passed to _generate_non_geodesic_leg should be the segment
            # from the current physical starting point (last_leg_end_z) towards the other pole.
            # This requires finding the index in profile_z_m_calc closest to last_leg_end_z
            # and slicing the profile arrays accordingly for the forward direction.
            
            # Simplified: Assume full profile for now, solver starts from initial_sin_alpha
            # at the beginning of the provided profile segment.
            leg1_profile_r_segment = profile_r_m_calc 
            leg1_profile_z_segment = profile_z_m_calc
            
            leg1_data = self._generate_non_geodesic_leg(
                leg1_profile_r_segment, leg1_profile_z_segment,
                current_sin_alpha_for_upcoming_leg, # This is sin_alpha at (last_leg_end_rho, last_leg_end_z)
                current_overall_phi_rad,            # This is phi at (last_leg_end_rho, last_leg_end_z)
                is_forward_on_profile_for_leg_gen=True, # Integrate along the provided profile segment
                leg_number_info=f"C{circuit_idx+1}-NonGeoLeg1",
                rk4_steps_factor_override=rk4_steps_factor
            )
            # ... (handle if leg1_data is None, append to all_path_segments_data) ...
            # ... (update current_overall_phi_rad from leg1_data['phi_rad'][-1]) ...
            last_leg_end_rho = leg1_data['rho_m'][-1]
            last_leg_end_z = leg1_data['z_m'][-1]
            
            # --- TURNAROUND 1 (at Pole B physical location) ---
            turnaround1_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=last_leg_end_rho, z_pole=last_leg_end_z, # Use actual end of leg
                phi_start=current_overall_phi_rad, # Use phi from end of leg1
                fixed_phi_advance_rad=phi_span_for_each_turnaround_rad,
                # ...
            )
            # ... (append turnaround, update current_overall_phi_rad from turnaround1_data_points[-1]['phi']) ...
            # After circumferential turnaround, next helical leg starts with sin_alpha = 1.0
            current_sin_alpha_for_upcoming_leg = 1.0 
            # The (rho,z) start for leg 2 is the end of turnaround (same rho,z as end of leg1)
            last_leg_end_rho = turnaround1_data_points[-1]['rho'] if turnaround1_data_points else last_leg_end_rho
            last_leg_end_z = turnaround1_data_points[-1]['z'] if turnaround1_data_points else last_leg_end_z


            # --- LEG 2 (e.g., from Pole B towards Pole A) ---
            # Profile needs to be presented in the direction of integration (Pole B to Pole A)
            leg2_profile_r_segment = profile_r_m_calc[::-1] 
            leg2_profile_z_segment = profile_z_m_calc[::-1]
            # The initial_sin_alpha is 1.0 (from turnaround).
            # The initial_phi_rad is from end of turnaround1.
            # The ODE solver will use the first point of leg2_profile_z_segment as its z_start.
            # We must ensure this z_start aligns with last_leg_end_z.
            # This implies that _generate_non_geodesic_leg should perhaps take an explicit
            # (z_start_on_profile, initial_sin_alpha_at_z_start)

            leg2_data = self._generate_non_geodesic_leg(
                leg2_profile_r_segment, leg2_profile_z_segment,
                current_sin_alpha_for_upcoming_leg, # sin_alpha = 1.0
                current_overall_phi_rad,
                is_forward_on_profile_for_leg_gen=True, # Integrate on the provided (reversed) profile
                leg_number_info=f"C{circuit_idx+1}-NonGeoLeg2",
                rk4_steps_factor_override=rk4_steps_factor
            )
            # ... (handle, append, update current_overall_phi_rad) ...
            last_leg_end_rho = leg2_data['rho_m'][-1]
            last_leg_end_z = leg2_data['z_m'][-1]

            # --- TURNAROUND 2 (at Pole A physical location) ---
            # ... (similar to Turnaround 1) ...
            # After circumferential turnaround, next circuit's helical leg starts with sin_alpha = 1.0
            current_sin_alpha_for_upcoming_leg = 1.0
            # last_leg_end_rho, last_leg_end_z updated from turnaround2
        
        # ... (consolidation and return) ...
```

**Key Change for Continuity:**

The most important part is that the `_generate_non_geodesic_leg` (which internally calls the RK4 solver) needs to correctly start its integration from the physical $(\rho, z)$ point where the previous segment (turnaround) ended, using the appropriate `initial_sin_alpha` for that starting point on the correct segment of the overall mandrel profile.

If `_solve_non_geodesic_sin_alpha_profile_rk4` always integrates from `profile_z_m[0]` to `profile_z_m[-1]` of the *segment passed to it*, then:
* For Leg 1 (Pole A to B): Pass the natural profile. `initial_sin_alpha` is `sin(initial_alpha_at_first_pole_deg)` or `1.0` if after a conceptual previous turnaround.
* For Leg 2 (Pole B to A): Pass the *reversed* profile. `initial_sin_alpha` is `1.0`.

The "jump" you are seeing in visualization likely means that the $(x,y,z)$ coordinates of the end of a turnaround segment do not match the $(x,y,z)$ coordinates of the very first point generated by the subsequent `_generate_non_geodesic_leg` call. This usually happens if the `initial_phi_rad` is correct, but the starting $(\rho, z)$ point for the leg solver doesn't perfectly align with the actual pole where the turnaround occurred, or if the `profile_idx` isn't reset/chosen correctly for the start of the new leg.

The function `_generate_leg_from_sin_alpha_profile` already takes the `leg_profile_r_m` and `leg_profile_z_m` and iterates through them. The first point of this list should be the start of the new leg.

**To confirm:**
When Leg 1 ends at `(rho_L1e, z_L1e, phi_L1e, alpha_L1e)`.
Turnaround 1 occurs at `(rho_L1e, z_L1e)`, and its phi goes from `phi_L1e` to `phi_T1e`. Alpha is 90.
Leg 2 should start its *physical path* at `(rho_L1e, z_L1e)` with `phi = phi_T1e` and an *initial condition for its ODE solver* of `sin_alpha = 1.0`. The ODE solver then uses the reversed profile (`profile_z_m[::-1]`, `profile_r_m[::-1]`) to find properties as it integrates away from this point.

It seems your `_generate_non_geodesic_leg` uses the `is_forward_on_profile` flag for the `_solve_non_geodesic_sin_alpha_profile_rk4` call.
Ensure that when `is_forward_on_profile = False` for the solver, it correctly uses `initial_sin_alpha` at `profile_z_m[-1]` and integrates backward, and that the resulting `sin_alpha_on_profile` is then correctly indexed by `_generate_leg_from_sin_alpha_profile` when it iterates through the `leg_profile_...` arrays (which would be reversed).

The most direct way to ensure continuity is for `_generate_non_geodesic_leg` to effectively start its path generation at the exact $(\rho, z, \phi)$ of the last point of the preceding turnaround, with $\sin\alpha=1$.