That's a crucial requirement for practical design: ensuring that a user-defined winding angle (typically for the cylindrical section) is physically and mathematically achievable before attempting to generate the full trajectory.

Here's how we can integrate this validation into the `TrajectoryPlanner` class:

**1. Modify `TrajectoryPlanner.__init__`:**
   Add an optional parameter for the target cylinder angle. If provided, the planner will attempt to use it.

**2. Create a Validation Method `validate_and_set_clairauts_constant`:**
   This method will:
   a. Take a `target_cylinder_angle_deg`.
   b. Calculate the implied Clairaut's constant ($c_{implied}$) needed to achieve this angle on the cylinder: $c_{implied} = R_{cylinder} \cdot \sin(\alpha_{target\_cyl\_rad})$.
   c. Compare $c_{implied}$ with the physically minimum possible turning radius, `self.effective_polar_opening_radius_m` (let's call this $c_{eff\_physical}$), which is determined by the actual dome geometry at the pole and the roving dimensions.
   d. **Validation condition:** For the target angle to be achievable, $c_{implied}$ must be $\ge c_{eff\_physical}$. If $c_{implied} < c_{eff\_physical}$, the desired angle is too shallow, as it would require turning around at a radius smaller than what's physically possible for the roving at the given dome entry.
   e. If valid, set `self.clairauts_constant_for_path_m = c_{implied}`. Otherwise, raise an error or return a status.

**3. Modify `calculate_geodesic_alpha_at_rho`:**
   This method will now use `self.clairauts_constant_for_path_m` for its calculations instead of always using `self.effective_polar_opening_radius_m`.

**4. Modify `generate_geodesic_trajectory`:**
   It will use the winding angles derived from `self.clairauts_constant_for_path_m`. The logic for determining the "windable segment" (where $\rho \ge \text{self.clairauts\_constant\_for\_path\_m}$) remains essential.

Here's the proposed code update for `trajectories.py`:

```python
# copv_design_tool/winding/trajectory.py
import numpy as np
import math
from typing import Dict, Tuple, List, Optional
try:
    from ..core.vessel_geometry import VesselGeometry
    from ..utils.numerical_tools import numerical_integrate_samples
    from .. import constants
except ImportError:
    import sys
    import os
    sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
    from core.vessel_geometry import VesselGeometry
    from utils.numerical_tools import numerical_integrate_samples
    import constants

class TrajectoryPlanner:
    def __init__(self,
                 vessel_geometry: VesselGeometry,
                 dry_roving_width_m: float, # Expecting meters
                 dry_roving_thickness_m: float, # Expecting meters
                 roving_eccentricity_at_pole_m: float = 0.0, # Expecting meters
                 target_cylinder_angle_deg: Optional[float] = None): # User-defined target
        
        print("\nDEBUG trajectories.py: Entering TrajectoryPlanner.__init__")
        self.vessel = vessel_geometry
        self.dry_roving_width_m = dry_roving_width_m
        self.dry_roving_thickness_m = dry_roving_thickness_m
        self.roving_eccentricity_at_pole_m = roving_eccentricity_at_pole_m
        self.target_cylinder_angle_deg = target_cylinder_angle_deg

        self.effective_polar_opening_radius_m = None # Min physical turning radius at pole
        self.clairauts_constant_for_path_m = None    # Actual c used for path gen (either c_eff or c_implied)
        
        self.alpha_profile_deg = None
        self.phi_profile_rad_cumulative = None
        self.turn_around_angle_rad_DeltaK = None
        self.alpha_eq_deg = None # This will be the actual angle at equator based on chosen c
        self.trajectory_3d_points_m = None

        if self.vessel.profile_points is None:
            print("DEBUG trajectories.py: Vessel profile_points is None, calling self.vessel.generate_profile().")
            self.vessel.generate_profile()
            if self.vessel.profile_points is None:
                raise ValueError("Vessel profile_points is STILL None after calling generate_profile() in TrajectoryPlanner.")
        
        # 1. Calculate the physical minimum turning radius (c_eff)
        self._calculate_effective_polar_opening()
        if self.effective_polar_opening_radius_m is None:
            raise ValueError("Failed to calculate effective polar opening radius (physical minimum).")

        # 2. Validate target angle and set the Clairaut's constant for path generation
        if self.target_cylinder_angle_deg is not None:
            if not self._validate_and_set_clairauts_constant_from_target_angle(self.target_cylinder_angle_deg):
                # Error already printed by the validation method.
                # Depending on desired behavior, either raise error or default to c_eff.
                # For now, an error is more informative if a target can't be met.
                raise ValueError(f"Target cylinder angle {self.target_cylinder_angle_deg} deg is not physically or mathematically achievable.")
            print(f"DEBUG: Using Clairaut's constant c = {self.clairauts_constant_for_path_m:.6f} m (derived from target cylinder angle).")
        else:
            # No target angle specified, use the physical minimum turning radius as Clairaut's constant
            self.clairauts_constant_for_path_m = self.effective_polar_opening_radius_m
            print(f"DEBUG: No target cylinder angle. Using Clairaut's constant c_eff = {self.clairauts_constant_for_path_m:.6f} m (physical pole limit).")
        
        print("DEBUG trajectories.py: TrajectoryPlanner.__init__ completed.")

    def _validate_and_set_clairauts_constant_from_target_angle(self, target_alpha_cyl_deg: float) -> bool:
        """
        Validates if the target cylinder angle is achievable and sets the
        Clairaut's constant to be used for path generation.
        """
        if not (0 < target_alpha_cyl_deg < 90):
            print(f"ERROR validate_angle: Target cylinder angle {target_alpha_cyl_deg} deg must be > 0 and < 90 for a helical path on dome.")
            return False

        # c_eff_physical is already calculated and stored in self.effective_polar_opening_radius_m
        c_eff_physical = self.effective_polar_opening_radius_m
        
        R_cyl_m = self.vessel.inner_radius * 1e-3 # Cylinder radius in meters
        alpha_cyl_target_rad = math.radians(target_alpha_cyl_deg)
        
        c_implied_by_target_angle_m = R_cyl_m * math.sin(alpha_cyl_target_rad)

        print(f"DEBUG _validate_angle: Target alpha_cyl={target_alpha_cyl_deg:.2f} deg")
        print(f"  R_cyl_m: {R_cyl_m:.6f} m")
        print(f"  Implied Clairaut's constant (c_implied): {c_implied_by_target_angle_m:.6f} m")
        print(f"  Physical min turning radius (c_eff_physical): {c_eff_physical:.6f} m")

        if c_implied_by_target_angle_m < c_eff_physical - 1e-7: # Add tolerance
            print(f"ERROR validate_angle: Target cylinder angle {target_alpha_cyl_deg:.2f} deg is TOO SHALLOW.")
            print(f"  It implies a turning radius of {c_implied_by_target_angle_m*1000:.2f}mm, "
                  f"but the roving/dome physical minimum turning radius (c_eff_physical) is {c_eff_physical*1000:.2f}mm.")
            print(f"  Try a larger (steeper) cylinder angle.")
            return False
        
        if c_implied_by_target_angle_m >= R_cyl_m - 1e-7 : # Implied c is at or beyond cylinder radius
            print(f"ERROR validate_angle: Target cylinder angle {target_alpha_cyl_deg:.2f} deg is TOO STEEP (or hoop).")
            print(f"  It implies a turning radius of {c_implied_by_target_angle_m*1000:.2f}mm, "
                  f"which is at or beyond cylinder radius {R_cyl_m*1000:.2f}mm. Path won't enter dome.")
            return False

        self.clairauts_constant_for_path_m = c_implied_by_target_angle_m
        return True

    def calculate_geodesic_alpha_at_rho(self, rho_m: float) -> Optional[float]:
        """Calculates geodesic winding angle (radians) at a given radius rho_m using the set Clairaut's constant."""
        if self.clairauts_constant_for_path_m is None:
            # This should have been set in __init__
            print("CRITICAL ERROR: Clairaut's constant for path not set before alpha calculation!")
            return None 
        
        c_path = self.clairauts_constant_for_path_m
        
        if rho_m < c_path - 1e-9 : 
            # print(f"Debug alpha_calc: Target rho_m ({rho_m:.6f}) < c_path ({c_path:.6f}). Geodesic alpha undefined.")
            return None 
        if abs(rho_m) < 1e-9: 
            return constants.PI / 2.0 if np.isclose(c_path, 0.0) else None

        asin_arg = c_path / rho_m
        if asin_arg > 1.0: asin_arg = 1.0 # Clamp due to potential numerical inaccuracies
        elif asin_arg < -1.0: asin_arg = -1.0 
            
        try:
            alpha_rad = math.asin(asin_arg)
            return alpha_rad
        except ValueError:
            print(f"Error: math.asin arg {asin_arg} out of range for rho={rho_m}, c_path={c_path}")
            return None

    # The _calculate_effective_polar_opening method remains the same, calculating the *physical minimum*.
    # The generate_geodesic_trajectory method will now use self.clairauts_constant_for_path_m
    # as the 'c' for its alpha calculations and for determining the windable segment.

    def generate_geodesic_trajectory(self, 
                                     num_points_dome_pass: int = 100, 
                                     num_points_cylinder_pass: int = 10):
        # ... (initial checks for profile_points as before) ...
        if self.clairauts_constant_for_path_m is None:
            print("Error: Clairaut's constant for path generation not set. Initialize planner with target angle or ensure c_eff calculable.")
            return None # Or raise error
            
        c_for_winding = self.clairauts_constant_for_path_m # Use the validated/set constant
        print(f"\nDEBUG generate_geodesic_trajectory (Adaptive): Using Clairaut's constant for winding c = {c_for_winding:.6f} m")

        # ... (rest of the method for resampling profile: fwd_dome_r_calc, cyl_r_calc, aft_dome_r_calc etc.
        #      and adaptive point generation remains the same) ...
        
        # CRITICAL CHANGE: The filtering of windable segments now uses c_for_winding
        # In _resample_segment or when creating fwd_dome_r_calc, aft_dome_r_calc etc.
        # The logic for finding 'windable_fwd_indices' etc. should use 'c_for_winding'
        # And the first point of the path should start where rho = c_for_winding.

        # Example adjustment (conceptual, this needs to be integrated into your adaptive sampling logic):
        # windable_indices = np.where(profile_r_m_resampled >= c_for_winding - 1e-7)[0]
        # And the loop for alpha and phi calculation will use calculate_geodesic_alpha_at_rho
        # which now internally uses self.clairauts_constant_for_path_m.

        # The existing logic in generate_geodesic_trajectory that determines the
        # active_profile_r/z based on c_eff should now use c_for_winding.
        # For example:
        # valid_segment_indices = np.where(profile_r_m_resampled >= c_for_winding - 1e-7)[0]
        # All subsequent calculations for alpha, phi, and path points use this c_for_winding via
        # calls to self.calculate_geodesic_alpha_at_rho.
        
        # ... (The rest of your existing generate_geodesic_trajectory logic for looping,
        #      calculating alpha, ds, delta_phi, x,y,z, and returning the dictionary.
        #      Ensure all alpha calculations use self.calculate_geodesic_alpha_at_rho which uses self.clairauts_constant_for_path_m)

        # For brevity, I'm not showing the full duplicated generate_geodesic_trajectory.
        # The key is that it now relies on self.clairauts_constant_for_path_m
        # when determining the actual turning radius for the path and calculating alphas.

        # --- Snippet of how it would be used inside generate_geodesic_trajectory ---
        # (Assuming profile_r_m_calc, profile_z_m_calc are your adaptively sampled points for the full vessel)
        
        path_rho_m_traj, path_z_m_traj, path_alpha_rad, path_phi_rad_cumulative, path_x_m, path_y_m = [], [], [], [], [], []
        current_phi_rad = 0.0
        first_valid_point_found = False

        for i in range(len(profile_r_m_calc)): # profile_r_m_calc is your adaptively sampled rho array
            rho_i_m = profile_r_m_calc[i]
            z_i_m = profile_z_m_calc[i]
            
            if rho_i_m < self.clairauts_constant_for_path_m - 1e-7: # Path cannot go inside its Clairaut's constant
                if not first_valid_point_found:
                    continue # Skip until we find the actual start of the windable path
                else:
                    # print(f"Path segment for rho={rho_i_m:.4f}m ended as it's < c_path={self.clairauts_constant_for_path_m:.4f}m.")
                    break # Path has turned around and is now going "inside" c_path on other dome
            
            alpha_i_rad = self.calculate_geodesic_alpha_at_rho(rho_i_m) # This uses self.clairauts_constant_for_path_m

            if alpha_i_rad is None: # Should be ~pi/2 if rho_i_m is c_path
                if np.isclose(rho_i_m, self.clairauts_constant_for_path_m):
                    alpha_i_rad = constants.PI / 2.0
                else: # Problem
                    if path_alpha_rad: alpha_i_rad = path_alpha_rad[-1] # Use previous
                    else: alpha_i_rad = constants.PI / 2.0 # Fallback
                    print(f"Warning: Alpha undefined at rho={rho_i_m:.4f} with c_path={self.clairauts_constant_for_path_m:.4f}. Using fallback alpha.")

            if not first_valid_point_found:
                first_valid_point_found = True
                # Add first point to trajectory lists
                path_rho_m_traj.append(rho_i_m); path_z_m_traj.append(z_i_m); path_alpha_rad.append(alpha_i_rad)
                path_phi_rad_cumulative.append(current_phi_rad)
                path_x_m.append(rho_i_m * math.cos(current_phi_rad)); path_y_m.append(rho_i_m * math.sin(current_phi_rad))
                continue

            # ... (rest of ds_segment, delta_phi, point appending logic as before) ...
            # ... ensure to use path_rho_m_traj[-1], path_z_m_traj[-1], path_alpha_rad[-1] for prev values ...
        
        # ... (Update self.alpha_eq_deg, self.turn_around_angle_rad_DeltaK based on the generated path_..._traj arrays) ...
        # ... (Return the dictionary with path_..._traj arrays) ...
        if not path_rho_m_traj:
             print("Error: No valid trajectory points generated with current Clairaut's constant.")
             return None
        # ... (populate self.alpha_profile_deg etc. from the path_..._traj lists and return dict)
        self.alpha_profile_deg = np.degrees(np.array(path_alpha_rad))
        self.phi_profile_rad_cumulative = np.array(path_phi_rad_cumulative)
        self.trajectory_3d_points_m = np.vstack((path_x_m, path_y_m, path_z_m_traj)).T

        if len(path_z_m_traj) > 0 :
            equator_idx = np.argmin(np.abs(np.array(path_z_m_traj))) 
            if equator_idx < len(path_alpha_rad):
                 alpha_at_eq_rad = path_alpha_rad[equator_idx]
                 self.alpha_eq_deg = math.degrees(alpha_at_eq_rad) # This is the *actual* angle at equator for the *chosen C*
            else: self.alpha_eq_deg = None
        else: self.alpha_eq_deg = None

        if self.target_cylinder_angle_deg and self.alpha_eq_deg is not None:
            print(f"DEBUG: Target Cyl Angle: {self.target_cylinder_angle_deg:.2f} deg, Actual Eq Angle: {self.alpha_eq_deg:.2f} deg")
            # Note: alpha_eq will be based on R_cyl and self.clairauts_constant_for_path_m
            # If clairauts_constant_for_path_m was set from target_cylinder_angle_deg and R_cyl,
            # then alpha_eq should indeed be close to target_cylinder_angle_deg IF the equator is on cylinder.

        # ... rest of return statement ...
        return {"rho_m": np.array(path_rho_m_traj), #... etc.
               }


    # _calculate_effective_polar_opening remains as it calculates the physical minimum c_eff
    # based on geometry and roving, not a target angle.
```

**How to use it:**

```python
# In your main script
try:
    planner = TrajectoryPlanner(
        vessel_geometry=vessel_geom,
        dry_roving_width_m=0.003,  # 3mm IN METERS
        dry_roving_thickness_m=0.0002, # 0.2mm IN METERS
        roving_eccentricity_at_pole_m=0.0,
        target_cylinder_angle_deg=30.0 # User wants 30 deg on cylinder
    )
    trajectory_data = planner.generate_geodesic_trajectory(num_points_dome_pass=100, num_points_cylinder_pass=20)
    if trajectory_data:
        # Plot, analyze...
        print(f"Trajectory generated with cylinder angle ~{planner.alpha_eq_deg:.2f} deg (if equator is on cylinder).")
        print(f"Clairaut's constant used for path: {planner.clairauts_constant_for_path_m*1000:.2f} mm")

except ValueError as e:
    print(f"Error during trajectory planning: {e}")

# Example without target angle (uses physical c_eff)
try:
    planner_auto_angle = TrajectoryPlanner(
        vessel_geometry=vessel_geom,
        dry_roving_width_m=0.003,
        dry_roving_thickness_m=0.0002,
        roving_eccentricity_at_pole_m=0.0
    )
    trajectory_data_auto = planner_auto_angle.generate_geodesic_trajectory()
    if trajectory_data_auto:
        print(f"Trajectory (auto angle) generated with cylinder angle ~{planner_auto_angle.alpha_eq_deg:.2f} deg.")
        print(f"Clairaut's constant used (c_eff): {planner_auto_angle.clairauts_constant_for_path_m*1000:.2f} mm")
except ValueError as e:
    print(f"Error (auto angle): {e}")
```

This structure ensures that if a `target_cylinder_angle_deg` is given:
1.  The physical minimum turning radius ($c_{eff\_physical}$) is calculated first based on actual dome geometry and roving size.
2.  The implied Clairaut constant ($c_{implied}$) needed for the target angle on the cylinder is calculated.
3.  If $c_{implied} < c_{eff\_physical}$, it's an error (angle too shallow).
4.  If $c_{implied} \ge R_{cylinder}$, it's an error (angle too steep or hoop, won't form a dome path).
5.  If valid, this $c_{implied}$ is used as `self.clairauts_constant_for_path_m` for all subsequent geodesic $\alpha$ calculations.
6.  If no target angle is given, `self.clairauts_constant_for_path_m` defaults to `self.effective_polar_opening_radius_m` ($c_{eff\_physical}$).

The `generate_geodesic_trajectory` then uses `self.clairauts_constant_for_path_m` to determine the actual windable path boundaries and calculate all angles. The actual angle achieved on the cylinder (at the equator) is reported back as `self.alpha_eq_deg`.