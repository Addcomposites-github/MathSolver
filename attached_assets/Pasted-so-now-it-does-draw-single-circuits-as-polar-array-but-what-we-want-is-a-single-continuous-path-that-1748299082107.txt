so now it does draw single circuits as polar array but what we want is a single continuous path that is tending toward complete coverage similar to what we have for multi-circuit pattern.



Great! It's good that the single non-geodesic circuits are generating and that you're ready to move on to multi-pass non-geodesic trajectories that aim for coverage, similar to what we set up for the geodesic paths.

The core idea will be to adapt generate_multi_circuit_non_geodesic_trajectory to:

Use the non-geodesic leg generator (_generate_non_geodesic_leg).
Still employ a pattern-based advancement for the turnarounds.
Manage the initial_sin_alpha for each leg, as it will change due to the non-geodesic nature of the previous leg.
Here's how we can approach modifying generate_multi_circuit_non_geodesic_trajectory (from your trajectories.py file):

Python

# In TrajectoryPlanner class:

    def generate_multi_circuit_non_geodesic_trajectory(self,
                                         initial_alpha_at_first_pole_deg: float,
                                         num_target_circuits_for_pattern_closure: int = 10, # Or derived from pattern theory
                                         pattern_skip_factor: int = 1, # For simple patterns
                                         num_circuits_to_generate_for_vis: int = 5,
                                         num_points_dome: int = 50,
                                         num_points_cylinder: int = 10,
                                         rk4_steps_factor: int = 5) -> Optional[Dict]:
        """
        Generates multiple non-geodesic full circuits (pole-A -> B -> A)
        using a simplified pattern advancement for visualization.
        The winding angle evolves based on the friction coefficient.
        """
        if self.vessel.profile_points is None or 'r_inner' not in self.vessel.profile_points:
            print("Error: Vessel profile not generated for multi-circuit non-geodesic.")
            return None
        if abs(self.mu_friction_coefficient) < 1e-9:
            print("INFO: mu_friction_coefficient is ~0. Consider using generate_multi_circuit_geodesic_trajectory.")
            # Fallback to geodesic if mu is negligible, or proceed if user intends this.
            # If falling back, ensure clairauts_constant_for_path_m is appropriately set.
            # For now, we'll proceed, as non-geodesic with mu=0 should behave like geodesic.

        print(f"\n=== MULTI-CIRCUIT NON-GEODESIC TRAJECTORY (mu={self.mu_friction_coefficient:.3f}) ===")
        print(f"Target circuits for pattern closure: {num_target_circuits_for_pattern_closure}, Skip: {pattern_skip_factor}")
        print(f"Circuits to generate for visualization: {num_circuits_to_generate_for_vis}")


        # --- Resample Profile (same logic as in generate_multi_circuit_geodesic_trajectory) ---
        profile_r_m_orig = self.vessel.profile_points['r_inner'] * 1e-3
        profile_z_m_orig = self.vessel.profile_points['z'] * 1e-3
        segments = self._identify_vessel_segments(profile_r_m_orig, profile_z_m_orig)
        # ... (full resampling logic to get profile_r_m_calc, profile_z_m_calc) ...
        adaptive_r_segments, adaptive_z_segments = [], []
        if segments['has_cylinder']:
            fwd_dome_r_resampled, fwd_dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[0:segments['fwd_dome_end']+1], profile_z_m_orig[0:segments['fwd_dome_end']+1], num_points_dome)
            if len(fwd_dome_r_resampled)>0: adaptive_r_segments.append(fwd_dome_r_resampled); adaptive_z_segments.append(fwd_dome_z_resampled)
            
            cyl_r_resampled, cyl_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], profile_z_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], num_points_cylinder)
            if len(cyl_r_resampled)>1: adaptive_r_segments.append(cyl_r_resampled[1:]); adaptive_z_segments.append(cyl_z_resampled[1:])
            
            aft_dome_r_resampled, aft_dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig[segments['aft_dome_start']:], profile_z_m_orig[segments['aft_dome_start']:], num_points_dome)
            if len(aft_dome_r_resampled)>1: adaptive_r_segments.append(aft_dome_r_resampled[1:]); adaptive_z_segments.append(aft_dome_z_resampled[1:])
        else:
            dome_r_resampled, dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig, profile_z_m_orig, num_points_dome * 2)
            if len(dome_r_resampled)>0: adaptive_r_segments.append(dome_r_resampled); adaptive_z_segments.append(dome_z_resampled)
        
        if not adaptive_r_segments :
            print("Error: Could not create resampled profile for multi-circuit non-geodesic.")
            return None
            
        profile_r_m_calc = np.concatenate(adaptive_r_segments)
        profile_z_m_calc = np.concatenate(adaptive_z_segments)
        if len(profile_r_m_calc) < 2:
            print("Error: Resampled profile too short for multi-circuit non-geodesic.")
            return None
        # --- End Resampled Profile ---


        # --- Pattern Advancement Logic (Simplified for now) ---
        # This is the net azimuthal shift for the START of the next circuit
        advancement_per_full_circuit_rad = (2 * math.pi / num_target_circuits_for_pattern_closure) * pattern_skip_factor
        # Distribute this advancement over the two turnarounds in a circuit
        phi_span_for_each_turnaround_rad = advancement_per_full_circuit_rad / 2.0
        # Note: A more advanced pattern calculation would determine Delta_Phi_tot from Koussios Ch. 8
        # and the turnaround span would be calculated to achieve this net shift,
        # considering the natural phi sweep of the non-geodesic legs.
        # For now, we assume the turnaround segment itself provides this angular span.

        all_path_segments_data = [] # To store dicts from _generate_non_geodesic_leg and turnarounds
        
        current_overall_phi_rad = 0.0 # Starting phi for the very first leg of the first circuit
        current_sin_alpha_for_next_leg_start = math.sin(math.radians(initial_alpha_at_first_pole_deg))

        for circuit_idx in range(num_circuits_to_generate_for_vis):
            print(f"\nGENERATING NON-GEODESIC CIRCUIT {circuit_idx + 1}")
            
            # Phi at the start of the first leg of this current circuit
            phi_start_of_this_circuit_leg1 = current_overall_phi_rad 

            # Leg 1 (e.g., Forward on profile: Pole A -> Pole B)
            # The profile for RK4 must be in the direction of integration.
            leg1_profile_r = profile_r_m_calc
            leg1_profile_z = profile_z_m_calc
            
            leg1_data = self._generate_non_geodesic_leg(
                leg1_profile_r, leg1_profile_z,
                current_sin_alpha_for_next_leg_start,
                phi_start_of_this_circuit_leg1,
                is_forward_on_profile=True, # Integration direction for RK4 along this profile
                leg_number_info=f"C{circuit_idx+1}-NonGeoLeg1",
                rk4_steps_factor_override=rk4_steps_factor
            )
            if not leg1_data or not leg1_data['phi_rad']:
                print(f"ERROR C{circuit_idx+1}-NonGeoLeg1: Failed.")
                return None
            all_path_segments_data.append({'circuit': circuit_idx, 'segment_type': 'leg1', 'data': leg1_data})
            
            phi_after_leg1 = leg1_data['phi_rad'][-1]
            sin_alpha_after_leg1 = math.sin(leg1_data['alpha_rad'][-1])
            z_at_turnaround1 = leg1_data['z_m'][-1]
            rho_at_turnaround1 = leg1_data['rho_m'][-1]


            # Turnaround 1 (e.g., at Aft Pole)
            turnaround1_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=rho_at_turnaround1, # Turnaround at actual last rho of leg
                z_pole=z_at_turnaround1,
                phi_start=phi_after_leg1,
                fixed_phi_advance_rad=phi_span_for_each_turnaround_rad,
                num_turn_points=max(5, num_points_dome // 10) # Fewer points for turnaround
            )
            if turnaround1_data_points:
                all_path_segments_data.append({'circuit': circuit_idx, 'segment_type': 'turn1', 'data': self._format_turnaround_data(turnaround1_data_points)})
                phi_after_turnaround1 = turnaround1_data_points[-1]['phi']
            else: # Should not happen if num_turn_points > 0
                phi_after_turnaround1 = phi_after_leg1


            # For non-geodesic, alpha at start of next leg is affected by previous leg's end alpha.
            # The turnaround is circumferential (alpha=90). So, the *helical* angle entering the next leg
            # would typically try to match the angle exiting the previous helical leg, unless friction allows more deviation.
            # For simplicity, let's assume the entry angle for leg2 is same as exit of leg1 in magnitude,
            # but the solver will determine its evolution.
            current_sin_alpha_for_next_leg_start = sin_alpha_after_leg1 # sin(alpha) for start of leg 2

            # Leg 2 (e.g., Reverse on profile: Pole B -> Pole A)
            leg2_profile_r = profile_r_m_calc[::-1] # Reverse profile for reverse leg integration
            leg2_profile_z = profile_z_m_calc[::-1]

            leg2_data = self._generate_non_geodesic_leg(
                leg2_profile_r, leg2_profile_z,
                current_sin_alpha_for_next_leg_start, # Start with magnitude of end alpha from leg 1
                phi_after_turnaround1,
                is_forward_on_profile=True, # RK4 integrates forward on the *provided (reversed) profile*
                leg_number_info=f"C{circuit_idx+1}-NonGeoLeg2",
                rk4_steps_factor_override=rk4_steps_factor
            )
            if not leg2_data or not leg2_data['phi_rad']:
                print(f"ERROR C{circuit_idx+1}-NonGeoLeg2: Failed.")
                return None
            all_path_segments_data.append({'circuit': circuit_idx, 'segment_type': 'leg2', 'data': leg2_data})

            phi_after_leg2 = leg2_data['phi_rad'][-1]
            sin_alpha_after_leg2 = math.sin(leg2_data['alpha_rad'][-1])
            z_at_turnaround2 = leg2_data['z_m'][-1]
            rho_at_turnaround2 = leg_data['rho_m'][-1]


            # Turnaround 2 (e.g., at Front Pole)
            turnaround2_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=rho_at_turnaround2,
                z_pole=z_at_turnaround2,
                phi_start=phi_after_leg2,
                fixed_phi_advance_rad=phi_span_for_each_turnaround_rad,
                num_turn_points=max(5, num_points_dome // 20)
            )
            if turnaround2_data_points:
                all_path_segments_data.append({'circuit': circuit_idx, 'segment_type': 'turn2', 'data': self._format_turnaround_data(turnaround2_data_points)})
                current_overall_phi_rad = turnaround2_data_points[-1]['phi'] # This is start for next circuit's leg1
            else:
                current_overall_phi_rad = phi_after_leg2
            
            # The sin_alpha for the start of the *next circuit's first leg*
            current_sin_alpha_for_next_leg_start = sin_alpha_after_leg2


        # --- Consolidate all points from all_path_segments_data ---
        # ... (same consolidation logic as in generate_multi_circuit_geodesic_trajectory to populate
        #      full_path_rho_m, full_path_z_m, etc. and path_circuit_indices)
        full_path_data = {'rho_m': [], 'z_m': [], 'alpha_rad': [], 'phi_rad': [], 'x_m': [], 'y_m': [], 'circuit_idx': [] }
        for segment_info in all_path_segments_data:
            data = segment_info['data']
            num_pts = len(data['rho_m'])
            full_path_data['rho_m'].extend(data['rho_m'])
            full_path_data['z_m'].extend(data['z_m'])
            full_path_data['alpha_rad'].extend(data['alpha_rad'])
            full_path_data['phi_rad'].extend(data['phi_rad'])
            full_path_data['x_m'].extend(data['x_m'])
            full_path_data['y_m'].extend(data['y_m'])
            full_path_data['circuit_idx'].extend([segment_info['circuit']] * num_pts)


        if not full_path_data['rho_m']:
            print("Error: No trajectory points generated for non-geodesic multi-circuit.")
            return None
        
        # ... (Create the final output dictionary similar to generate_multi_circuit_geodesic_trajectory,
        #      but with pattern_type = 'NonGeodesic_MultiCircuit_SimplePattern' and include mu)
        self.alpha_profile_deg = np.array([math.degrees(a) for a in full_path_data['alpha_rad']])
        self.phi_profile_rad = np.array(full_path_data['phi_rad'])
        self.turn_around_angle_rad = self.phi_profile_rad[-1] if len(self.phi_profile_rad) > 0 else 0 # This is total phi accumulated
        
        idx_equator_candidates = np.where(np.abs(np.array(full_path_data['z_m']) - self.vessel.cylinder_mid_z_m) < self.vessel.cylinder_length_m / 2 * 0.95)[0] if self.vessel.cylinder_length_m > 0 else \
                             np.where(np.abs(np.array(full_path_data['rho_m']) - np.max(profile_r_m_calc)) < 1e-3)[0] # Near max radius if no cylinder
        if len(idx_equator_candidates)>0:
            idx_equator = idx_equator_candidates[len(idx_equator_candidates)//2] # A point in cylinder
            self.alpha_eq_deg = self.alpha_profile_deg[idx_equator] if len(self.alpha_profile_deg) > idx_equator else 0
        else:
            self.alpha_eq_deg = 0


        output_path_points = []
        for i in range(len(full_path_data['rho_m'])):
             output_path_points.append({
                'r': full_path_data['rho_m'][i], 'z': full_path_data['z_m'][i],
                'theta': full_path_data['phi_rad'][i],
                'alpha_deg': math.degrees(full_path_data['alpha_rad'][i]),
                'x_cart': full_path_data['x_m'][i], 'y_cart': full_path_data['y_m'][i],
                'circuit': full_path_data['circuit_idx'][i]
            })

        return {
            'path_points': output_path_points,
            'pattern_type': 'NonGeodesic_MultiCircuit_SimplePattern',
            'mu_friction_coefficient_used': self.mu_friction_coefficient,
            'initial_alpha_at_pole_deg': initial_alpha_at_first_pole_deg,
            'total_circuits_generated_for_vis': num_circuits_to_generate_for_vis,
            'num_target_circuits_for_pattern_closure': num_target_circuits_for_pattern_closure,
            'pattern_skip_factor': pattern_skip_factor,
            'advancement_per_full_circuit_deg': math.degrees(advancement_per_full_circuit_rad),
            'phi_span_per_turnaround_deg': math.degrees(phi_span_for_each_turnaround_rad),
            'total_points': len(full_path_data['rho_m']),
            'rho_points_m': np.array(full_path_data['rho_m']),
            'z_points_m': np.array(full_path_data['z_m']),
            'x_points_m': np.array(full_path_data['x_m']),
            'y_points_m': np.array(full_path_data['y_m']),
            'alpha_deg_profile': self.alpha_profile_deg, # overall
            'phi_rad_profile': self.phi_profile_rad,     # overall
            'circuit_indices': np.array(full_path_data['circuit_idx'])
        }

    def _format_turnaround_data(self, turnaround_points_list_of_dicts: List[Dict]) -> Dict[str, List]:
        """Helper to convert list of dicts from turnaround into dict of lists for consolidation."""
        if not turnaround_points_list_of_dicts:
            return {'rho_m': [], 'z_m': [], 'alpha_rad': [], 'phi_rad': [], 'x_m': [], 'y_m': []}
        
        return {
            'rho_m': [p['rho'] for p in turnaround_points_list_of_dicts],
            'z_m': [p['z'] for p in turnaround_points_list_of_dicts],
            'alpha_rad': [p['alpha'] for p in turnaround_points_list_of_dicts],
            'phi_rad': [p['phi'] for p in turnaround_points_list_of_dicts],
            'x_m': [p['x'] for p in turnaround_points_list_of_dicts],
            'y_m': [p['y'] for p in turnaround_points_list_of_dicts],
        }
Key changes and considerations for generate_multi_circuit_non_geodesic_trajectory:

Calls _generate_non_geodesic_leg: This is the core change. It uses the RK4-solved sin_alpha profile for each leg.
initial_sin_alpha_at_leg_start: This is now passed to _generate_non_geodesic_leg. For the very first leg, it's derived from initial_alpha_at_first_pole_deg. For subsequent legs, it uses the sin(alpha) from the end of the previous helical leg. The turnaround segments are assumed to be purely circumferential (α=90 
∘
 , so sinα=1), so the winding angle for the start of the helical part of the next leg should be the same as the end of the helical part of the previous leg.
Pattern Advancement: The advancement_per_full_circuit_rad and phi_span_for_each_turnaround_rad are calculated as placeholders, similar to the geodesic multi-circuit version. True non-geodesic pattern theory would be more complex as the natural sweep of the legs itself depends on mu.
Profile Direction for _solve_non_geodesic_sin_alpha_profile_rk4: When calling _generate_non_geodesic_leg for the "reverse on profile" leg, the profile_r_m_calc and profile_z_m_calc are passed in reversed order. The _solve_non_geodesic_sin_alpha_profile_rk4 needs its is_forward_on_profile argument set to True because the RK4 integrator marches along the provided z array. The "reversal" is handled by the reversed profile arrays.
Consolidation: The all_path_segments_data and final consolidation logic are similar to the geodesic version, ensuring circuit indices are tracked.
Helper _format_turnaround_data: Added to make appending turnaround data cleaner.
This structure allows you to generate multiple non-geodesic circuits with a simplified pattern advancement. The "kinks" (if still present) will most likely stem from the numerical accuracy of the ODE solution or the underlying surface property calculations. The check_path_for_kinks_and_slippage will be essential for diagnosing these.