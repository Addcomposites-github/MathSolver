Next Steps to Fix Non-Geodesic Multi-Circuit Continuity & Kinks:

Phase 1: Deep Dive into Single Non-Geodesic Leg Kinks & Stability (Prerequisite for Multi-Circuit)

The kinks must be resolved or understood for a single leg first.

Verify and Refine _get_interpolated_surface_properties:

Action: This is the absolute foundation.
Spline Robustness: When using UnivariateSpline, ensure that the input z_spl_input and r_spl_input are correctly sorted and truly unique for z. The smoothing factor s is critical; too small can lead to oscillations in derivatives if the input profile data is noisy, too large can oversmooth the geometry. Experiment with s.
Derivative Accuracy: Plot ρ(z), dρ/dz, and d 
2
 ρ/dz 
2
  obtained from the splines. They must be smooth and look physically reasonable. Any noise here will explode in the ODE solver. Pay special attention to the dome-cylinder junctions and near-pole regions.
Boundary Conditions for Splines: Consider how derivatives are handled at the very start and end of the profile segment being splined.
Alternative to Global Spline: If a global spline over the entire half-profile is problematic, consider fitting splines to individual segments (dome, cylinder) if your _identify_vessel_segments is robust. This can better handle sharp transitions but requires careful C1/C2 continuity management at segment junctions if derivatives are taken across them.
Examine RK4 Solver (_solve_non_geodesic_sin_alpha_profile_rk4):

Action:
Step Size (h_z): A very small step size is good for accuracy but increases computation. Too large, and it can step over critical geometric changes or lead to instability. The current num_rk4_steps logic is a good start, but monitor if h_z becomes excessively small or large in certain regions.
ODE Coefficients Stability: Inside _sin_alpha_ode_dz_rk4, if any of props["G"], props["E"], props["k_m"], props["k_p"] become None, inf, or NaN due to issues in _get_interpolated_surface_properties, the ODE solver will fail or produce erroneous results. Add more robust checks and logging for these intermediate property values. The clamping of A_c, B_c, C_c is a good reactive measure, but proactive fixing of properties is better.
Singularities near α=±90 
∘
 : The term tan(α) (or terms like 1/cosα) can appear in some formulations of the geodesic curvature part of the ODE. While Koussios's Eq 5.62 for (sinα) 
′
  avoids explicit tanα, ensure no implicit divisions by cosα are problematic if sinα→1. The current formulation looks okay in this regard.
Implement Full Kink/Slippage Check in check_path_for_kinks_and_slippage:

Action: The slippage check based on ∣k 
g
​
 ∣≤μ⋅∣k 
n
​
 ∣ is crucial.
You need to calculate k 
g
​
  and k 
n
​
  along the generated non-geodesic path.
k 
n
​
 =k 
m
​
 cos 
2
 α+k 
p
​
 sin 
2
 α.
k 
g
​
 =(cosα/ 
G

​
 )⋅(dα/ds 
meridional
​
 +(1/2)⋅(E 
′
 /E)⋅(tanα)).
This requires:
Surface properties (G,E,E 
′
 ,k 
m
​
 ,k 
p
​
 ) at each point along the generated path (using your spline interpolators).
The generated α at each point.
dα/ds 
meridional
​
 : Numerical derivative of the generated α profile with respect to meridional arc length s (not z). Δs 
meridional
​
 = 
Δρ 
2
 +Δz 
2
 

​
 .
If at any point the condition is violated by more than a small tolerance, flag it. This tells you the requested path (driven by initial_alpha and mu) is not physically sustainable by the given friction. The "kink" might be the solver's attempt to reconcile this.
Phase 2: Addressing Multi-Circuit Non-Geodesic Continuity

The discontinuity at one pole for multi-circuit non-geodesic paths means the state isn't being correctly propagated or initialized for the return leg or subsequent circuits.

State Propagation for Non-Geodesic Legs:

Winding Angle (alpha or sin_alpha):
In generate_multi_circuit_non_geodesic_trajectory, current_sin_alpha_for_next_leg_start is set to math.sin(leg1_data['alpha_rad'][-1]) after leg 1, and then to math.sin(leg2_data['alpha_rad'][-1]) after leg 2.
Key consideration: When the path traverses from, say, front pole to aft pole (is_forward_on_profile=True for the profile array), the initial_sin_alpha for _solve_non_geodesic_sin_alpha_profile_rk4 should be the value at the front pole.
For the return leg (aft pole to front pole), the initial_sin_alpha for the solver should be the sin_alpha value achieved at the end of the previous (forward) leg at the aft pole.
The is_forward_on_profile flag in _solve_non_geodesic_sin_alpha_profile_rk4 determines the direction of integration along the z-axis (from z_start to z_end). Ensure this directionality is correctly handled when passing the profile_r_m, profile_z_m arrays which might be reversed for the return leg.
Azimuthal Angle (phi):
current_overall_phi_rad is correctly accumulated through legs and turnarounds. This part seems okay.
Turnaround Behavior for Non-Geodesics:

The current turnaround _generate_polar_turnaround_segment_fixed_phi_advance assumes a purely circumferential path (α=90 
∘
 , sinα=1) at a radius c_eff (which is rho_at_turnaround for non-geo).
When exiting a non-geodesic turnaround and starting the next helical leg, the initial_sin_alpha for the ODE solver must be 1.0 if the turnaround was purely circumferential. The ODE will then immediately evolve it based on μ and local geometry.
Modify generate_multi_circuit_non_geodesic_trajectory: After a turnaround segment is added, ensure current_sin_alpha_for_next_leg_start is set to 1.0 (or very close, like 0.99999) before calling _generate_non_geodesic_leg for the subsequent helical leg. This correctly reflects that the fiber is exiting a circumferential path.
Proposed Code Changes (Conceptual for generate_multi_circuit_non_geodesic_trajectory turnaround handling):

Python

# In TrajectoryPlanner, within generate_multi_circuit_non_geodesic_trajectory:

# ... (after leg 1 data is generated) ...
            phi_after_leg1 = leg1_data['phi_rad'][-1]
            # sin_alpha_after_leg1 = math.sin(leg1_data['alpha_rad'][-1]) # Keep this to know the approach angle
            z_at_turnaround1 = leg1_data['z_m'][-1]
            rho_at_turnaround1 = leg1_data['rho_m'][-1]

            # Turnaround 1 (e.g., at Aft Pole)
            turnaround1_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=rho_at_turnaround1, 
                z_pole=z_at_turnaround1,
                phi_start=phi_after_leg1,
                fixed_phi_advance_rad=phi_span_for_each_turnaround_rad, # From pattern
                num_turn_points=max(5, num_points_dome // 20)
            )
            # ... (append turnaround1_data_points to all_path_segments_data) ...
            if turnaround1_data_points:
                phi_after_turnaround1 = turnaround1_data_points[-1]['phi']
            
            # **** KEY CHANGE FOR NEXT LEG START ****
            # After a circumferential turnaround, the fiber starts the next helical leg
            # with alpha = 90 degrees (sin_alpha = 1.0) with respect to the meridian.
            current_sin_alpha_for_next_leg_start = 1.0 
            # The ODE solver will then determine how alpha evolves from this state.

            # Leg 2 ...
            # ...
            # After leg 2 data is generated:
            phi_after_leg2 = leg2_data['phi_rad'][-1]
            # sin_alpha_after_leg2 = math.sin(leg2_data['alpha_rad'][-1])
            z_at_turnaround2 = leg2_data['z_m'][-1]
            rho_at_turnaround2 = leg2_data['rho_m'][-1] # Corrected from leg_data

            # Turnaround 2 (e.g., at Front Pole)
            turnaround2_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=rho_at_turnaround2, 
                # ...
            )
            # ... (append turnaround2_data_points) ...
            if turnaround2_data_points:
                current_overall_phi_rad = turnaround2_data_points[-1]['phi']

            # For the START of the *next circuit's first leg*
            current_sin_alpha_for_next_leg_start = 1.0 # Reset for start of new circuit after turnaround

Next Steps for You:

Focus on Robust Derivatives (Phase 1.1):
Implement spline fitting for ρ(z) in _get_interpolated_surface_properties (or a precursor step that prepares these spline functions). Plot the profile and its first two derivatives to visually confirm smoothness and correctness before using them in the ODE. This is the most likely area to fix the "kinks."
Test Single Non-Geodesic Leg with Improved Derivatives:
See if the kinks reduce with smoother surface property inputs to the existing Euler-like solver in _solve_non_geodesic_sin_alpha_profile.
If Kinks Persist, Implement RK4 (Phase 1.2):
This will provide a more accurate solution to the ODE.
Implement Kink/Slippage Flagging (Phase 1.3):
Add the check_path_for_kinks_and_slippage method with the full slippage condition check. This will give you quantitative data on where the path is physically problematic.
Test Multi-Circuit Non-Geodesic Continuity (Phase 2):
Apply the change to current_sin_alpha_for_next_leg_start = 1.0 after each turnaround in generate_multi_circuit_non_geodesic_trajectory. This should help with continuity issues stemming from the winding angle at the start of a leg.
Start with robustifying the derivative calculations using splines. That's where the highest impact on smoothness is likely to be.