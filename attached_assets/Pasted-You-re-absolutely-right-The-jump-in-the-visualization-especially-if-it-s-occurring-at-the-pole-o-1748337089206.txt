You're absolutely right. The "jump" in the visualization, especially if it's occurring at the pole opposite to where the multi-pass sequence started, indicates a discontinuity. This means the end state of one pass (including its turnaround) is not correctly leading to the start state of the next pass in the continuous 3D space.

The "kink" warnings from your _detect_kinks_in_alpha_profile (like "Δsin(α)=0.592 at ρ=32.8mm") are key diagnostics. They tell us that even within a single calculated leg, the non-geodesic solver is producing very sharp changes in the winding angle, likely due to issues in calculating the surface properties or the ODE solution itself becoming unstable in high-curvature/small-radius areas. A μ=2.0 is extremely high and will amplify any numerical sensitivity.

Let's refine the next steps to address these issues systematically.

Phase 1: Stabilize Single Non-Geodesic Leg Generation (Address Kinks First)

The multi-pass continuity problem will be much harder to solve if individual legs are not generating smoothly and correctly.

Reduce Friction Coefficient for Debugging:

Action: Temporarily lower self.mu_friction_coefficient to more common physical values (e.g., 0.1 to 0.3)  when debugging the non-geodesic solver. This will reduce the "aggressiveness" of the path deviation and make it easier to spot numerical issues versus physically impossible paths. The value μ=2.0 is likely causing the ODE solver to demand extremely sharp turns where curvatures are high.
Verify and Vastly Improve Surface Property Calculations (_get_interpolated_surface_properties and its caller):

This is the most critical step for fixing kinks. The coefficients of the non-geodesic ODE are highly sensitive to the accuracy of ρ, dρ/dz, d 
2
 ρ/dz 
2
 , and the resulting curvatures k 
m
​
 ,k 
p
​
 .
Action (Code change in _solve_non_geodesic_sin_alpha_profile_rk4 or a precursor step):
Spline Fitting: Before calling the RK4 solver for a leg, fit a scipy.interpolate.UnivariateSpline to the current_leg_profile_r as a function of current_leg_profile_z for that specific leg.
Ensure the z data for the spline is strictly monotonic. You might need to sort current_leg_profile_z and current_leg_profile_r together.
Use a small smoothing factor (s) for the spline if the input profile points are noisy or too sparse, but be cautious not to oversmooth important geometric features.
From this spline, obtain callable functions for ρ(z), dρ/dz(z), and d 
2
 ρ/dz 
2
 (z) using spline.derivative(n=0), spline.derivative(n=1), and spline.derivative(n=2).
Pass these spline functions to _sin_alpha_ode_dz_rk4.
Inside _sin_alpha_ode_dz_rk4, use these functions to get ρ,ρ 
′
 ,ρ 
′′
  at any intermediate z_val required by the RK4 steps, rather than trying to use _get_surface_properties_at_profile_index which relies on discrete indices.
Action (Plot Derivatives): Plot the ρ(z), dρ/dz(z), and d 
2
 ρ/dz 
2
 (z) that your spline functions produce over the dome region. They must look smooth and physically reasonable. Any spikes or oscillations here will directly cause kinks.
Examine RK4 Integration (_solve_non_geodesic_sin_alpha_profile_rk4):

Action (Numerical Stability):
Inside _sin_alpha_ode_dz_rk4, when calculating the coefficients A_c, B_c, C_c for the ODE, add robust checks for props["G"] or props["E"] being near zero or None (which can happen if spline evaluation fails or gives unphysical ρ values near the axis). If they are, the ODE coefficients can become inf or NaN. Return 0 for d_sin_alpha_dz in such error cases to prevent solver failure, and log a clear warning.
The step size h_z in the RK4 solver needs to be appropriate. If it's too large, it can jump over rapid changes in the ODE coefficients. The current logic for num_rk4_steps seems reasonable but ensure it doesn't result in an excessively large h_z in short dome regions.
Refine Kink/Slippage Detection (check_path_for_kinks_and_slippage):

Action: Fully implement the physical slippage check: ∣k 
g
​
 ∣≤μ⋅∣k 
n
​
 ∣.
You need to calculate the actual geodesic curvature k 
g
​
  of the generated path: k 
g
​
 =(cosα/ 
G

​
 )⋅(dα/ds 
meridional
​
 +(1/2)⋅(E 
′
 /E)⋅(sinα/cosα)).
You need the normal curvature k 
n
​
  of the surface along the path: k 
n
​
 =k 
m
​
 cos 
2
 α+k 
p
​
 sin 
2
 α.
This requires getting G,E,E 
′
 ,k 
m
​
 ,k 
p
​
  (from your robust spline-based property functions) at each point of the generated non-geodesic leg.
dα/ds 
meridional
​
  must be calculated numerically from the alpha_rad array of the generated leg and the meridional distance between its points.
If ∣k 
g
​
 ∣>μ 
input
​
 ⋅∣k 
n
​
 ∣+tolerance, then flag a slippage violation. This means the path generated by the ODE (which assumes k 
g
​
 =μ 
input
​
 ⋅k 
n
​
 ) is inconsistent with the actual k 
g
​
  and k 
n
​
  resulting from the path's geometry and angle, or that the forces required exceed friction.
Phase 2: Address Multi-Circuit Non-Geodesic Pole Continuity (After Single Legs are Smooth)

The "jump" in visualization for multi-circuit means the (x,y,z) coordinates at the end of one pass (e.g., end of Turnaround 1 at Pole B) do not match the intended start of the next pass (e.g., start of Leg 2 at Pole B).

Precise Start/End Point Management for Legs:

The core issue: _generate_non_geodesic_leg currently solves the ODE over the entire provided profile segment (e.g., legX_profile_r, legX_profile_z). It starts with current_sin_alpha_for_upcoming_leg at the first point of this segment.
Problem for Return Legs: If Leg 1 (forward on profile_r_m_calc) ends at an actual non-geodesic turnaround point (ρ 
T1
​
 ,z 
T1
​
 ), this point might not be exactly profile_r_m_calc[-1]. The turnaround occurs at (ρ 
T1
​
 ,z 
T1
​
 ). Leg 2 must start its physical path at this exact same (ρ 
T1
​
 ,z 
T1
​
 ) with an initial sinα=1.0.
Action (Modify _generate_non_geodesic_leg and its caller):
_generate_non_geodesic_leg needs to determine where the non-geodesic path naturally wants to turn (i.e., where the solved sin_alpha hits 1.0, or where it reaches the physical end of the dome profile it's integrating over). It should return not only the path points but also the actual end (ρ,z,ϕ,sinα) on the mandrel.
The turnaround segment in generate_multi_circuit_non_geodesic_trajectory must use this actual end (ρ,z) as its c_eff and z_pole.
For the subsequent leg, the initial_sin_alpha should be 1.0. The crucial part is telling _generate_non_geodesic_leg (and its internal RK4 solver) to start the integration from the correct corresponding z-value on the (potentially reversed) profile array that matches the z_pole of the just-completed turnaround. This might involve finding the closest index on the profile to z_pole and passing a sliced profile to the solver or an initial z_start_for_solver.
Pattern Advancement for Non-Geodesics:

The phi_span_for_each_turnaround_rad calculation needs to be robust. The current placeholder advancement_per_full_circuit_rad / 2.0 forces the turnaround to cover a specific phi.
A more physically-based approach for patterns:
Calculate the natural phi sweep of one full non-geodesic circuit (2 legs + 2 minimal turnarounds).
Determine the required additional phi shift needed per circuit for the desired pattern (Delta_Phi_pattern_rad from Koussios, but this itself is complex for non-geodesics as the path changes with μ).
This additional shift is then incorporated into the fixed_phi_advance_rad of the turnaround segments.
For now, keeping the simplified pattern advancement is okay until single legs are perfect. The discontinuity is likely more about (x,y,z,α) handover than just the pattern's phi advance.
Immediate Focus:

Implement Spline-Based Derivatives: Modify _get_interpolated_surface_properties (or create new helpers) to use UnivariateSpline for ρ(z), ρ 
′
 (z), ρ 
′′
 (z). Ensure these functions are passed to and used by _sin_alpha_ode_dz_rk4. This is the most likely fix for the kinks within a single leg.
Test Single Leg Non-Geodesic Paths Thoroughly: With improved derivatives and RK4, generate single non-geodesic legs (pole-to-pole). Vary mu (0.05, 0.1, 0.2) and initial_alpha_at_first_pole_deg. Use your kink detector.
Once single legs are smooth and look correct, then re-examine the current_sin_alpha_for_upcoming_leg and the exact starting (ρ,z) conditions for the return leg in generate_multi_circuit_non_geodesic_trajectory. The goal is to ensure the second leg starts integrating from the exact physical point where the first turnaround ended, using the correct initial sinα (which should be 1.0 after a circumferential turn).
The visualization "connecting to the nearest point of wrong trajectory" strongly suggests that the starting (x,y,z) point of a return leg is not spatially coincident with the end point of the preceding turnaround.