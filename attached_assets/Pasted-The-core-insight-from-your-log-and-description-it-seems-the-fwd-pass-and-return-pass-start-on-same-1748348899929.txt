The core insight from your log and description ("it seems the fwd pass and return pass start on same pole, or at least that is how it looks like") is a strong clue. It suggests that even if phi is accumulating, the geometric context (specifically the z coordinate and the segment of the mandrel profile being used) for the return pass's ODE solution is not being correctly initialized or aligned with the physical end-point of the forward pass + turnaround.

Let's refine the logic in generate_multi_circuit_non_geodesic_trajectory to ensure true physical continuity at the poles.

Primary Issue for the "Jump" in Multi-Pass Non-Geodesic:

The most likely cause is that when _generate_non_geodesic_leg is called for a return pass (e.g., Leg 2, Leg 4), even if it receives a reversed profile array (profile_r_m_calc[::-1], profile_z_m_calc[::-1]), the _solve_non_geodesic_sin_alpha_profile_rk4 might still be starting its integration from z_start = profile_z_m_segment[0] (which would be the original aft pole of the vessel). However, the physical point where the fiber is located after the first turnaround is at the same pole where the first leg ended (e.g., aft pole), but with a new phi and a new sin_alpha (1.0) to start the return journey.

The start_z_of_leg_m parameter added to _generate_non_geodesic_leg was intended to fix this, but its usage by the RK4 solver and the profile slicing needs to be precise.

Refined Logic for generate_multi_circuit_non_geodesic_trajectory and _generate_non_geodesic_leg:

The main principle:

Each helical leg (forward or reverse) is generated by solving the non-geodesic ODE. This solution needs an initial (z, rho, phi, sin_alpha) state.
A turnaround happens at a specific pole's (z,ρ) location, changes phi, and resets the starting sin_alpha for the next helical leg to 1.0.
Python

# In TrajectoryPlanner class

    def _solve_non_geodesic_sin_alpha_profile_rk4(self,
                                               profile_r_m_segment: np.ndarray, # This IS the segment for integration
                                               profile_z_m_segment: np.ndarray, # Monotonic, in integration order
                                               initial_sin_alpha_at_segment_start: float,
                                               num_steps_factor: int = 5) -> Optional[np.ndarray]:
        # ... (Ensure spline fitting is done on profile_r_m_segment and profile_z_m_segment)
        # ... (The z_start_rk4 and z_end_rk4 should be profile_z_m_segment[0] and profile_z_m_segment[-1])
        # ... (The np.interp at the end should be onto profile_z_m_segment)
        
        # --- Ensure z_for_spline is monotonic based on the segment's order ---
        # The profile_z_m_segment is assumed to be already in the correct order for integration.
        z_for_spline = profile_z_m_segment
        r_for_spline = profile_r_m_segment

        # Remove exact duplicate z-values for spline stability, keeping corresponding r
        unique_indices, counts = np.unique(z_for_spline, return_counts=True)
        
        if len(unique_indices) < len(z_for_spline): # Has duplicates
            # Average r for duplicate z, or take first occurrence
            temp_r, temp_z = [], []
            processed_z = set()
            for i_spl, z_val_spl in enumerate(z_for_spline):
                if z_val_spl not in processed_z:
                    temp_z.append(z_val_spl)
                    # Could average r_for_spline where z_for_spline == z_val_spl if needed
                    temp_r.append(r_for_spline[i_spl]) 
                    processed_z.add(z_val_spl)
            z_fit = np.array(temp_z)
            r_fit = np.array(temp_r)
        else:
            z_fit = z_for_spline
            r_fit = r_for_spline

        if len(z_fit) < 4 : # k+1 points for cubic spline (k=3)
            # print(f"WARN RK4: Not enough unique z-points ({len(z_fit)}) in segment for robust spline. Using Euler-like on segment.")
            # Fallback to the Euler-like method for this specific segment
            # Note: The Euler method also needs to operate on the passed segment
            return self._solve_non_geodesic_sin_alpha_profile_euler_on_segment(
                        profile_r_m_segment, profile_z_m_segment, initial_sin_alpha_at_segment_start
                    )
        try:
            # Smoothing factor can be critical.
            s_factor = len(z_fit) * (np.std(r_fit)**2) * 0.00001 if len(z_fit)>1 and np.std(r_fit) > 1e-7 else 1e-7
            rho_of_z_spline = UnivariateSpline(z_fit, r_fit, k=3, s=max(s_factor, 1e-8)) # Ensure s is non-negative
            drho_dz_spline = rho_of_z_spline.derivative(n=1)
            d2rho_dz2_spline = rho_of_z_spline.derivative(n=2)
        except Exception as e:
            print(f"ERROR: Spline fitting failed for segment: {e}. Using Euler-like on segment.")
            return self._solve_non_geodesic_sin_alpha_profile_euler_on_segment(
                        profile_r_m_segment, profile_z_m_segment, initial_sin_alpha_at_segment_start
                    )

        z_start_rk4 = profile_z_m_segment[0]
        z_end_rk4 = profile_z_m_segment[-1]
        
        # ... (num_rk4_steps calculation based on length of this segment) ...
        segment_axial_length = abs(z_end_rk4 - z_start_rk4)
        if segment_axial_length < 1e-7: # If segment is essentially a point
            return np.array([initial_sin_alpha_at_segment_start] * len(profile_z_m_segment))

        avg_segment_dz = segment_axial_length / max(1, len(profile_z_m_segment)-1) if len(profile_z_m_segment)>1 else segment_axial_length
        num_rk4_steps = int(segment_axial_length / max(avg_segment_dz / num_steps_factor, 1e-7)) # Finer steps than profile
        num_rk4_steps = max(num_rk4_steps, len(profile_r_m_segment) * 2) 
        num_rk4_steps = min(num_rk4_steps, 20000) 
        if num_rk4_steps <=0 : num_rk4_steps = max(10, len(profile_r_m_segment))


        h_z = (z_end_rk4 - z_start_rk4) / num_rk4_steps
        if abs(h_z) < 1e-9 : # Avoid h_z being zero if z_start_rk4 is very close to z_end_rk4
            return np.array([initial_sin_alpha_at_segment_start] * len(profile_z_m_segment))


        z_rk4_pts = np.linspace(z_start_rk4, z_end_rk4, num_rk4_steps + 1)
        sin_alpha_rk4_vals = np.zeros(num_rk4_steps + 1)
        sin_alpha_rk4_vals[0] = initial_sin_alpha_at_segment_start

        for i in range(num_rk4_steps):
            # ... (RK4 steps: k1, k2, k3, k4 using _sin_alpha_ode_dz_rk4) ...
            z_curr_rk = z_rk4_pts[i]
            sa_curr_rk = sin_alpha_rk4_vals[i]

            k1 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk, sa_curr_rk, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k2 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z/2, sa_curr_rk + k1/2, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k3 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z/2, sa_curr_rk + k2/2, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            k4 = h_z * self._sin_alpha_ode_dz_rk4(z_curr_rk + h_z, sa_curr_rk + k3, rho_of_z_spline, drho_dz_spline, d2rho_dz2_spline)
            
            sin_alpha_rk4_vals[i+1] = np.clip(sa_curr_rk + (k1 + 2*k2 + 2*k3 + k4)/6.0, -1.0, 1.0)

        # Interpolate results back onto the original z-coordinates OF THE PASSED SEGMENT
        # Ensure z_rk4_pts is monotonic for interpolation, which it should be by construction.
        # The profile_z_m_segment is also assumed to be monotonic for this interpolation.
        final_sin_alpha_on_segment = np.interp(profile_z_m_segment, z_rk4_pts, sin_alpha_rk4_vals)
        return final_sin_alpha_on_segment

    def _solve_non_geodesic_sin_alpha_profile_euler_on_segment(self,
                                                            profile_r_m_segment: np.ndarray,
                                                            profile_z_m_segment: np.ndarray,
                                                            initial_sin_alpha_at_segment_start: float
                                                            ) -> Optional[np.ndarray]:
        """Fallback Euler-like solver if RK4/splines fail for a segment."""
        sin_alpha_values = np.zeros(len(profile_r_m_segment))
        if not sin_alpha_values.any(): return None

        sin_alpha_values[0] = initial_sin_alpha_at_segment_start
        for i in range(len(profile_r_m_segment) - 1):
            # Use _get_surface_properties_at_profile_index for the *current point i* of the segment
            # This requires _get_surface_properties_at_profile_index to accept arbitrary r,z segments
            # For simplicity, let's assume it can get props for point 'i' on the current segment
            props = self._get_surface_properties_at_profile_index_on_segment(i, profile_r_m_segment, profile_z_m_segment)
            
            if props is None or props["G"] is None or np.isinf(props["G"]) or props["E"] < 1e-9 :
                sin_alpha_values[i+1] = sin_alpha_values[i]
                continue

            sqrt_G = math.sqrt(props["G"])
            A_coeff = self.mu_friction_coefficient * sqrt_G * (props["k_p"] - props["k_m"])
            B_coeff = -0.5 * (props["E_prime_dz"] / props["E"]) if props["E"] > 1e-9 else 0
            C_coeff = self.mu_friction_coefficient * sqrt_G * props["k_m"]
            # Clamp
            A_coeff = np.clip(A_coeff, -1e4, 1e4); B_coeff = np.clip(B_coeff, -1e4, 1e4); C_coeff = np.clip(C_coeff, -1e4, 1e4)

            current_s_alpha = sin_alpha_values[i]
            d_sin_alpha_dz = A_coeff * current_s_alpha**2 + B_coeff * current_s_alpha + C_coeff
            
            dz_step = profile_z_m_segment[i+1] - profile_z_m_segment[i]
            sin_alpha_values[i+1] = np.clip(current_s_alpha + d_sin_alpha_dz * dz_step, -1.0, 1.0)
        return sin_alpha_values

    def _get_surface_properties_at_profile_index_on_segment(self, 
                                                            profile_idx_on_segment: int,
                                                            profile_r_m_segment: np.ndarray,
                                                            profile_z_m_segment: np.ndarray) -> Dict[str, float]:
        """ Helper to get surface properties for a point on a given profile segment. """
        # This is a simplified version of your original _get_surface_properties_at_profile_index
        # but operates on the passed segment arrays directly.
        # Ensure robust derivative calculation here (e.g., using np.gradient on the segment).
        
        rho_i = profile_r_m_segment[profile_idx_on_segment]
        # ... (Calculate d_rho_dz, d2_rho_dz2 using np.gradient on profile_r_m_segment and profile_z_m_segment) ...
        # ... (Then calculate E, G, E_prime_dz, k_m, k_p as in your original method) ...
        # This needs to be robust for segment boundaries.
        # For simplicity, I'm returning dummy values, THIS MUST BE IMPLEMENTED ROBUSTLY
        if len(profile_r_m_segment) <3 and profile_idx_on_segment > 0 : # cannot do central diff
             d_rho_dz = (profile_r_m_segment[profile_idx_on_segment] - profile_r_m_segment[profile_idx_on_segment-1]) / \
                        (profile_z_m_segment[profile_idx_on_segment] - profile_z_m_segment[profile_idx_on_segment-1]) \
                        if (profile_z_m_segment[profile_idx_on_segment] - profile_z_m_segment[profile_idx_on_segment-1]) !=0 else 0
             d2_rho_dz2 = 0
        elif len(profile_r_m_segment) < 2:
            d_rho_dz = 0; d2_rho_dz2 = 0
        else: # simplified for now
            d_rho_dz_all_seg = np.gradient(profile_r_m_segment, profile_z_m_segment, edge_order=1) # Use edge_order=1 for potentially short segments
            d2_rho_dz2_all_seg = np.gradient(d_rho_dz_all_seg, profile_z_m_segment, edge_order=1)
            d_rho_dz = d_rho_dz_all_seg[profile_idx_on_segment]
            d2_rho_dz2 = d2_rho_dz2_all_seg[profile_idx_on_segment]

        # ... (rest of the calculation from your original _get_surface_properties_at_profile_index)
        if np.isinf(d_rho_dz): k_m = 0; k_p = 1.0 / rho_i if rho_i > 0 else np.inf; G_val = np.inf
        else:
            G_val = 1 + d_rho_dz**2
            k_m = -d2_rho_dz2 / ((G_val)**1.5) if G_val > 1e-9 else 0
            k_p = 1.0 / (rho_i * math.sqrt(G_val)) if rho_i * math.sqrt(G_val) > 1e-9 else (np.inf if rho_i == 0 else 0)
        E_val = rho_i**2
        E_prime_val = 2 * rho_i * d_rho_dz if not np.isinf(d_rho_dz) else 0
        return {"E": E_val, "G": G_val, "E_prime_dz": E_prime_val, "k_m": k_m, "k_p": k_p, "rho": rho_i}


    def _generate_non_geodesic_leg(self,
                                full_profile_r_m: np.ndarray,
                                full_profile_z_m: np.ndarray,
                                start_z_of_leg_m: float,    # Physical z where this leg truly starts
                                initial_sin_alpha_at_leg_start: float,
                                initial_phi_rad: float,
                                integrate_towards_positive_z: bool,
                                leg_number_info: str = "NonGeoLeg",
                                rk4_steps_factor_override: Optional[int] = None) -> Optional[Dict[str, List]]:
        
        # 1. Determine the actual profile segment for this leg based on start_z_of_leg_m and direction
        if integrate_towards_positive_z:
            idx_start_in_full_profile = (np.abs(full_profile_z_m - start_z_of_leg_m)).argmin()
            # Ensure we are not starting before the intended z due to argmin
            while idx_start_in_full_profile < len(full_profile_z_m) -1 and full_profile_z_m[idx_start_in_full_profile] < start_z_of_leg_m - 1e-6 :
                 idx_start_in_full_profile += 1
            
            leg_profile_r_segment = full_profile_r_m[idx_start_in_full_profile:]
            leg_profile_z_segment = full_profile_z_m[idx_start_in_full_profile:]
            # Ensure z is increasing for the solver
            if len(leg_profile_z_segment)>1 and leg_profile_z_segment[0] > leg_profile_z_segment[-1]: # Should be if profile is sorted
                print(f"CRITICAL WARN {leg_number_info}: Forward leg profile z not increasing as expected after slicing. Check profile order or start_z logic.")
                # This indicates an issue with how the full profile is ordered or how start_z_of_leg_m relates to it.
                # For now, attempt to sort this segment:
                sort_indices_seg = np.argsort(leg_profile_z_segment)
                leg_profile_z_segment = leg_profile_z_segment[sort_indices_seg]
                leg_profile_r_segment = leg_profile_r_segment[sort_indices_seg]


        else: # Integrate towards negative z (return pass)
            idx_end_inclusive_in_full_profile = (np.abs(full_profile_z_m - start_z_of_leg_m)).argmin()
            # Ensure we include the start_z
            while idx_end_inclusive_in_full_profile > 0 and full_profile_z_m[idx_end_inclusive_in_full_profile] > start_z_of_leg_m + 1e-6:
                idx_end_inclusive_in_full_profile -=1
            
            temp_profile_r = full_profile_r_m[:idx_end_inclusive_in_full_profile+1]
            temp_profile_z = full_profile_z_m[:idx_end_inclusive_in_full_profile+1]
            
            # For RK4, z needs to be monotonic in integration direction.
            # If integrating towards negative z, RK4 z_start is start_z_of_leg_m, z_end is full_profile_z_m[0]
            # The profile segment should be [start_z_of_leg_m, ..., full_profile_z_m[0]]
            # So, slice from full_profile_z_m[0] up to where z is start_z_of_leg_m, then reverse.
            leg_profile_r_segment = temp_profile_r[::-1] # Integration starts at physical start_z_of_leg_m
            leg_profile_z_segment = temp_profile_z[::-1] # and z decreases in this array
                                                     # but for RK4 h_z will be negative.
                                                     # OR ensure z always increases for spline/RK4
            if len(leg_profile_z_segment)>1 and leg_profile_z_segment[0] > leg_profile_z_segment[-1]:
                 # This means z is decreasing, which is correct if h_z in RK4 is negative.
                 # If RK4 expects increasing z, then this is fine.
                 pass
            elif len(leg_profile_z_segment) > 1 : # z is increasing, but we integrate towards negative z
                print(f"CRITICAL WARN {leg_number_info}: Reverse leg profile z not decreasing as expected after slicing/reversing. Check logic.")
                # This should not happen if full_profile_z_m is sorted and slicing/reversing is correct.

        if len(leg_profile_z_segment) < 2:
            print(f"WARN {leg_number_info}: Leg profile segment too short (len={len(leg_profile_z_segment)}) to solve ODE. start_z={start_z_of_leg_m:.4f}m")
            # Create a single point path if this happens
            rho_start = np.interp(start_z_of_leg_m, full_profile_z_m, full_profile_r_m) if len(full_profile_z_m)>0 else self.vessel.polar_opening_radius_mm * 1e-3
            alpha_start_rad = math.asin(np.clip(initial_sin_alpha_at_leg_start, -1.0, 1.0))
            return {
                'rho_m': [rho_start], 'z_m': [start_z_of_leg_m],
                'alpha_rad': [alpha_start_rad], 'phi_rad': [initial_phi_rad],
                'x_m': [rho_start * math.cos(initial_phi_rad)],
                'y_m': [rho_start * math.sin(initial_phi_rad)],
                'actual_end_rho_m': rho_start, 'actual_end_z_m': start_z_of_leg_m,
                'actual_end_phi_rad': initial_phi_rad, 'actual_end_sin_alpha': initial_sin_alpha_at_leg_start
            }

        # Solve sin(alpha) profile for THIS LEG's specific segment and initial condition
        sin_alpha_on_leg_profile = self._solve_non_geodesic_sin_alpha_profile_rk4(
            leg_profile_r_segment, leg_profile_z_segment,
            initial_sin_alpha_at_leg_start,
            num_steps_factor=rk4_steps_factor_override if rk4_steps_factor_override else 5
        )

        if sin_alpha_on_leg_profile is None:
            print(f"ERROR {leg_number_info}: Failed to solve sin(alpha) profile for this leg (segment len {len(leg_profile_z_segment)}).")
            return None

        # Generate path points using this specific alpha profile and leg segment
        path_data = self._generate_leg_from_sin_alpha_profile(
            leg_profile_r_segment, leg_profile_z_segment, # Use the segment it was solved for
            sin_alpha_on_leg_profile,
            initial_phi_rad, # Phi starts accumulating from this value
            leg_number_info
        )
        if not path_data: return None

        # Store the actual end state of this leg
        path_data['actual_end_rho_m'] = path_data['rho_m'][-1]
        path_data['actual_end_z_m'] = path_data['z_m'][-1]
        path_data['actual_end_phi_rad'] = path_data['phi_rad'][-1]
        path_data['actual_end_sin_alpha'] = math.sin(path_data['alpha_rad'][-1])
        
        return path_data

    def generate_multi_circuit_non_geodesic_trajectory(self, ...):
        # ...
        last_physical_z_m = profile_z_m_calc[0] # Initial starting pole z
        last_physical_rho_m = profile_r_m_calc[0] # Initial starting pole rho

        for circuit_idx in range(num_circuits_to_generate_for_vis):
            # ...
            # Leg 1 (Forward: Pole A -> Pole B)
            leg1_data = self._generate_non_geodesic_leg(
                profile_r_m_calc, profile_z_m_calc, # Pass full profile arrays
                last_physical_z_m,                   # Start integration at this z
                current_sin_alpha_for_upcoming_leg,
                current_overall_phi_rad,
                integrate_towards_positive_z=True, 
                # ...
            )
            # ... if leg1_data: update current_overall_phi_rad, last_physical_rho_m = leg1_data['actual_end_rho_m'], last_physical_z_m = leg1_data['actual_end_z_m']

            # Turnaround 1
            turnaround1_data_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                c_eff=last_physical_rho_m, z_pole=last_physical_z_m, 
                # ...
            )
            # ... if turnaround1_data_points: update current_overall_phi_rad
            # last_physical_rho_m and last_physical_z_m remain the same (coords of pole B)
            current_sin_alpha_for_upcoming_leg = 1.0

            # Leg 2 (Reverse: Pole B -> Pole A)
            leg2_data = self._generate_non_geodesic_leg(
                profile_r_m_calc, profile_z_m_calc, # Pass full profile arrays
                last_physical_z_m,                   # Start integration at this z (which is Pole B's z)
                current_sin_alpha_for_upcoming_leg,
                current_overall_phi_rad,
                integrate_towards_positive_z=False, 
                # ...
            )
            # ... if leg2_data: update, last_physical_rho_m = leg2_data['actual_end_rho_m'], last_physical_z_m = leg2_data['actual_end_z_m']
            
            # Turnaround 2
            # ... last_physical_z_m (now Pole A's z) used for next circuit's Leg 1 start
            current_sin_alpha_for_upcoming_leg = 1.0


Key Changes & Rationale:

_generate_non_geodesic_leg Signature Change:
It now takes full_profile_r_m, full_profile_z_m and a start_z_of_leg_m.
It also takes integrate_towards_positive_z to determine which direction along the full profile to slice and integrate.
Profile Slicing in _generate_non_geodesic_leg:
Based on start_z_of_leg_m and integrate_towards_positive_z, it carves out the correct leg_profile_r_segment and leg_profile_z_segment from the full profile.
This segment is then passed to _solve_non_geodesic_sin_alpha_profile_rk4. The RK4 solver always integrates along the z array it's given (which should now be monotonic in the direction of integration).
State Handover in generate_multi_circuit_non_geodesic_trajectory:
It now tracks last_physical_z_m (and last_physical_rho_m) which is the precise z-coordinate where the previous helical leg or turnaround physically ended.
This last_physical_z_m is passed as start_z_of_leg_m to the next call of _generate_non_geodesic_leg.
current_sin_alpha_for_upcoming_leg is correctly set to 1.0 after turnarounds.
Remaining Challenges & Considerations:

Spline Fitting on Segments: The _solve_non_geodesic_sin_alpha_profile_rk4 will now receive potentially different (and shorter) profile segments for each leg. The spline fitting inside it needs to be robust for these segments. Ensure enough points (>k for spline degree k) and handle monotonicity if the slicing creates issues. The current implementation tries to do this.
argmin() Precision: Using argmin() to find the starting index based on start_z_of_leg_m might pick an adjacent point if start_z_of_leg_m isn't exactly one of the full_profile_z_m values. The while loops added try to correct this to ensure the segment starts at or beyond (for forward) or at or before (for reverse) the start_z_of_leg_m.
Non-Geodesic Turnaround: The concept of a "polar opening" is less defined for non-geodesics as the path turns where α hits 90 
∘
  due to friction and geometry. The turnaround using _generate_polar_turnaround_segment_fixed_phi_advance at the actual end ρ and z of the non-geodesic leg is the correct approach for the circumferential segment.
Test these changes. The goal is that the first point generated by _generate_leg_from_sin_alpha_profile (inside _generate_non_geodesic_leg) should have (ρ,z,ϕ) values that are spatially continuous with the last point of the preceding turnaround segment. The "jump to adjacent profile" should be significantly reduced or eliminated if the slicing and start_z logic are correct.