Okay, this is a solid plan. Refactoring `TrajectoryPlanner` to have a clear structure with primary options for "single circuit" and "full coverage," while consolidating the core physics, will significantly improve its robustness and usability.

Let's draft the details and provide the necessary code structure.

**I. Refined `TrajectoryPlanner` Structure and Main Methods**

We'll aim for the following primary public method:

* `generate_trajectory(self, pattern_name: str, coverage_option: str, user_circuits: int = 1)`

And internal engines/solvers:

* `_engine_geodesic_spiral(self, coverage_option: str, user_circuits: int, ...)`
* `_engine_non_geodesic_spiral(self, coverage_option: str, user_circuits: int, ...)` (marked experimental)
* `_engine_standard_helical_polar(self, coverage_option: str, user_circuits: int, ...)` (if this distinct pattern is kept)
* `_solve_ode_non_geodesic_segment(...)` (your current `_solve_non_geodesic_sin_alpha_phi_segment_ode`)
* `_solve_ode_geodesic_segment(...)` (new, for robust geodesic integration)

**II. Core Mathematical Logic Review & Implementation**

**A. Geodesic Paths (`_engine_geodesic_spiral` and `_solve_ode_geodesic_segment`)**

1.  **Clairaut's Constant ($C$):**
    * `self.clairauts_constant_for_path_m` is correctly initialized by `_initialize_clairauts_constant`. This $C = \rho_{cyl} \sin(\alpha_{cyl})$ or $C = \text{effective\_polar\_opening\_radius\_m}$. This math is sound.
2.  **Path Equation:**
    * On a surface of revolution, for a geodesic, $\rho \sin(\alpha) = C$, where $\alpha$ is the angle with the meridian.
    * The change in azimuthal angle $\phi$ with respect to the meridional arc length $s_m$ is $d\phi/ds_m = \tan(\alpha) / \rho$.
    * Alternatively, $d\phi/dz = (d\phi/ds_m) \cdot (ds_m/dz) = (\tan(\alpha) / \rho) \sqrt{1 + (d\rho/dz)^2}$.
3.  **Turnaround at $\rho = C$:**
    * As $\rho \to C^+$, $\sin(\alpha) \to 1$, so $\alpha \to \pi/2$.
    * $\tan(\alpha) \to \infty$. The formulation $d\phi/dz$ becomes singular.
    * **Solution:** Koussios (and others) suggest switching the integration variable near the turnaround or using specific series expansions. A common numerical approach is:
        * Integrate $d\phi/dz$ from one pole until $\rho$ is very close to $C$ (e.g., $\rho = C + \epsilon$).
        * At this point, the path is almost purely circumferential. Perform a small segment of pure circumferential winding ($dz=0, d\rho=0$) for a calculated $\Delta\phi_{turnaround}$ (this $\Delta\phi_{turnaround}$ incorporates the pattern advancement).
        * Then, switch to integrating $d\phi/dz$ (or $d\phi/d(-\text{z})$) for the return path, starting with $\alpha \approx \pi/2$.
    * The `_solve_ode_geodesic_segment` needs to handle this robustly.

**B. Non-Geodesic Paths (`_engine_non_geodesic_spiral` and `_solve_ode_non_geodesic_segment`)**

1.  **Koussios's DE:**
    * Your `_solve_non_geodesic_sin_alpha_phi_segment_ode` using `ode_system_non_geodesic` implements:
        $d(\sin\alpha)/dz = (A \sin^2\alpha + B \sin\alpha + C) \cdot (ds_m/dz)$
        $d\phi/dz = (\tan\alpha / \rho) \cdot (ds_m/dz)$
    * The coefficients $A, B, C$ depend on $\mu, k_m, k_p, E, G, E'$. Your `_get_surface_properties_for_ode` calculates these. **This math needs to be double-checked for sign conventions and correct derivative calculations from splines.** (Koussios, `book1.pdf` Ch 6, Eq. 6.20 or `book2.pdf` Ch 5, Eq. 5.62).
2.  **Turnaround:**
    * A non-geodesic path does not necessarily have $\alpha=\pi/2$ at turnaround. The turnaround radius and angle are determined by the solution of the DE with friction.
    * The current model (meridional pass + discrete $\phi$ shift at the pole) is a simplification. The "sharp turn" is a visual result of this. As discussed, this is acceptable if the DE is solved correctly for the meridional parts and the $\phi$ shift achieves coverage.
3.  **ODE Solver Failures:** This is the primary current blocker. Robust error checking and termination are key.

**C. Pattern Advancement (Both Geodesic and Non-Geodesic)**

1.  **`phi_advancement_rad_per_pass`:**
    * The calculation `(self.dry_roving_width_m / math.cos(target_alpha_cyl_rad_effective)) / self.R_cyl_m` is the angular width of one band projected onto the cylinder, perpendicular to the winding direction. This is correct for $\Delta\phi_{band}$.
    * This $\Delta\phi_{band}$ is the amount the *pattern* should shift after one band has been laid and you want to lay the next one adjacently.
    * If applied after *each pole-to-pole pass*, then one full fiber circuit (A->B->A, 2 passes) will result in a total pattern shift of $2 \times \Delta\phi_{band}$. This should correctly place subsequent circuits.

**D. "Single Circuit" vs. "Full Coverage"**

* **Single Circuit:** Defined as two pole-to-pole passes (e.g., PoleFront -> PoleAft, then PoleAft -> PoleFront). This forms one complete loop of the fiber.
* **Full Coverage:** The number of pole-to-pole passes required to cover $2\pi$ radians of the vessel's circumference.
    * `passes_for_one_coverage_layer = ceil(2 * pi / phi_advancement_rad_per_pass)`.
    * Ensure this is even if you want full A->B->A circuits.

---

**III. Proposed Code Structure and Modifications**

**1. Main Dispatcher `generate_trajectory`**

```python
# In TrajectoryPlanner class (trajectories.py)

class TrajectoryPlanner:
    # ... (Keep __init__, log_message, _initialize_final_summary, _return_trajectory_data,
    #      _calculate_effective_polar_opening_radius_m, _initialize_clairauts_constant,
    #      _get_surface_properties_for_ode, _solve_ode_non_geodesic_segment,
    #      profile interpolation helpers like get_rho_interpolator, etc.)

    # Add a new robust geodesic segment solver
    def _solve_ode_geodesic_segment(self, z_eval_points: np.ndarray,
                                    initial_phi: float,
                                    clairaut_C: float,
                                    profile_r_m_full_sorted: np.ndarray,
                                    profile_z_m_full_sorted: np.ndarray,
                                    # pass_idx: int # for point metadata
                                   ) -> Optional[Dict]: # Returns {'solution': solve_ivp_result, 'final_sin_alpha': float}
        """
        Solves for phi for a geodesic segment given z_eval_points.
        ODE: d(phi)/dz = (C / (rho * sqrt(rho^2 - C^2))) * sqrt(1 + (drho/dz)^2)
                      = (tan(alpha) / rho) * ds_m_dz
        Handles turnaround proximity by adjusting integration or returning specific status.
        """
        self.log_message(f"Solving geodesic segment: z_eval_points from {z_eval_points[0]:.4f} to {z_eval_points[-1]:.4f}, C={clairaut_C:.4f}", level="DEBUG")

        if len(profile_z_m_full_sorted) < 4 or len(np.unique(profile_z_m_full_sorted)) < 4 :
            self.log_message("Profile too short for spline interpolation in geodesic segment.", level="ERROR")
            return None

        # Ensure z unique for spline, use original indices for r
        unique_z, unique_idx = np.unique(profile_z_m_full_sorted, return_index=True)
        rho_of_z_spl = UnivariateSpline(unique_z, profile_r_m_full_sorted[unique_idx], s=1e-7, k=3, ext='raise') # s=0 for exact
        drho_dz_of_z_spl = rho_of_z_spl.derivative(1)

        min_profile_z, max_profile_z = profile_z_m_full_sorted[0], profile_z_m_full_sorted[-1]
        
        # Clip z_eval_points to be strictly within the interpolator's domain to avoid extrapolation issues
        # especially if z_start/z_end are exactly the profile limits.
        epsilon_z = 1e-6 * (max_profile_z - min_profile_z)
        z_eval_points_clipped = np.clip(z_eval_points, min_profile_z + epsilon_z, max_profile_z - epsilon_z)
        # Ensure start and end points are exactly what was requested if they were within original domain
        z_eval_points_clipped[0] = z_eval_points[0]
        z_eval_points_clipped[-1] = z_eval_points[-1]


        def geodesic_ode_system(z_val, y_phi_ode, C_val, rho_spl, drho_dz_spl_func):
            rho_at_z = float(rho_spl(z_val))
            
            # Turnaround handling: if rho is very close to C, dphi/dz can be huge.
            # This region requires special handling if using this dphi/dz form.
            if rho_at_z <= C_val + 1e-7: # At or below turnaround radius (problematic for this ODE form)
                # This indicates the path should be purely circumferential or integration var change needed.
                # For solve_ivp, returning a massive slope might make it take tiny steps and fail.
                # A better approach is to stop before this point and handle turnaround explicitly.
                # For now, if we hit this, it's an issue with z_eval_points going too far.
                self.log_message(f"Geodesic ODE: rho ({rho_at_z:.5f}) too close to C ({C_val:.5f}) at z={z_val:.4f}. Turnaround instability.", level="WARNING")
                return [np.nan] # Signal solver to stop or indicate error

            try:
                # Ensure argument to asin is valid
                arg_asin = C_val / rho_at_z
                if not (-1.0 <= arg_asin <= 1.0):
                    self.log_message(f"Geodesic ODE: Invalid arg for asin ({arg_asin:.5f}) at rho={rho_at_z:.5f}, C={C_val:.5f}, z={z_val:.4f}",level="WARNING")
                    return [np.nan] # Invalid path
                
                alpha_val = math.asin(arg_asin) # Angle with meridian
            except ValueError:
                 self.log_message(f"Geodesic ODE: ValueError for asin at rho={rho_at_z:.5f}, C={C_val:.5f}, z={z_val:.4f}",level="WARNING")
                 return [np.nan]


            if abs(math.cos(alpha_val)) < 1e-9: # alpha is pi/2 (turnaround)
                # This implies dphi/dz is infinite. The solver will struggle.
                # This means z should not be changing here; phi should be.
                # This state should ideally be the *end* of a z-varying segment.
                self.log_message(f"Geodesic ODE: At turnaround (alpha=pi/2) at z={z_val:.4f}, rho={rho_at_z:.4f}", level="DEBUG")
                return [1e9 if z_eval_points[-1] > z_eval_points[0] else -1e9] # Large dphi/dz

            drho_dz_at_z = float(drho_dz_spl_func(z_val))
            ds_m_dz = math.sqrt(1.0 + drho_dz_at_z**2)
            
            dphi_dz = (math.tan(alpha_val) / rho_at_z) * ds_m_dz
            if np.isnan(dphi_dz):
                self.log_message(f"Geodesic ODE: dphi_dz is NaN at z={z_val:.4f}", level="WARNING")
                return [np.nan]
            return [dphi_dz]

        sol_span = [z_eval_points_clipped[0], z_eval_points_clipped[-1]]
        try:
            solution = solve_ivp(
                geodesic_ode_system, sol_span, [initial_phi],
                args=(clairaut_C, rho_of_z_spl, drho_dz_of_z_spl),
                dense_output=True, method='RK45', # LSODA might be better if stiff
                atol=1e-7, rtol=1e-5,
                events=None # Could add event for rho approaching C
            )
        except Exception as e:
            self.log_message(f"Exception in geodesic solve_ivp: {e}", level="ERROR")
            return None

        if not solution.success:
            self.log_message(f"Geodesic ODE solution failed for z_span {sol_span}: {solution.message}", level="WARNING")
            # Try to return partial if some solution exists
            if hasattr(solution, 'sol') and solution.sol is not None:
                 pass # will use below
            else:
                return None
        
        # Calculate final sin_alpha at the actual end point of evaluation
        rho_at_z_end = float(rho_of_z_spl(z_eval_points_clipped[-1]))
        final_sin_alpha = 0.0
        if rho_at_z_end > 1e-9 and rho_at_z_end >= clairaut_C: # Ensure rho >= C
            final_sin_alpha = np.clip(clairaut_C / rho_at_z_end, -1.0, 1.0)
        elif rho_at_z_end < clairaut_C: # Path went into forbidden zone
             self.log_message(f"Warning: Geodesic path ended with rho ({rho_at_z_end:.4f}) < C ({clairaut_C:.4f}). Setting sin_alpha to 1.0.", level="WARNING")
             final_sin_alpha = 1.0 # Effectively at turnaround
        else: # rho_at_z_end is zero
            final_sin_alpha = 1.0 # Assume turnaround at pole if C is also ~0

        return {'solution': solution, 'final_sin_alpha': final_sin_alpha, 'rho_of_z_spl': rho_of_z_spl}


    def _engine_continuous_spiral(self, # Renamed from _generate_continuous_spiral_engine
                                  is_geodesic_mode: bool,
                                  coverage_option: str,
                                  user_defined_circuits: int,
                                  points_per_meridian_pass_segment: int = 100,
                                  # ... (other relevant params from your current generate_physical_continuous_spiral)
                                 ) -> Dict:
        """
        Core engine for generating continuous spiral patterns (geodesic or non-geodesic).
        Handles 'single_circuit' and 'full_coverage' options.
        """
        # --- Initial Setup (largely from your existing generate_physical_continuous_spiral) ---
        self.log_message(f"Starting {'Geodesic' if is_geodesic_mode else 'Non-Geodesic (Experimental)'} Continuous Spiral Engine.", level="INFO")
        self._prepare_profile_data() # Ensure self.profile_r_m_sorted, self.profile_z_m_sorted, self.R_cyl_m etc. are set

        target_alpha_cyl_rad_effective = None
        if self.target_cylinder_angle_deg is not None:
            target_alpha_cyl_rad_effective = math.radians(self.target_cylinder_angle_deg)
        elif is_geodesic_mode and self.clairauts_constant_for_path_m is not None and self.R_cyl_m > 1e-6:
            # If no target angle, but C is known (e.g. from polar opening), calculate implied alpha_cyl
            val = self.clairauts_constant_for_path_m / self.R_cyl_m
            if -1.0 <= val <= 1.0:
                target_alpha_cyl_rad_effective = math.asin(val)
            else: # C > R_cyl, path doesn't reach cylinder as a helix
                target_alpha_cyl_rad_effective = math.pi / 2 # Hoop like
                self.log_message(f"Warning: Clairaut's const {self.clairauts_constant_for_path_m:.4f} > R_cyl {self.R_cyl_m:.4f}. Effective alpha_cyl is ~90deg.", level="WARNING")
        else: # Fallback if nothing else
            target_alpha_cyl_rad_effective = math.radians(30.0) # Default if truly nothing set
            self.log_message(f"Warning: No target_cylinder_angle and cannot derive from C. Defaulting to {math.degrees(target_alpha_cyl_rad_effective):.1f} deg on cylinder for B_eff calc.", level="WARNING")

        if is_geodesic_mode and self.clairauts_constant_for_path_m is None:
            self.log_message("CRITICAL: Clairaut's constant not set for Geodesic mode. Aborting.", level="ERROR")
            return self._empty_trajectory_data(status="CONFIG_ERROR", message="Clairaut's constant missing for Geodesic mode.")

        pattern_name_log = f"{'Geodesic' if is_geodesic_mode else 'NonGeodesic_Experimental'} Spiral ({coverage_option})"
        final_summary = self._initialize_final_summary(pattern_type=pattern_name_log)
        full_path_points = []

        # Initial conditions for the very first segment (current_z, current_rho, current_sin_alpha, current_phi_rad)
        # ... (Use logic from your L2600-L2618 in generate_physical_continuous_spiral for initialization) ...
        # This part is crucial and needs to be robust
        current_z = self.profile_z_m_sorted[0]
        current_rho = self.rho_interp_spl(current_z) if hasattr(self, 'rho_interp_spl') else self.profile_r_m_sorted[0]


        if is_geodesic_mode:
            # For geodesic, initial sin_alpha is defined by C and current_rho
            if current_rho < self.clairauts_constant_for_path_m - 1e-7: # Starting in impossible region
                 self.log_message(f"ERROR: Initial rho {current_rho:.4f} for geodesic is less than C {self.clairauts_constant_for_path_m:.4f}. Cannot start path.", level="ERROR")
                 return self._empty_trajectory_data(status="GEOMETRY_ERROR", message="Initial rho < C for geodesic.")
            current_sin_alpha = np.clip(self.clairauts_constant_for_path_m / current_rho if current_rho > 1e-9 else 1.0, -1.0, 1.0)
        else: # Non-geodesic (copied from your existing logic, review carefully)
            if self.R_cyl_m > 1e-9 and abs(current_rho - self.R_cyl_m) < 1e-3: # Starting on cylinder
                 current_sin_alpha = math.sin(target_alpha_cyl_rad_effective) if target_alpha_cyl_rad_effective is not None else math.sin(math.radians(30.0))
            elif self.effective_polar_opening_radius_m is not None and current_rho < self.effective_polar_opening_radius_m * 1.1:
                current_sin_alpha = math.sin(math.radians(0.1)) # Very meridional start at pole
            else: # General case on dome, estimate from effective C
                eff_C = self.R_cyl_m * math.sin(target_alpha_cyl_rad_effective) if self.R_cyl_m > 1e-9 and target_alpha_cyl_rad_effective is not None else self.effective_polar_opening_radius_m
                if eff_C is not None and current_rho > 1e-9:
                    current_sin_alpha = np.clip(eff_C / current_rho, -1.0, 1.0)
                else:
                    current_sin_alpha = math.sin(math.radians(0.1)) # Fallback
        current_phi_rad = 0.0

        # Add initial point
        if not np.isnan(current_sin_alpha):
             alpha_rad_init = math.asin(current_sin_alpha)
             full_path_points.append({
                'x_m': current_rho * math.cos(current_phi_rad), 'y_m': current_rho * math.sin(current_phi_rad),
                'z_m': current_z, 'r_m': current_rho,
                'alpha_meridian_rad': alpha_rad_init, 'phi_rad': current_phi_rad, 'pass_idx': 0
             })
        else:
            self.log_message("ERROR: Initial sin_alpha is NaN. Cannot start path.", level="ERROR")
            return self._empty_trajectory_data(status="INIT_ERROR", message="Initial sin_alpha NaN.")

        # --- Phi Advancement Calculation ---
        phi_advancement_rad_per_pass = 0.05 # Default
        if self.R_cyl_m > 1e-6 and target_alpha_cyl_rad_effective is not None and \
           abs(math.cos(target_alpha_cyl_rad_effective)) > 1e-9: # Avoid division by zero if alpha_cyl is 90 deg
            phi_advancement_rad_per_pass = (self.dry_roving_width_m / math.cos(target_alpha_cyl_rad_effective)) / self.R_cyl_m
        
        self.log_message(f"DEBUG: Calculated phi_advancement_per_pole_pass_rad={phi_advancement_rad_per_pass:.4f} rad ({math.degrees(phi_advancement_rad_per_pass):.2f} deg)")

        if abs(phi_advancement_rad_per_pass) < 1e-7 : # Check if advancement is too small
            self.log_message("WARNING: Phi advancement per pass is near zero.", level="WARNING")
            if coverage_option == 'full_coverage':
                 final_summary['status'] = "ZERO_ADVANCEMENT_ERROR"
                 final_summary['message'] = "Cannot achieve full coverage with (near) zero phi advancement."
                 return self._return_trajectory_data(full_path_points, final_summary)
                 
        # --- Determine Number of Passes ---
        actual_num_passes_to_run = 0
        if coverage_option == 'full_coverage':
            if abs(phi_advancement_rad_per_pass) > 1e-7:
                passes_for_one_coverage_layer = math.ceil((2 * math.pi) / abs(phi_advancement_rad_per_pass))
                if passes_for_one_coverage_layer % 2 != 0:
                    passes_for_one_coverage_layer += 1
                actual_num_passes_to_run = passes_for_one_coverage_layer
                self.log_message(f"INFO: Coverage: 'full_coverage'. Calculated {actual_num_passes_to_run} pole-to-pole passes.")
            else: # Should have been caught, safeguard
                actual_num_passes_to_run = 2
                self.log_message("WARNING: Full coverage with zero advancement. Running 2 passes.", level="WARNING")
        elif coverage_option == 'single_circuit':
            actual_num_passes_to_run = 2 # Pole A -> Pole B -> Pole A
            self.log_message(f"INFO: Coverage: 'single_circuit'. Running 2 pole-to-pole passes.")
        else: # Assumed 'user_defined_circuits'
            actual_num_passes_to_run = user_defined_circuits * 2
            self.log_message(f"INFO: Coverage: 'user_defined'. Running {actual_num_passes_to_run} passes for {user_defined_circuits} circuits.")

        if actual_num_passes_to_run == 0 and coverage_option != 'full_coverage': # Full coverage might be 0 if adv is huge
            self.log_message("Warning: Number of passes to run is zero. No trajectory will be generated.", level="WARNING")

        # --- Main Pass Loop ---
        for pass_idx in range(actual_num_passes_to_run):
            is_forward_pass = (pass_idx % 2 == 0)
            # Ensure z_start and z_end for the pass are on the actual profile points
            pass_start_z = self.profile_z_m_sorted[0] if is_forward_pass else self.profile_z_m_sorted[-1]
            pass_end_z = self.profile_z_m_sorted[-1] if is_forward_pass else self.profile_z_m_sorted[0]

            # Ensure z_eval_points are distinct and cover the range.
            # For geodesic, special handling at turnaround (rho=C) is needed.
            # The ODE form dphi/dz is ill-suited when dz -> 0 (i.e., alpha -> pi/2).
            
            # Create z_eval_points for the current segment
            # For geodesic, we might need to stop just short of rho=C if using dphi/dz
            z_eval_points_pass = np.linspace(pass_start_z, pass_end_z, points_per_meridian_pass_segment)
            if len(z_eval_points_pass) < 2: continue

            initial_phi_for_pass = current_phi_rad # Phi from end of previous pass + advancement
            initial_sin_alpha_for_pass = current_sin_alpha

            self.log_message(f"Pass {pass_idx + 1}/{actual_num_passes_to_run} ({'Fwd' if is_forward_pass else 'Rev'}): Start z={pass_start_z:.4f}, End z={pass_end_z:.4f}, Init sinα={initial_sin_alpha_for_pass:.4f}, Init Φ={math.degrees(initial_phi_for_pass):.2f}°", level="INFO")

            segment_points_this_pass = []
            pass_successful = False
            final_sin_alpha_this_pass = initial_sin_alpha_for_pass
            final_phi_this_pass = initial_phi_for_pass

            if is_geodesic_mode:
                # Prepare z_eval_points carefully for geodesic turnaround
                # If current_sin_alpha is already ~1.0, and we are at a pole, we need to turn.
                # This means a segment of pure phi rotation.
                # For now, using the _solve_ode_geodesic_segment which uses d(phi)/dz.
                # It needs to handle rho approaching C.
                
                # Determine actual z-span for integration, avoiding rho < C
                # This is complex; _solve_ode_geodesic_segment should internally manage it.
                # It should integrate up to where rho ~ C, then the turnaround logic applies.
                
                # A simplified geodesic turnaround for now:
                # If sin_alpha is ~1.0 (at turnaround radius C), next segment is mainly phi shift
                if abs(current_sin_alpha - 1.0) < 1e-4: # At turnaround point
                    self.log_message(f"Pass {pass_idx+1}: Geodesic turnaround (sin_alpha ~ 1). Applying phi advancement as turn.",level="DEBUG")
                    # No meridional movement, phi changes by advancement
                    # This is an oversimplification. A real geodesic turn has some dZ.
                    # The phi advancement is for pattern, not part of single fiber path physics here.
                    # The path itself is circumferential.
                    
                    # We are AT the turnaround radius. The "pass" is the circumferential part.
                    # The length of this circumferential part is the pattern advancement.
                    # For "single circuit", this advancement is still needed between legs.

                    # For this simplified turnaround:
                    # Create a few points representing the circumferential shift
                    # This is NOT how a single geodesic path turns, but how a pattern advances AT turnaround.
                    # A single geodesic becomes circumferential at rho=C.
                    # The phi_advancement_rad_per_pass is for the *pattern*.
                    # The current "pass" becomes a circumferential segment.
                    # Let's assume phi_advancement_rad_per_pass is the turn angle.
                    
                    rho_turn = self.clairauts_constant_for_path_m
                    num_turn_points = max(2, points_per_meridian_pass_segment // 10)
                    phi_turn_increment = phi_advancement_rad_per_pass / (num_turn_points -1 if num_turn_points > 1 else 1)
                    
                    # Z remains constant (at the pole where rho=C for this pass direction)
                    # Need to know which z corresponds to rho=C for this pass
                    # This requires finding z where rho_of_z_spl(z) == C.
                    # For simplicity, take z_start of this pass if it corresponds to the turnaround.
                    # This is not robust.
                    z_at_turn = pass_start_z # This is an approximation

                    # Points for the "turn"
                    for k_turn in range(num_turn_points):
                        phi_p_turn = initial_phi_for_pass + k_turn * phi_turn_increment
                        segment_points_this_pass.append({
                             'x_m': rho_turn * math.cos(phi_p_turn), 'y_m': rho_turn * math.sin(phi_p_turn),
                             'z_m': z_at_turn, 'r_m': rho_turn,
                             'alpha_meridian_rad': math.pi/2, 'phi_rad': phi_p_turn, 'pass_idx': pass_idx + 1
                        })
                    pass_successful = True
                    final_sin_alpha_this_pass = 1.0 # Remains at turnaround
                    final_phi_this_pass = initial_phi_for_pass + phi_advancement_rad_per_pass
                    # For the *next* pass, phi should be final_phi_this_pass (no double advancement)
                    # And the next pass will start with sin_alpha=1.0, moving in opposite z.
                    # The global current_phi_rad below will handle advancement for next *meridional* segment.

                else: # Regular meridional geodesic segment
                    geo_solution_info = self._solve_ode_geodesic_segment(
                        z_eval_points=z_eval_points_pass,
                        initial_phi=initial_phi_for_pass,
                        clairaut_C=self.clairauts_constant_for_path_m,
                        profile_r_m_full_sorted=self.profile_r_m_sorted,
                        profile_z_m_full_sorted=self.profile_z_m_sorted,
                        # pass_idx=pass_idx
                    )
                    if geo_solution_info and geo_solution_info['solution'] and geo_solution_info['solution'].success:
                        solution_obj = geo_solution_info['solution']
                        rho_of_z_spl_pass = geo_solution_info['rho_of_z_spl']
                        phi_values_ode_pass = solution_obj.sol(z_eval_points_pass)[0]
                        
                        for i in range(len(z_eval_points_pass)):
                            z_p = z_eval_points_pass[i]
                            rho_p = float(rho_of_z_spl_pass(z_p))
                            phi_p = phi_values_ode_pass[i]
                            sin_alpha_p_val = 0.0
                            if rho_p > 1e-9 and self.clairauts_constant_for_path_m is not None:
                                sin_alpha_p_val = np.clip(self.clairauts_constant_for_path_m / rho_p, -1.0, 1.0)
                            
                            # Stop if path goes to invalid region (rho < C for geodesic)
                            if self.clairauts_constant_for_path_m is not None and rho_p < self.clairauts_constant_for_path_m - 1e-6:
                                self.log_message(f"Geodesic path for pass {pass_idx+1} went below C (rho={rho_p:.4f}, C={self.clairauts_constant_for_path_m:.4f}) at z={z_p:.4f}. Truncating pass.", level="WARNING")
                                break # Truncate this pass
                            
                            segment_points_this_pass.append({
                                'x_m': rho_p * math.cos(phi_p), 'y_m': rho_p * math.sin(phi_p),
                                'z_m': z_p, 'r_m': rho_p,
                                'alpha_meridian_rad': math.asin(sin_alpha_p_val), 'phi_rad': phi_p, 'pass_idx': pass_idx + 1
                            })
                        if segment_points_this_pass: # If any points were added
                            pass_successful = True
                            final_sin_alpha_this_pass = geo_solution_info['final_sin_alpha']
                            final_phi_this_pass = segment_points_this_pass[-1]['phi_rad']
                        else: # No points added, implies immediate failure or empty z_eval
                            pass_successful = False
                    else:
                        pass_successful = False

            else: # --- NON-GEODESIC ---
                segment_solution_obj = self._solve_ode_non_geodesic_segment( # was _solve_non_geodesic_sin_alpha_phi_segment_ode
                    z_eval_points=z_eval_points_pass,
                    initial_conditions=[initial_sin_alpha_for_pass, initial_phi_for_pass],
                    profile_r_m_sorted_full=self.profile_r_m_sorted, # Pass full sorted profiles
                    profile_z_m_sorted_full=self.profile_z_m_sorted,
                    mu=self.mu_friction_coefficient,
                    target_sin_alpha_on_cylinder=math.sin(target_alpha_cyl_rad_effective) if target_alpha_cyl_rad_effective is not None else None
                )

                if segment_solution_obj and segment_solution_obj.success:
                    # The solution is for points in z_eval_points_pass
                    sin_alpha_ode_pass = segment_solution_obj.sol(z_eval_points_pass)[0]
                    phi_ode_pass = segment_solution_obj.sol(z_eval_points_pass)[1]

                    for i in range(len(z_eval_points_pass)):
                        z_p = z_eval_points_pass[i]
                        # Use the general rho_interp_spl which should be defined from self.profile_..._sorted
                        rho_p = float(self.rho_interp_spl(z_p)) if hasattr(self, 'rho_interp_spl') else np.interp(z_p, self.profile_z_m_sorted, self.profile_r_m_sorted)
                        sin_alpha_p = sin_alpha_ode_pass[i]
                        alpha_p = math.asin(np.clip(sin_alpha_p, -1.0, 1.0))
                        phi_p = phi_ode_pass[i]
                        segment_points_this_pass.append({
                            'x_m': rho_p * math.cos(phi_p), 'y_m': rho_p * math.sin(phi_p),
                            'z_m': z_p, 'r_m': rho_p,
                            'alpha_meridian_rad': alpha_p, 'phi_rad': phi_p, 'pass_idx': pass_idx + 1
                        })
                    if segment_points_this_pass:
                        pass_successful = True
                        final_sin_alpha_this_pass = sin_alpha_ode_pass[-1]
                        final_phi_this_pass = phi_ode_pass[-1]
                    else: # No points added
                        pass_successful = False
                else: # ODE solution object is None or not successful
                    pass_successful = False


            if not pass_successful:
                self.log_message(f"ERROR: {'Geodesic' if is_geodesic_mode else 'Non-Geodesic'} segment generation failed for pass {pass_idx + 1}. Aborting.", level="ERROR")
                final_summary['status'] = "SEGMENT_GENERATION_FAILURE"
                final_summary['error_message'] = f"Path segment failed on pass {pass_idx + 1}."
                break # Exit the pass loop

            # Add points from this pass (skip first point if not the very first point overall to avoid duplicates)
            start_idx_storage_pass = 0
            if len(full_path_points) > 0 and segment_points_this_pass: # If not the very first point of trajectory
                 # Check if the first point of this segment is same as last point of overall path
                last_overall_pt = full_path_points[-1]
                first_segment_pt = segment_points_this_pass[0]
                if abs(last_overall_pt['z_m'] - first_segment_pt['z_m']) < 1e-5 and \
                   abs(last_overall_pt['phi_rad'] - first_segment_pt['phi_rad']) < 1e-5 :
                    start_idx_storage_pass = 1
            
            full_path_points.extend(segment_points_this_pass[start_idx_storage_pass:])
            
            # Update for next pass's start
            current_sin_alpha = final_sin_alpha_this_pass
            # The phi at the end of the current pass's meridional sweep
            current_phi_rad_pass_end = final_phi_this_pass 
            
            # Apply advancement for the STARTING phi of the NEXT pass
            current_phi_rad = current_phi_rad_pass_end + phi_advancement_rad_per_pass
            
            self.log_message(f"DEBUG: Pass {pass_idx+1} completed. End Z={segment_points_this_pass[-1]['z_m']:.3f}, End sinα={current_sin_alpha:.4f}, End Φ_pass={math.degrees(current_phi_rad_pass_end):.1f}° -> Advancing global Start Φ for next pass to {math.degrees(current_phi_rad):.1f}°", level="DEBUG")

        # --- End of Pass Loop ---
        
        # Finalize summary, calculate total phi rotation, etc.
        # ... (from your existing generate_physical_continuous_spiral) ...
        if full_path_points:
            final_summary['total_phi_rotation_deg'] = math.degrees(full_path_points[-1]['phi_rad'] - full_path_points[0]['phi_rad'])
            final_summary['actual_passes_completed'] = pass_idx + 1 if 'pass_idx' in locals() and pass_successful else pass_idx if 'pass_idx' in locals() else 0
        
        if final_summary['status'] == "OK" and not full_path_points:
            final_summary['status'] = "NO_POINTS_GENERATED"
            final_summary['message'] = "No trajectory points were generated."
            
        return self._return_trajectory_data(full_path_points, final_summary)


    def generate_trajectory(self, pattern_name: str, 
                            coverage_option: str, # 'single_circuit', 'full_coverage', 'user_defined'
                            user_circuits: int = 1, # Used if coverage_option is 'user_defined'
                            points_per_segment: int = 100 # Renamed for clarity
                           ) -> Dict:
        """
        Main public method to generate trajectories.
        """
        self.log_message(f"Trajectory request: Pattern='{pattern_name}', Coverage='{coverage_option}', UserCircuits='{user_circuits}'", level="INFO")

        if pattern_name == "Geodesic Spiral":
            return self._engine_continuous_spiral(
                is_geodesic_mode=True,
                coverage_option=coverage_option,
                user_defined_circuits=user_circuits,
                points_per_meridian_pass_segment=points_per_segment
            )
        elif pattern_name == "Non-Geodesic Spiral (Experimental)":
            if self.mu_friction_coefficient == 0:
                self.log_message("Warning: Non-Geodesic mode selected, but μ=0. Path will be effectively geodesic.", level="WARNING")
            return self._engine_continuous_spiral(
                is_geodesic_mode=False, # Non-Geodesic
                coverage_option=coverage_option,
                user_defined_circuits=user_circuits,
                points_per_meridian_pass_segment=points_per_segment
            )
        elif pattern_name == "Standard Helical-Polar":
            # Ensure generate_standard_helical_polar_pattern also adheres to coverage_option
            return self.generate_standard_helical_polar_pattern(
                num_circuits_input=user_circuits, # Or map coverage_option to its needs
                coverage_option_ Strada=coverage_option, # Pass it along
                num_points_dome_segment=points_per_segment, # Adapt parameters
                num_points_cyl_segment=points_per_segment
            )
        # elif pattern_name == "Kinematic Spiral": # If you keep a purely kinematic one
            # return self.generate_kinematic_spiral(...)
        else:
            self.log_message(f"Error: Unknown pattern name '{pattern_name}'", level="ERROR")
            return self._empty_trajectory_data(status="INVALID_PATTERN_NAME", message=f"Unknown pattern name: {pattern_name}")

    def _prepare_profile_data(self):
        """Helper to ensure sorted profile data and interpolators are ready."""
        if not hasattr(self, 'profile_z_m_sorted') or \
           not hasattr(self, 'profile_r_m_sorted') or \
           not hasattr(self, 'rho_interp_spl') or \
           not hasattr(self, 'drho_dz_interp_spl'):

            if self.vessel.profile_points is None or \
               'r_inner_mm' not in self.vessel.profile_points or \
               'z_mm' not in self.vessel.profile_points:
                self.log_message("Vessel profile not generated. Attempting to generate.", level="WARNING")
                self.vessel.generate_profile()
                if self.vessel.profile_points is None: # Still None
                    self.log_message("CRITICAL: Vessel profile is missing.", level="ERROR")
                    raise ValueError("Vessel profile is missing in TrajectoryPlanner.")

            _profile_r_m = np.array(self.vessel.profile_points['r_inner_mm']) * 1e-3
            _profile_z_m = np.array(self.vessel.profile_points['z_mm']) * 1e-3
            
            sort_indices = np.argsort(_profile_z_m)
            self.profile_z_m_sorted = _profile_z_m[sort_indices]
            self.profile_r_m_sorted = _profile_r_m[sort_indices]

            self.R_cyl_m = self.vessel.get_cylindrical_radius_m() # Ensure this method exists in VesselGeometry
            if self.R_cyl_m is None and self.vessel.is_cylindrical: # Fallback if method not there
                self.R_cyl_m = self.vessel.inner_radius_mm * 1e-3 if self.vessel.inner_radius_mm is not None else 0.0
            elif self.R_cyl_m is None:
                self.R_cyl_m = np.max(self.profile_r_m_sorted) if len(self.profile_r_m_sorted) > 0 else 0.0 # Approx

            # Create splines for rho(z) and drho/dz(z) for internal use by ODE solvers
            unique_z, unique_idx = np.unique(self.profile_z_m_sorted, return_index=True)
            if len(unique_z) < 4:
                 self.log_message("Profile too short for global spline init. ODE solvers will create local splines.", level="WARNING")
                 # ODE solvers will need to create their own from full profile passed to them.
                 self.rho_interp_spl = lambda z_val: np.interp(z_val, self.profile_z_m_sorted, self.profile_r_m_sorted) # Fallback linear interp
                 self.drho_dz_interp_spl = None # Cannot easily create derivative for linear interp
            else:
                self.rho_interp_spl = UnivariateSpline(unique_z, self.profile_r_m_sorted[unique_idx], s=1e-7, k=3, ext='raise')
                self.drho_dz_interp_spl = self.rho_interp_spl.derivative(1)


    # --- Deprecate or Remove these older methods ---
    # generate_geodesic_trajectory (L998 in your file)
    # generate_non_geodesic_trajectory (L1750)
    # generate_continuous_helical_non_geodesic (L2450 - was kinematic)
    # _solve_non_geodesic_sin_alpha_profile (L1200 - Euler based)

    # Keep and ensure generate_standard_helical_polar_pattern (L2038) also uses
    # the 'coverage_option' and robust segment generation.
    # Its math for helical on cylinder and geodesic on dome is generally sound but needs
    # robust segment integration and C1 continuity if possible.
```

**IV. Key Changes and Math Review in `_engine_continuous_spiral` and Helpers:**

1.  **Unified Engine `_engine_continuous_spiral`:**
    * Takes `is_geodesic_mode` boolean.
    * Implements `coverage_option` logic for `actual_num_passes_to_run`.
    * Manages the main loop for passes, continuity of `current_sin_alpha` and `current_phi_rad` (with advancement).
    * Calls either `_solve_ode_geodesic_segment` or `_solve_ode_non_geodesic_segment`.
    * **Crucially, robustly breaks the loop on segment generation failure.**

2.  **New `_solve_ode_geodesic_segment`:**
    * This function encapsulates the geodesic integration $d\phi/dz = (\tan\alpha/\rho) ds_m/dz$.
    * $\alpha = \arcsin(C/\rho)$.
    * **Math Correctness:** The core equation is correct. The main challenge is numerical stability when $\rho \to C$ (turnaround, $\alpha \to \pi/2$, $\tan\alpha \to \infty$).
    * **Turnaround Handling (Simplified in sketch):** The provided sketch for `_solve_ode_geodesic_segment` uses the $d\phi/dz$ form. This *will* struggle at $\rho=C$. A more robust implementation would:
        * Integrate $d\phi/dz$ until $\rho$ is very close to $C$ (e.g., $\sin\alpha = 0.9999$).
        * Calculate the remaining $\Delta z$ to reach the $z$ coordinate where $\rho=C$ (if not already there).
        * The path becomes circumferential here ($\alpha = \pi/2$). $dz=0, d\rho=0$.
        * The "pass" along the meridian ends here. The `phi_advancement_rad_per_pass` is then added to `current_phi_rad` *conceptually at this turnaround point* before the next meridional pass begins (in the reverse $z$ direction, starting with $\sin\alpha \approx 1.0$).
        * The `generate_physical_continuous_spiral`'s `if abs(current_sin_alpha - 1.0) < 1e-4:` block was an attempt at this discrete turnaround. This logic needs to be clean: either the ODE solver handles the approach to turnaround and stops, or this explicit circumferential segment is used.

3.  **`_solve_ode_non_geodesic_segment` (Your existing `_solve_non_geodesic_sin_alpha_phi_segment_ode`):**
    * **Math Correctness:** The Koussios DE system and coefficients $A,B,C$ from your code need to be meticulously verified against the source literature for signs and terms (especially derivatives from splines $E' = d(\rho^2)/ds_m = 2\rho (d\rho/ds_m)$ and curvatures $k_m, k_p$). This is the most complex mathematical part.
    * Ensure `ds_m_dz = math.sqrt(1.0 + drho_dz_val_at_z**2)` is correct; if $z$ is the independent variable, $ds_m = \sqrt{dz^2 + d\rho^2} = dz \sqrt{1 + (d\rho/dz)^2}$. So $ds_m/dz = \sqrt{1 + (d\rho/dz)^2}$. This looks correct.

4.  **Helper `_prepare_profile_data()`:** Added to centralize sorting of profile points and creation of global interpolators if desired, reducing redundant calculations in each pass.

**V. `generate_standard_helical_polar_pattern`**
* This seems to implement a common [helical-dome, polar opening, dome-helical] pattern.
* **Math Review:**
    * Cylinder: Helical path with constant $\alpha_{cyl}$. Correct.
    * Dome: Geodesic path from cylinder junction to polar opening, using $C = R_{cyl} \sin\alpha_{cyl}$. Correct.
    * `_generate_dome_segment_geodesic` (called by it) seems to use the $d\phi/dz$ integration. It needs the same robustness for turnaround ($\rho \to C$) as discussed for `_solve_ode_geodesic_segment`.
    * `_generate_cylinder_segment_helical` is straightforward.
    * Pattern advancement `phi_increment_per_circuit`: calculated based on effective band width on cylinder and number of circuits for coverage. This is a sound approach for pattern control.
* **Recommendation:**
    * Refine `_generate_dome_segment_geodesic` to handle the $\rho \to C$ turnaround robustly (perhaps by stopping integration just before $\rho=C$ and noting that $\alpha=90^\circ$ there).
    * Adapt it to fit the `coverage_option: 'single_circuit' / 'full_coverage'` paradigm. "Single circuit" would be one full set of [cyl-dome-turn-dome-cyl]. "Full coverage" would use `num_polar_circuits_for_coverage`.

This refactoring provides a clearer structure. The immediate next step for you would be:
1.  Implement the robust ODE failure handling (breaking the loop) in your current `generate_physical_continuous_spiral` for the non-geodesic mode. This should fix the 300mm "step length" issue and give you a continuous (though perhaps short, if other passes fail) path.
2.  Then, structure the `generate_trajectory` dispatcher and the `_engine_continuous_spiral` method.
3.  Focus on making the **geodesic mode** of `_engine_continuous_spiral` (using a new, robust `_solve_ode_geodesic_segment` or by adapting its logic directly) work perfectly for "single circuit" and "full coverage". This will build confidence as geodesics are simpler.
4.  Revisit and debug the non-geodesic engine with the improved structure.