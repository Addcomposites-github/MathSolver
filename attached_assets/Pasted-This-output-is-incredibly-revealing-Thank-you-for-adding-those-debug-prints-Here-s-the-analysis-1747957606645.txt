This output is incredibly revealing! Thank you for adding those debug prints.

Here's the analysis of your new output:

1.  **`DEBUG geometry.py, generate_profile(): self.profile_points JUST ASSIGNED.`**
    * This section appears **twice**. This means `VesselGeometry.generate_profile()` is being called twice before `TrajectoryPlanner` even starts its main work, or there are two `VesselGeometry` instances being created and profiled.
    * In both instances, the output shows:
        * `Type: <class 'dict'>`
        * `Keys: ['r_inner', 'z', 'r_outer', 'dome_height']`
        * `Key 'r_inner' type: <class 'numpy.ndarray'>, Length (if applicable): 102`
    * This **confirms** that your `VesselGeometry.generate_profile()` method *is* correctly creating the `self.profile_points` dictionary with the `'r_inner'` key, and `'r_inner'` is a NumPy array of length 102. This part of the code seems to be working as intended each time it's called.

2.  **`DEBUG trajectories.py: Entering TrajectoryPlanner.__init__`**
    * **`Vessel dome_type: Elliptical`** - Confirms the dome type being used for this run.
    * **`Vessel initial profile_points: {'r_inner': array(...), 'z': array(...), ...}`**
        * This shows that when the `TrajectoryPlanner` is initialized, the `vessel_geometry` object it receives *already has* `profile_points` populated. This is because `generate_profile()` was called at least once before this point (as seen from the "JUST ASSIGNED" messages). The data looks like a complete profile (102 points, starting and ending at rho=0, with a cylinder in between).
    * **`DEBUG trajectories.py: After potential generate_profile call in TrajectoryPlanner init:`**
        * **`self.vessel.profile_points type: <class 'dict'>`**
        * **`Keys in self.vessel.profile_points: ['r_inner', 'z', 'r_outer', 'dome_height']`**
        * **`'r_inner' key FOUND. Length: 102`**
        These lines again confirm that *within the `TrajectoryPlanner.__init__` method*, right before the call to `self._calculate_effective_polar_opening()`, the `self.vessel.profile_points` dictionary is correctly structured and contains the `'r_inner'` key.

3.  **`TrajectoryPlanner init: About to call _calculate_effective_polar_opening()`**
    * This is your print statement, and it's reached *after* all the checks have confirmed `self.vessel.profile_points['r_inner']` exists and is populated.

**Conclusion from the Debug Output:**

The `KeyError: 'r_inner'` is **not** due to `self.profile_points` being `None`, nor is it due to `'r_inner'` being initially missing from the dictionary when `_calculate_effective_polar_opening()` (which calls `_get_slope_dz_drho_at_rho()`) is invoked from `TrajectoryPlanner.__init__`. The dictionary is correctly populated at that stage.

This means the error is almost certainly happening *inside* `_get_slope_dz_drho_at_rho()` for a reason other than the key being absent at the *start* of that method, or there's a very subtle issue.

**Possible Remaining Causes for `KeyError` inside `_get_slope_dz_drho_at_rho` despite earlier checks:**

1.  **Reassignment/Modification of `self.vessel.profile_points`:** Is there any chance that `self.vessel.profile_points` is being reassigned or modified to a different dictionary (one without `'r_inner'`) *within* `_calculate_effective_polar_opening()` *before* it calls `_get_slope_dz_drho_at_rho()`? This seems unlikely given the typical flow.
2.  **The `self` object in `_get_slope_dz_drho_at_rho` is not the `self` of the `TrajectoryPlanner` instance we are tracking.** This could happen in very complex scenarios with decorators, metaclasses, or incorrect binding, but is highly unlikely for standard class methods.
3.  **The traceback is misleading, or the error isn't exactly `KeyError: 'r_inner'` from that line:** While less likely, sometimes error messages can be slightly misattributed in complex call stacks or if an intermediate operation transforms the error.

**Crucial Next Step:**

We *must* see the output of the debug prints that were added **inside `_get_slope_dz_drho_at_rho()`** as per my *previous* message (the one before this current one). Specifically these lines, right at the beginning of `_get_slope_dz_drho_at_rho`:

```python
    def _get_slope_dz_drho_at_rho(self, rho_target_m: float) -> float:
        # ***** THIS IS THE MOST IMPORTANT DEBUG OUTPUT NOW *****
        print(f"\nDEBUG trajectories.py: --- INSIDE _get_slope_dz_drho_at_rho ---")
        print(f"  rho_target_m for slope calculation: {rho_target_m}")
        print(f"  Type of self.vessel.profile_points at this point: {type(self.vessel.profile_points)}")
        if isinstance(self.vessel.profile_points, dict):
            print(f"  Keys in self.vessel.profile_points at this point: {list(self.vessel.profile_points.keys())}")
            if 'r_inner' not in self.vessel.profile_points:
                print("  CRITICAL ERROR _get_slope: 'r_inner' IS MISSING when _get_slope_dz_drho_at_rho is entered!")
            else:
                print(f"  _get_slope: 'r_inner' IS PRESENT. Length: {len(self.vessel.profile_points['r_inner'])}")
        else:
            print(f"  CRITICAL ERROR _get_slope: self.vessel.profile_points is NOT a dict here! It is: {self.vessel.profile_points}")
        # **********************************************************

        try:
            rho_profile_m = self.vessel.profile_points['r_inner'] * 1e-3 # Error line
            # ...
```

If these prints show that `'r_inner'` is missing *at this stage*, then the problem is a very subtle modification of `self.vessel.profile_points` between the end of `TrajectoryPlanner.__init__`'s checks and the entry into `_get_slope_dz_drho_at_rho`.

If these prints show `'r_inner'` *is present*, and the `KeyError` still happens on the next line, then we might be looking at a deeper Python environment issue or a very unusual object state.

Also, please provide the **full Python traceback** for the `KeyError`. The traceback is essential as it shows the exact line numbers and call sequence leading to the error. Your custom "Error calculating trajectory: 'r_inner'" message is helpful for your script, but the traceback gives us the precise location of the `KeyError` itself.