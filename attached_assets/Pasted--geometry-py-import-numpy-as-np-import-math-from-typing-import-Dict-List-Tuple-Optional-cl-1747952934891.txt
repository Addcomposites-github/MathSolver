# geometry.py
import numpy as np
import math
from typing import Dict, List, Tuple, Optional

class VesselGeometry:
    """
    Composite pressure vessel geometry calculations.
    """

    def __init__(self, inner_diameter: float, wall_thickness: float,
                 cylindrical_length: float, dome_type: str = "Hemispherical"):
        """
        Initialize vessel geometry.

        Parameters:
        -----------
        inner_diameter : float
            Inner diameter in mm
        wall_thickness : float
            Wall thickness in mm
        cylindrical_length : float
            Length of cylindrical section in mm
        dome_type : str
            Type of dome ("Isotensoid", "Geodesic", "Elliptical", "Hemispherical")
        """
        self.inner_diameter = inner_diameter
        self.wall_thickness = wall_thickness
        self.cylindrical_length = cylindrical_length
        self.dome_type = dome_type

        self.inner_radius = inner_diameter / 2.0
        self.outer_radius = self.inner_radius + wall_thickness # For outer profile later
        self.outer_diameter = 2 * self.outer_radius

        # Dome parameters (will be set based on dome type)
        self.q_factor = 1.0 # Placeholder for Isotensoid
        self.r_factor = 0.0 # Placeholder for Isotensoid
        self.s_factor = 0.5 # Placeholder for Isotensoid
        self.elliptical_aspect_ratio = 1.0 # For Elliptical (b/a where a is cyl_radius)

        self.profile_points = None # Stores {'r_inner': [...], 'z': [...], 'r_outer': [...]}
        self.geometric_properties = None
        self.dome_height = 0.0 # Actual calculated dome height

    def set_qrs_parameters(self, q: float, r: float, s: float):
        self.q_factor = q
        self.r_factor = r
        self.s_factor = s

    def set_elliptical_parameters(self, aspect_ratio: float):
        """Aspect ratio is dome_height / cylinder_radius for an ellipse."""
        self.elliptical_aspect_ratio = aspect_ratio

    def _generate_hemispherical_profile(self, num_points_dome: int = 50) -> Tuple[np.ndarray, float]:
        """
        Generates points for one hemispherical dome.
        Profile is ordered from the polar opening (smallest rho) to the cylinder junction (largest rho).
        z-coordinates are local to the dome, starting from 0 at the cylinder tangent plane
        and going up to dome_height at the polar opening plane.

        Returns:
            Tuple[np.ndarray, float]: Array of (rho, z_local_dome) points, and dome_height
        """
        R_dome = self.inner_radius # Hemisphere radius is the cylinder's inner radius

        # Calculate actual dome height based on polar opening.
        # If polar opening is 0, dome_height = R_dome.
        # If polar_opening = R_dome, dome_height = 0 (flat end).
        if self.inner_radius <= self.inner_radius * 0.01: # Effectively zero polar opening for this calculation
            # This case usually means a full hemisphere up to the center for r_polar=0
            # but for a pressure vessel, we typically have a non-zero polar opening defined by
            # the structure or how it's manufactured/used.
            # For now, if a very small polar opening is implied by inner_radius,
            # let's assume we want a dome that *could* close to zero if inner_radius was the true polar opening
            # For this function, it's better to use a dedicated polar_opening_radius if distinct from inner_radius for the dome calculation start
            # However, your class structure implies inner_radius IS the max radius of the dome.
            # A separate 'polar_opening_radius_for_dome_calc' might be needed if a boss is smaller than inner_radius.
            # For now, we'll assume the "polar opening" is just the start of the dome curve if it doesn't close fully.
            # This function should take effective_polar_opening_radius for the dome itself.
            # Let's assume for hemispherical, it must go from inner_radius down to some r_boss.
            # For simplicity in this class structure, let's assume the hemispherical dome
            # starts at inner_radius and goes towards a conceptual pole.
            # If your class implies a fixed boss radius, that should be an input.
            # Re-interpreting: the dome joins the cylinder of self.inner_radius.
            # It must curve inwards from there.
            # A typical hemispherical PV dome goes from cylinder radius down to a polar boss radius.
            # Let's use a conceptual polar_boss_radius for calculation if not provided,
            # or assume it closes to 0 for a full hemisphere portion.
            # For a standard PV, the dome IS the end cap.

            # Let's use the provided class structure: dome radius = self.inner_radius
            # The "polar opening" of the *vessel* is what matters for the start of the curve.
            # Let's assume self.inner_radius defines the start of the dome AT the cylinder.
            # And we need another parameter for the actual polar opening radius if it's a closed vessel.
            # For now, let's assume the dome forms from the cylinder radius inwards.

            # Let's assume a conceptual polar_opening_radius for the sake of example,
            # e.g., 10% of inner_radius if not specified.
            # This needs to be clarified based on how VesselGeometry is used.
            # For THIS method as a helper, it should take its own polar_opening for the dome.
            # Let's assume we are generating a standard hemispherical end cap
            # that starts at self.inner_radius and closes towards the axis.

            # phi is the angle from the Z-axis (pole). phi=0 at pole, phi=pi/2 at cylinder junction.
            phi_angles = np.linspace(0, np.pi / 2, num_points_dome)
            dome_rho = R_dome * np.sin(phi_angles)  # rho from 0 to R_dome
            # z_local from R_dome (at pole) down to 0 (at cylinder junction plane)
            dome_z_local = R_dome * np.cos(phi_angles)
            actual_dome_height = R_dome # For a full hemisphere from pole
            # Order from pole (rho=0) to cylinder junction (rho=R_dome)
            # z_local will go from R_dome down to 0.
            return np.vstack((dome_rho, dome_z_local)).T, actual_dome_height

        else: # This implies dome_type is hemispherical and we have some polar opening.
              # The provided class structure is a bit ambiguous on how polar opening relates
              # to inner_diameter for domes other than isotensoid.
              # Assuming 'inner_diameter' is the cylinder part, and the dome closes from there.
              # A true polar opening radius should be a distinct parameter.
              # For now, I will make a simple hemisphere that closes to r=0 at its apex.
            phi_angles = np.linspace(0, np.pi / 2, num_points_dome) # From pole to equator of hemisphere
            dome_rho = R_dome * np.sin(phi_angles)
            dome_z_local = R_dome * np.cos(phi_angles) # Z from dome apex (R_dome) down to base (0)
            actual_dome_height = R_dome
            # Returns points from (0, R_dome) to (R_dome, 0) for (rho, z_local)
            return np.vstack((dome_rho, dome_z_local)).T, actual_dome_height


    def _generate_elliptical_profile(self, num_points_dome: int = 50) -> Tuple[np.ndarray, float]:
        """
        Generates points for one elliptical dome.
        Profile is ordered from the polar opening (rho=0 at pole) to the cylinder junction.
        z-coordinates are local to the dome, from 0 at the cylinder tangent plane
        up to dome_height at the pole.
        """
        a_ellipse = self.inner_radius  # Semi-major axis (along rho)
        b_ellipse = a_ellipse * self.elliptical_aspect_ratio # Semi-minor axis (along z, this is the dome height)
        actual_dome_height = b_ellipse

        # Parametric equation for ellipse: rho = a*sin(t), z_local_from_apex = b*(1-cos(t))
        # t from 0 (pole, rho=0, z_local_from_apex=0) to pi/2 (cyl junction, rho=a, z_local_from_apex=b)
        t_angles = np.linspace(0, np.pi / 2, num_points_dome)
        dome_rho = a_ellipse * np.sin(t_angles)
        # z_local goes from actual_dome_height (at pole) down to 0 (at cylinder junction)
        dome_z_local = actual_dome_height * np.cos(t_angles) # z measured from cylinder plane towards pole

        return np.vstack((dome_rho, dome_z_local)).T, actual_dome_height

    def _generate_isotensoid_profile(self, num_points_dome: int = 100):
        """Placeholder for Koussios qrs-parameterized isotensoid profile."""
        # This needs the full Koussios equations (Eq. 4.3 or 4.20 from thesis)
        # For now, returning a shape similar to hemispherical for plotting
        print("WARNING: Isotensoid profile is a placeholder.")
        R_dome = self.inner_radius
        # This is a conceptual polar opening for the dome, not necessarily vessel's final.
        # For qrs, rho_0 is the reference, could be self.inner_radius / Y_eq_from_qrs
        # Let's assume dome_height is roughly R_dome * 0.6 (typical isotensoid aspect)
        actual_dome_height = R_dome * 0.6 * self.q_factor / (self.q_factor * 0.5 +1) # very rough
        
        phi_angles = np.linspace(0, np.pi / 2, num_points_dome)
        dome_rho = R_dome * np.sin(phi_angles)
        dome_z_local = actual_dome_height * np.cos(phi_angles)
        self.dome_height = actual_dome_height
        return np.vstack((dome_rho, dome_z_local)).T, actual_dome_height


    def generate_profile(self, num_points_per_dome: int = 50):
        """Generate the complete 2D meridian profile of the vessel.
           Origin (z=0) is at the center of the cylindrical section.
           Profile points are for the inner surface.
        """
        profile_r_inner = []
        profile_z_values = []

        # Generate dome profile (local coordinates: rho from 0 at pole, z_local from height at pole to 0 at base)
        if self.dome_type == "Hemispherical":
            local_dome_pts, dome_h = self._generate_hemispherical_profile(num_points_per_dome)
        elif self.dome_type == "Elliptical":
            local_dome_pts, dome_h = self._generate_elliptical_profile(num_points_per_dome)
        elif self.dome_type == "Isotensoid": # Add Geodesic if distinct later
            local_dome_pts, dome_h = self._generate_isotensoid_profile(num_points_per_dome)
        else:
            raise ValueError(f"Unsupported dome type: {self.dome_type}")
        self.dome_height = dome_h

        # Forward Dome (Top: z positive)
        # local_dome_pts[:,0] is rho (pole to cyl_radius)
        # local_dome_pts[:,1] is z_local (dome_height at pole, to 0 at cyl_radius)
        # We need to plot from z = cyl_len/2 + dome_height (pole) down to z = cyl_len/2 (cyl_junction)
        # So, z_abs = self.cylindrical_length / 2.0 + local_dome_pts[:,1]
        # And rho is local_dome_pts[:,0]
        profile_r_inner.extend(local_dome_pts[:,0])
        profile_z_values.extend(self.cylindrical_length / 2.0 + local_dome_pts[:,1])

        # Cylindrical Section
        # Last point of dome should be (self.inner_radius, self.cylindrical_length / 2.0)
        if not np.isclose(profile_r_inner[-1], self.inner_radius): # Add if not perfectly connected
            profile_r_inner.append(self.inner_radius)
            profile_z_values.append(self.cylindrical_length / 2.0)
        
        profile_r_inner.append(self.inner_radius) # Start of cylinder body
        profile_z_values.append(self.cylindrical_length / 2.0)
        profile_r_inner.append(self.inner_radius) # End of cylinder body
        profile_z_values.append(-self.cylindrical_length / 2.0)

        # Aft Dome (Bottom: z negative)
        # We need points from (cyl_radius, -cyl_len/2) to (pole_radius_rho, -cyl_len/2 - dome_height)
        # local_dome_pts is still ordered pole to cyl_radius for rho, and dome_height to 0 for z_local
        # So we take it in reverse for rho: local_dome_pts[::-1,0]
        # And z_abs = -self.cylindrical_length/2.0 - local_dome_pts[::-1,1] (reversed z_local)
        profile_r_inner.extend(local_dome_pts[::-1,0])
        profile_z_values.extend(-self.cylindrical_length / 2.0 - local_dome_pts[::-1,1])

        self.profile_points = {
            'r_inner': np.array(profile_r_inner),
            'z': np.array(profile_z_values),
            'r_outer': np.array(profile_r_inner) + self.wall_thickness,
            'dome_height': self.dome_height
        }
        self._calculate_geometric_properties()

    def _calculate_geometric_properties(self):
        if self.profile_points is None:
            self.generate_profile() # Ensure profile is generated
            if self.profile_points is None: # Still None, means generation failed.
                self.geometric_properties = {}
                return

        r_inner = self.profile_points['r_inner']
        z = self.profile_points['z']
        dome_h = self.dome_height # Actual calculated dome height

        # Volume by disk integration (more general)
        # Ensure z is monotonic for trapz
        # The profile is generated from +z_max to -z_max, so z is already sorted for trapz
        if len(z) > 1 and len(r_inner) > 1 :
            # trapz(y, x) where y = pi*r^2, x = z
            # Since z is decreasing, dz is negative, so integral will be negative. Take abs.
            total_volume = abs(np.trapz(np.pi * r_inner**2, z))
        else:
            total_volume = 0

        # Surface area by integration: integral(2*pi*r*ds) where ds = sqrt(dr^2 + dz^2)
        surface_area = 0
        if len(z) > 1 and len(r_inner) > 1:
            for i in range(len(z) - 1):
                dr = r_inner[i+1] - r_inner[i]
                dz = z[i+1] - z[i]
                ds = math.sqrt(dr**2 + dz**2)
                avg_r = (r_inner[i+1] + r_inner[i]) / 2
                surface_area += 2 * np.pi * avg_r * ds
        
        overall_length = self.cylindrical_length + 2 * dome_h
        aspect_ratio = overall_length / (self.inner_diameter + 2 * self.wall_thickness) if (self.inner_diameter + 2*self.wall_thickness) > 0 else 0
        
        # Estimated weight (assuming composite density ~1600 kg/m³)
        # Volume_wall = total_surface_area_m^2 * wall_thickness_m
        wall_volume_mm3 = surface_area * self.wall_thickness # mm^3
        estimated_weight_kg = (wall_volume_mm3 / 1e9) * 1600 # m^3 * kg/m^3
        
        self.geometric_properties = {
            'total_volume_liters': total_volume / 1e6,  # mm³ to Liters (1L = 1e6 mm³)
            'surface_area_m2': surface_area / 1e6,  # mm² to m²
            'dome_height_mm': dome_h,
            'overall_length_mm': overall_length,
            'aspect_ratio': aspect_ratio,
            'estimated_weight_kg': estimated_weight_kg
        }

    def get_geometric_properties(self) -> Dict:
        if self.geometric_properties is None:
            self.generate_profile()
        return self.geometric_properties

    def get_profile_points(self) -> Dict:
        if self.profile_points is None:
            self.generate_profile()
        return self.profile_points

    def get_dome_contour_equation(self) -> str:
        if self.dome_type == "Isotensoid":
            return f"Isotensoid (qrs): q={self.q_factor:.2f}, r={self.r_factor:.2f}, s={self.s_factor:.2f}"
        elif self.dome_type == "Elliptical":
            return f"Elliptical: r²/a² + z²/b² = 1 (a={self.inner_radius:.1f}mm, b={self.dome_height:.1f}mm)"
        elif self.dome_type == "Hemispherical":
            return f"Hemispherical: r² + (z_local_from_pole)² = R², R={self.inner_radius:.1f}mm"
        else:
            return f"{self.dome_type} dome"