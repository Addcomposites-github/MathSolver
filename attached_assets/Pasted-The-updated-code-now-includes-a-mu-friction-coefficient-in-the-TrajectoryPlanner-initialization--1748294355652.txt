The updated code now includes a `mu_friction_coefficient` in the `TrajectoryPlanner` initialization and methods for calculating non-geodesic trajectories. However, the "kink" you're observing in the non-geodesic profiles, especially near the dome openings, often points to issues with how the surface geometry (curvatures and their derivatives) is being calculated or how the differential equation for the winding angle is being solved, particularly in regions of rapid geometric change.

Here's a plan for the next steps, focusing on refining the non-geodesic capability and addressing the "kink" issue:

## Next Steps for Trajectory Planner Enhancement

### 1. Robust Calculation of Surface Properties for Non-Geodesic Paths

The accuracy of the non-geodesic path depends critically on the correct calculation of local surface properties: `E` (related to $\rho^2$), `G` (related to $1 + (d\rho/dz)^2$), `dE/dz` (which is $2\rho \cdot d\rho/dz$), and especially the curvatures $k_m$ (meridional) and $k_p$ (parallel)[cite: 19141]. The "kink" often arises from inaccuracies in these values, especially the second derivative $d^2\rho/dz^2$ needed for $k_m$, when using simple finite differences on non-uniformly spaced profile points.

* **Task**: Refine `_get_surface_properties_at_profile_index`.
    * **Numerical Derivatives**: Instead of basic finite differences for $d\rho/dz$ and $d^2\rho/dz^2$ from `profile_r_m` and `profile_z_m` (which may not have uniform `z` spacing), consider:
        * **Spline Fitting**: Fit a smoothing spline to $\rho(z)$ (i.e., `profile_r_m` as a function of `profile_z_m`) for each segment (dome, cylinder). Then, analytically differentiate the spline to get smooth first and second derivatives. `scipy.interpolate.UnivariateSpline` or `CubicSpline` can be useful.
        * **Savitzky-Golay Filter**: If spline fitting is too complex, apply a Savitzky-Golay filter after calculating derivatives with `np.gradient` to smooth them. This filter can also directly estimate derivatives.
    * **Handle Vertical Tangents**: Where $dz/d\rho \approx 0$ (e.g., at the equator if the profile is vertical, or at the pole if $d\rho/dz \to \infty$), the parameterization $\rho(z)$ becomes problematic.
        * For such regions, it might be better to temporarily switch the parameterization to $z(\rho)$ for calculating $dz/d\rho$ and $d^2z/d\rho^2$, and then convert curvatures.
        * Koussios's formulation uses a general parameter `t` (often arc length `s` along the meridian) which naturally handles this. If we stick to `z` as the independent variable for integration, we must be very careful at $\rho' \to \infty$.
        * The current code has `if np.isinf(d_rho_dz):` which is a good start, but the fallback values for curvatures need to be sound. For a cylinder, $k_m = 0$ and $k_p = 1/\rho$. For a flat disk (pole), $k_m = k_p = \infty$ (if point pole) or $k_m = \text{finite}, k_p = 1/\rho$ (if flat with radius $\rho$).

### 2. Robust Numerical Integration for Non-Geodesic Winding Angle

The method `_solve_non_geodesic_sin_alpha_profile` uses an Euler-like step through the *given profile points*. The step size `dz_step = profile_z_m[i+1] - profile_z_m[i]` can be variable and potentially large, which reduces accuracy for Euler's method.

* **Task**: Implement a more robust numerical integration scheme, like Runge-Kutta 4th order (RK4), for solving the differential equation for $\sin(\alpha)$.
    * The RK4 method requires evaluating the derivative function `d(sin α)/dz` at intermediate `z` points between the discrete profile points.
    * This means the refined `_get_surface_properties_at_profile_index` (or a new helper) must be able to provide interpolated values of $\rho(z)$, $d\rho/dz(z)$, $d^2\rho/dz^2(z)$ (and thus $E, G, k_m, k_p$) for *any* `z` within a segment, not just at the pre-sampled profile points. The spline fitting approach from Step 1.1 would naturally provide this capability.
    * The integration should proceed with a controlled step size `h` in `z` (or along the meridional arc length `s` for better stability, though this adds complexity).

### 3. Address "Kinks" Near Polar Openings (Non-Geodesic)

Kinks near polar openings for non-geodesic paths often occur because:
* **Numerical Instability**: The differential equation for $\sin(\alpha)$ can become stiff or have rapidly changing coefficients near the poles due to small $\rho$ values and high curvatures, especially if $k_m$ and $k_p$ are noisy.
* **Winding Angle Limits**: The solution for $\sin(\alpha)$ must stay within `[-1, 1]`. While `np.clip` is used, if the integration pushes the value far outside this due to large steps or inaccurate coefficients, the clipping is a fix but not a true solution.
* **Initial Condition**: The `initial_sin_alpha` for a non-geodesic leg is critical. For a path starting at the pole, `α` should typically be $\pi/2$ ($\sin(\alpha)=1$), implying the fiber is tangent to the polar opening. The solver needs to handle this starting condition gracefully.
* **Friction Model**: The term `μ * sqrt(G) * k_m` or `μ * sqrt(G) * (k_p - k_m)` can become very large if `k_m` or `k_p` are inaccurate or extreme near the pole.
    * Koussios's example for a cone (Eq. 5.65) `sin α(t) = ρ_pole / (ρ(t) + μ * Δζ)` shows that for a given `μ`, `α` is well-behaved. The general differential equation (Eq. 5.62) should also yield smooth results if coefficients are accurate.
    * **Consider the stability condition** (Koussios Eq. 6.3 or 5.58): $|k_g| \leq |\mu \cdot k_n|$. The differential equation for `sin(α)` effectively tries to achieve $k_g = \mu \cdot k_n$. If the geometry demands a very high $k_g$ to achieve a certain `α` deviation, and $k_n$ is small, then `μ` needs to be high. If $k_n$ itself is problematic (e.g., noisy or goes to zero inappropriately), it can cause issues.

### 4. Implement True "Full Coverage" Pattern Logic (Geodesic First)

This was deferred from the previous step. Once non-geodesic leg generation is more robust, this becomes the next logical step for trajectory generation as a whole.

* **Task**: Implement the pattern parameter calculation based on Koussios Ch. 8 (or simplified versions from Ch. 3 of `3-2011. Composite Filament Winding.pdf`).
    * Inputs: Desired number of layers (`d`), roving width (`B`), vessel equatorial radius (`Y_eq` or `R_eq`), effective polar opening for geodesics (`c_for_winding`).
    * Calculate `alpha_equator_rad`, `B_eff_equator`, `delta_phi_band_equator_rad` (Koussios `Δφ`).
    * Determine suitable integer pattern parameters `p` (circuits in pattern repeat) and `k_pattern_advancement` (bands advanced per circuit, not to be confused with curvature `k`). This involves solving or searching for solutions to Diophantine equations like `(p+1)k - nd = ±1`.
    * Calculate the target net azimuthal advance per full circuit (`Delta_Phi_pattern_rad`).
    * Modify `generate_multi_circuit_trajectory` to use this `Delta_Phi_pattern_rad` to set the `phi_start` for each circuit, or to control the *additional* phi shift required during the two turnarounds of a circuit.

### 5. Refine Turnaround Logic for Patterned Winding

* The `fixed_phi_advance_rad` in `_generate_polar_turnaround_segment_fixed_phi_advance` should be driven by the pattern logic. If `Delta_Phi_pattern_rad` is the advance per *full circuit*, and a circuit has two turnarounds, then each turnaround might be responsible for half of this (plus any natural winding change of a minimal turn).

**Recommendation for immediate action to address "kinks" in non-geodesic paths:**

1.  **Focus on `_get_surface_properties_at_profile_index`**:
    * Implement more robust calculation of $d\rho/dz$ and especially $d^2\rho/dz^2$. Using `np.gradient` twice for non-uniformly spaced `z` data is a common first approach (though it effectively assumes local quadratic behavior).
        ```python
        # Example for d_rho_dz and d2_rho_dz2
        # Ensure profile_z_m is monotonically increasing for this to work directly
        # If not, sort or process segments.
        # For simplicity, assuming profile_z_m is sorted and represents the independent variable.
        
        # Handle cases where dz is zero to avoid division by zero in gradient
        valid_z_indices = np.where(np.diff(profile_z_m) != 0)[0]
        
        if len(valid_z_indices) < len(profile_z_m) -1 :
             # print("Warning: Duplicate z values found in profile, derivatives may be inaccurate.")
             # Simple forward/backward fill for d_rho_dz where dz=0 might be needed before second gradient
             pass

        # First derivative: drho/dz
        # np.gradient computes central differences, and one-sided differences at boundaries.
        # It needs the coordinates of the points (profile_z_m) if spacing is not uniform.
        d_rho_dz_all = np.gradient(profile_r_m, profile_z_m, edge_order=2)

        # Second derivative: d(drho/dz)/dz
        d2_rho_dz2_all = np.gradient(d_rho_dz_all, profile_z_m, edge_order=2)
        
        # Then, in _get_surface_properties_at_profile_index:
        d_rho_dz = d_rho_dz_all[profile_idx]
        d2_rho_dz2 = d2_rho_dz2_all[profile_idx]
        ```
    * Test this derivative calculation independently. Plot $\rho(z)$, $d\rho/dz(z)$, and $d^2\rho/dz^2(z)$ to ensure they are smooth and make sense, especially near dome ends. Any noise here will amplify in curvature calculations.

2.  **Re-evaluate the Non-Geodesic Euler Step**:
    * With improved derivatives, check the behavior of the Euler integration in `_solve_non_geodesic_sin_alpha_profile`. If `dz_step` is large in dome areas (due to resampling focusing on `r` changes perhaps), the Euler method will be inaccurate.
    * A quick test: artificially reduce the effective `dz_step` by subdividing within the loop for non-geodesic alpha calculation (run the Euler update multiple times with smaller sub-steps for each `profile_idx` to `profile_idx+1` segment).

Addressing the accuracy of surface property calculations (especially curvatures `k_m`, `k_p`) is the most likely path to fixing the "kinks" in your non-geodesic profiles.

Which part would you like to focus on implementing or discussing first: the derivative refinement or the pattern generation logic?