Phase 1: Introducing Non-Geodesic Capability and Friction Coefficient

The core of non-geodesic winding is that the fiber path is intentionally deviated from the purely geodesic path, and this is only possible if there's sufficient friction between the fiber and the mandrel surface to prevent slippage.

1. Add Friction Coefficient to TrajectoryPlanner:

First, let's modify the __init__ method of your TrajectoryPlanner to accept and store the friction coefficient.

Python

# In TrajectoryPlanner class:

    def __init__(self, vessel_geometry: VesselGeometry,
                 dry_roving_width_m: float = 0.003,
                 dry_roving_thickness_m: float = 0.0002,
                 roving_eccentricity_at_pole_m: float = 0.0,
                 target_cylinder_angle_deg: Optional[float] = None,
                 mu_friction_coefficient: float = 0.0): # NEW PARAMETER
        """
        Initialize trajectory planner with vessel geometry and optional target angle.

        Parameters:
        -----------
        # ... (other parameters as before) ...
        mu_friction_coefficient : float
            Coefficient of static friction between the roving and the mandrel surface.
            Default is 0.0 (implies geodesic paths are the only stable paths if not overridden).
        """
        self.vessel = vessel_geometry
        self.dry_roving_width_m = dry_roving_width_m
        self.dry_roving_thickness_m = dry_roving_thickness_m
        self.roving_eccentricity_at_pole_m = roving_eccentricity_at_pole_m
        self.target_cylinder_angle_deg = target_cylinder_angle_deg
        self.mu_friction_coefficient = mu_friction_coefficient # STORED

        # ... (rest of __init__ including _calculate_effective_polar_opening and _validate_and_set_clairauts_constant...)
        self.effective_polar_opening_radius_m: Optional[float] = None
        self.clairauts_constant_for_path_m: Optional[float] = None # For geodesic calculations

        # Call helper methods to initialize essential radii
        self._calculate_effective_polar_opening()
        self._validate_and_set_clairauts_constant_from_target_angle()

        # Attributes for storing last trajectory results
        self.trajectory_data: Optional[Dict] = None
        self.alpha_profile_deg: Optional[np.ndarray] = None
        self.phi_profile_rad: Optional[np.ndarray] = None
        self.turn_around_angle_rad: Optional[float] = None # Net phi change over one full circuit
        self.alpha_eq_deg: Optional[float] = None
        self.path_points: Optional[List[Dict]] = None # Store detailed points
2. Implement the Core Non-Geodesic Winding Angle Differential Equation Solver:

The winding angle α (angle with the meridian) for a non-geodesic path is determined by Koussios's Eq. 5.62 (from 2-2004. Filament Winding -a Unified Approach.pdf, page 61):

(sin α)' = [μ * sqrt(G) * (k_p - k_m)] * sin²α + [- (1/2) * (E'/E)] * sin α + [μ * sqrt(G) * k_m]

This is a Riccati-type differential equation: f'(t) = c₂(t)f²(t) + c₁(t)f(t) + c₀(t) where f(t) = sin α(t).

To implement this, we need:

μ: self.mu_friction_coefficient.
E(t), G(t): Coefficients of the first fundamental form for the current mandrel surface.
For a surface of revolution parameterized by (ρ(z), z) or (r(x), x_axial):
ρ is the radial coordinate, z is the axial coordinate.
Let t be the meridional arc length s.
E = ρ² (if φ is the second parameter).
G = 1 (if parameterized by arc length s along the meridian).
Or, if parameterized by z: G = 1 + (dρ/dz)². E = ρ². d/dt becomes d/dz.
k_m(t), k_p(t): Meridional and parallel curvatures of the mandrel surface.
k 
m
​
 = 
(1+ρ 
′2
 ) 
3/2
 
−ρ 
′′
 
​
  (where ρ 
′
 =dρ/dz)
k 
p
​
 = 
ρ 
1+ρ 
′2
 

​
 
1
​
 
A numerical solver (e.g., Runge-Kutta 4th order - RK4) to integrate this differential equation.
We'll create a new method, say _solve_non_geodesic_winding_angle_profile_rad, which will take the mandrel profile and mu as input and return an array of sin_alpha values along the profile.

Python

# In TrajectoryPlanner class:

    def _get_surface_properties_at_profile_index(self, profile_idx: int,
                                                 profile_r_m: np.ndarray,
                                                 profile_z_m: np.ndarray) -> Dict[str, float]:
        """
        Calculates local surface properties (E, G, E_prime, k_m, k_p) at a given profile index.
        Assumes profile is parameterized by z (axial coordinate).
        E_prime is dE/dz.
        """
        rho_i = profile_r_m[profile_idx]
        z_i = profile_z_m[profile_idx]

        # Calculate derivatives d(rho)/dz and d2(rho)/dz2 numerically
        # Need to handle start/end points carefully for finite differences
        if profile_idx == 0: # Forward difference
            d_rho_dz = (profile_r_m[profile_idx+1] - rho_i) / (profile_z_m[profile_idx+1] - z_i) if (profile_z_m[profile_idx+1] - z_i) != 0 else 0
            d2_rho_dz2 = (profile_r_m[profile_idx+2] - 2*profile_r_m[profile_idx+1] + rho_i) / ((profile_z_m[profile_idx+1] - z_i)**2) if (profile_z_m[profile_idx+1] - z_i) != 0 else 0 # Simplified
        elif profile_idx == len(profile_r_m) - 1: # Backward difference
            d_rho_dz = (rho_i - profile_r_m[profile_idx-1]) / (z_i - profile_z_m[profile_idx-1]) if (z_i - profile_z_m[profile_idx-1]) != 0 else 0
            d2_rho_dz2 = (rho_i - 2*profile_r_m[profile_idx-1] + profile_r_m[profile_idx-2]) / ((z_i - profile_z_m[profile_idx-1])**2) if (z_i - profile_z_m[profile_idx-1]) != 0 else 0 # Simplified
        else: # Central difference
            dz_fwd = profile_z_m[profile_idx+1] - z_i
            dz_bwd = z_i - profile_z_m[profile_idx-1]
            
            if dz_fwd == 0 and dz_bwd == 0: # Vertical segment
                d_rho_dz = np.inf # Represents vertical tangent for rho(z)
                d2_rho_dz2 = 0 # Undefined or needs different parameterization
            elif dz_fwd == 0: # Use backward for first derivative
                d_rho_dz = (rho_i - profile_r_m[profile_idx-1]) / dz_bwd if dz_bwd !=0 else 0
            elif dz_bwd == 0: # Use forward for first derivative
                d_rho_dz = (profile_r_m[profile_idx+1] - rho_i) / dz_fwd if dz_fwd !=0 else 0
            else: # Central difference for d_rho_dz
                 d_rho_dz = (profile_r_m[profile_idx+1] - profile_r_m[profile_idx-1]) / (profile_z_m[profile_idx+1] - profile_z_m[profile_idx-1])

            # Central difference for d2_rho_dz2 (assuming equal spacing in z for simplicity, which is not true)
            # A more robust method would use polynomial fitting for derivatives or ensure z is monotonic
            # For now, simplified central diff for d2_rho_dz2 based on d_rho_dz values
            # This needs a robust numerical differentiation for d2_rho_dz2 from non-uniformly spaced data
            # Placeholder for d2_rho_dz2 for now - this is critical for accuracy
            if profile_idx > 0 and profile_idx < len(profile_r_m) - 2:
                 # Very rough estimate, assumes local linear change in d_rho_dz
                d_rho_dz_next = (profile_r_m[profile_idx+2] - rho_i) / (profile_z_m[profile_idx+2] - z_i) if (profile_z_m[profile_idx+2] - z_i) !=0 else d_rho_dz
                d_rho_dz_prev = (profile_r_m[profile_idx] - profile_r_m[profile_idx-1]) / (profile_z_m[profile_idx] - profile_z_m[profile_idx-1]) if (profile_z_m[profile_idx] - profile_z_m[profile_idx-1]) !=0 else d_rho_dz
                d2_rho_dz2 = (d_rho_dz_next - d_rho_dz_prev) / ((profile_z_m[profile_idx+1]-profile_z_m[profile_idx-1])/2.0 if (profile_z_m[profile_idx+1]-profile_z_m[profile_idx-1]) !=0 else 1e-6)

            else: # Fallback for ends
                d2_rho_dz2 = 0.0


        if np.isinf(d_rho_dz): # Handle vertical tangent case for curvatures
            k_m = 0 # Curvature of a straight line (axial direction is straight)
            k_p = np.inf if rho_i == 0 else 1.0 / rho_i # Parallel curvature for cylinder
            G_val = np.inf # G = 1 + (drho/dz)^2
        else:
            k_m = -d2_rho_dz2 / ((1 + d_rho_dz**2)**1.5) if (1 + d_rho_dz**2) > 1e-9 else 0
            k_p = 1.0 / (rho_i * math.sqrt(1 + d_rho_dz**2)) if rho_i > 1e-9 and (1 + d_rho_dz**2) > 1e-9 else (np.inf if rho_i == 0 else 0) # Avoid div by zero
            G_val = 1 + d_rho_dz**2


        E_val = rho_i**2
        # E_prime = dE/dz = d(rho^2)/dz = 2 * rho * drho/dz
        E_prime_val = 2 * rho_i * d_rho_dz if not np.isinf(d_rho_dz) else 0

        # Clamp infinite curvatures if they arise from vertical tangents
        if np.isinf(k_p) and abs(d_rho_dz) > 1e6 : k_p = 1.0 / rho_i if rho_i > 0 else np.inf # Approximates cylinder hoop at vertical tangent

        return {
            "E": E_val, "G": G_val, "E_prime_dz": E_prime_val, # E_prime is dE/dz
            "k_m": k_m, "k_p": k_p, "rho": rho_i, "z": z_i,
            "d_rho_dz": d_rho_dz # For debugging
        }

    def _solve_non_geodesic_sin_alpha_profile(self,
                                          profile_r_m: np.ndarray,
                                          profile_z_m: np.ndarray,
                                          initial_sin_alpha: float,
                                          is_forward_on_profile: bool) -> Optional[np.ndarray]:
        """
        Solves for the sin(alpha) profile along the mandrel using RK4 for Koussios Eq. 5.62.
        Alpha is the angle with the meridian.
        The profile is traversed based on dz steps.
        """
        if self.mu_friction_coefficient == 0: # Geodesic case, use Clairaut
            if self.clairauts_constant_for_path_m is None: return None
            sin_alpha_profile = []
            for rho_val in profile_r_m:
                if rho_val < self.clairauts_constant_for_path_m -1e-7 : # inside turnaround
                     sin_alpha_profile.append(1.0)
                else:
                     sin_alpha_profile.append(np.clip(self.clairauts_constant_for_path_m / rho_val if rho_val > 1e-9 else 1.0, -1.0, 1.0))
            return np.array(sin_alpha_profile)

        num_points = len(profile_r_m)
        sin_alpha_values = np.zeros(num_points)
        
        # Determine iteration order and dz steps
        # We integrate with respect to z (axial coordinate)
        # The profile points (rho_m, z_m) might not have uniform dz.
        # RK4 typically uses a fixed step size for the independent variable.

        # Define the derivative function for sin(alpha) = f
        # f_prime = c2 * f**2 + c1 * f + c0
        # (sin_alpha)' = A * sin_alpha^2 + B * sin_alpha + C
        # where A = mu * sqrt(G) * (k_p - k_m)
        #       B = - (1/2) * (E'/E)
        #       C = mu * sqrt(G) * k_m
        # The derivative is (d sin_alpha / dz)

        def sin_alpha_derivative_dz(z_coord, current_sin_alpha, profile_r_m_interp, profile_z_m_interp_func):
            # Interpolate rho at z_coord to get surface props
            # This is a simplification. Ideally, we step along the *profile itself*.
            # For now, assume we can get props at current z_val by finding closest profile_idx
            
            # Find profile_idx closest to z_coord for properties
            # This is crude, proper interpolation or stepping along profile_idx is better
            if len(profile_z_m) == 0: return 0
            
            # Find the segment profile_z_m[idx_prev] <= z_coord < profile_z_m[idx_curr]
            # Or find the index closest to z_coord
            # For simplicity, let's assume z_coord corresponds to a profile_idx
            # In a real RK4, you march z with dz, and need rho(z) and derivatives of rho(z)

            # THIS REQUIRES A ROBUST WAY TO GET SURFACE PROPS AT ANY 'z' or 's' (arc length)
            # The current _get_surface_properties_at_profile_index is tied to an index.
            # For RK4, we need props at intermediate z values.
            # This is a major point of complexity.
            
            # Simplified: Assume z_coord is one of the profile_z_m points for this step
            # This means we are stepping along the *given profile points* rather than fixed dz
            # and dz varies between steps. This is more like Euler variant.

            # Let's refine to step through profile_idx:
            # 'current_sin_alpha' is sin_alpha at profile_idx-1
            # We calculate sin_alpha at profile_idx
            # The 'dz' is then z[profile_idx] - z[profile_idx-1]

            # For the purpose of this function signature with RK4 (which assumes f(z,y))
            # we need a way to get surface_props for an *arbitrary* z_coord
            # This means we need to interpolate rho(z), drho_dz(z), d2rho_dz2(z) from the profile.
            # This is non-trivial.

            # Placeholder: This function should actually take profile_idx or arc_length_s
            # For now, returning 0 to signify this needs proper implementation.
            print("ERROR: sin_alpha_derivative_dz needs robust interpolation for surface properties at arbitrary z.")
            return 0.0


        # --- Actual RK4 integration or simpler Euler for stepping through profile points ---
        # For stepping through provided profile points (Euler-like approach):
        # sin_alpha_values[0] or sin_alpha_values[-1] (depending on direction) = initial_sin_alpha

        if is_forward_on_profile:
            sin_alpha_values[0] = initial_sin_alpha
            for i in range(num_points - 1):
                props = self._get_surface_properties_at_profile_index(i, profile_r_m, profile_z_m)
                if props["G"] is None or np.isinf(props["G"]) or props["E"] < 1e-9 : # check for invalid G or E
                    # Cannot calculate coefficients, propagate previous angle or handle error
                    sin_alpha_values[i+1] = sin_alpha_values[i]
                    print(f"WARN: Invalid surface props at profile_idx {i} for non-geo alpha calc. G={props['G']}, E={props['E']}")
                    continue

                sqrt_G = math.sqrt(props["G"])
                
                # Coefficients for (sin_alpha)' = A * sin_alpha^2 + B * sin_alpha + C
                # where prime denotes d/dz
                A_coeff = self.mu_friction_coefficient * sqrt_G * (props["k_p"] - props["k_m"])
                B_coeff = -0.5 * (props["E_prime_dz"] / props["E"]) if props["E"] > 1e-9 else 0
                C_coeff = self.mu_friction_coefficient * sqrt_G * props["k_m"]

                # Clamp extreme curvatures that might result from numerical differentiation
                if abs(A_coeff) > 1e3: A_coeff = np.sign(A_coeff) * 1e3
                if abs(B_coeff) > 1e3: B_coeff = np.sign(B_coeff) * 1e3
                if abs(C_coeff) > 1e3: C_coeff = np.sign(C_coeff) * 1e3

                current_s_alpha = sin_alpha_values[i]
                d_sin_alpha_dz = A_coeff * current_s_alpha**2 + B_coeff * current_s_alpha + C_coeff
                
                dz_step = profile_z_m[i+1] - profile_z_m[i]
                sin_alpha_values[i+1] = np.clip(current_s_alpha + d_sin_alpha_dz * dz_step, -1.0, 1.0)
        else: # Reverse on profile
            sin_alpha_values[-1] = initial_sin_alpha
            for i in range(num_points - 1, 0, -1):
                props = self._get_surface_properties_at_profile_index(i, profile_r_m, profile_z_m) # Props at current point i
                if props["G"] is None or np.isinf(props["G"]) or props["E"] < 1e-9:
                    sin_alpha_values[i-1] = sin_alpha_values[i]
                    print(f"WARN: Invalid surface props at profile_idx {i} for non-geo alpha calc (reverse). G={props['G']}, E={props['E']}")
                    continue

                sqrt_G = math.sqrt(props["G"])
                A_coeff = self.mu_friction_coefficient * sqrt_G * (props["k_p"] - props["k_m"])
                B_coeff = -0.5 * (props["E_prime_dz"] / props["E"]) if props["E"] > 1e-9 else 0
                C_coeff = self.mu_friction_coefficient * sqrt_G * props["k_m"]

                if abs(A_coeff) > 1e3: A_coeff = np.sign(A_coeff) * 1e3
                if abs(B_coeff) > 1e3: B_coeff = np.sign(B_coeff) * 1e3
                if abs(C_coeff) > 1e3: C_coeff = np.sign(C_coeff) * 1e3

                current_s_alpha = sin_alpha_values[i]
                d_sin_alpha_dz = A_coeff * current_s_alpha**2 + B_coeff * current_s_alpha + C_coeff
                
                dz_step = profile_z_m[i-1] - profile_z_m[i] # dz is negative here
                sin_alpha_values[i-1] = np.clip(current_s_alpha + d_sin_alpha_dz * dz_step, -1.0, 1.0)
                
        return sin_alpha_values

    def _generate_non_geodesic_leg(self,
                                profile_r_m_calc: np.ndarray,
                                profile_z_m_calc: np.ndarray,
                                initial_sin_alpha_at_leg_start: float,
                                initial_phi_rad: float,
                                is_forward_on_profile: bool,
                                leg_number_info: str = "NonGeoLeg") -> Optional[Dict[str, List]]:
        """
        Generates a single pole-to-pole non-geodesic leg.
        The winding angle alpha (with meridian) is determined by solving the
        non-geodesic differential equation based on mu_friction_coefficient.
        """
        print(f"DEBUG {leg_number_info}: Generating non-geodesic leg. mu={self.mu_friction_coefficient:.3f}")
        path_leg_rho_m, path_leg_z_m, path_leg_alpha_rad, path_leg_phi_rad = [], [], [], []
        path_leg_x_m, path_leg_y_m = [], []

        current_phi_rad_for_leg = initial_phi_rad

        # Solve for sin(alpha) profile first
        sin_alpha_profile_full = self._solve_non_geodesic_sin_alpha_profile(
            profile_r_m_calc, profile_z_m_calc, initial_sin_alpha_at_leg_start, is_forward_on_profile
        )

        if sin_alpha_profile_full is None:
            print(f"ERROR {leg_number_info}: Failed to solve for sin(alpha) profile.")
            return None

        # Determine the profile indices to iterate over for this leg
        # (This might need adjustment based on where alpha becomes invalid or hits pi/2 if mu is large)
        # For now, assume we use all points where alpha is valid.
        iterable_profile_indices = range(len(profile_r_m_calc)) if is_forward_on_profile else range(len(profile_r_m_calc) - 1, -1, -1)
        
        # Filter for actual leg points (where alpha allows progression)
        # For non-geodesic, c_for_winding isn't strictly used in the same way to define path boundary
        # Instead, alpha itself might reach pi/2 due to friction.
        leg_profile_indices = []
        for k_idx in iterable_profile_indices:
            # If sin_alpha is 1 (alpha=pi/2), it's a turnaround point.
            # The path can proceed as long as alpha is meaningful.
            # We need a condition to stop if alpha becomes too small to maintain path or hits a limit.
            # For now, let's assume the solver gives valid sin_alpha values.
            leg_profile_indices.append(k_idx)
        
        if not is_forward_on_profile:
            leg_profile_indices.reverse()


        if not leg_profile_indices:
            print(f"ERROR {leg_number_info}: No valid profile indices for non-geodesic leg after alpha calculation. Skipping leg.")
            return None
            
        first_point_of_this_leg = True

        for point_counter_in_leg, profile_idx in enumerate(leg_profile_indices):
            rho_current_profile_m = profile_r_m_calc[profile_idx]
            z_current_profile_m = profile_z_m_calc[profile_idx]
            
            current_sin_alpha = sin_alpha_profile_full[profile_idx]
            alpha_current_rad = math.asin(np.clip(current_sin_alpha, -1.0, 1.0))

            if first_point_of_this_leg:
                delta_phi = 0.0
                first_point_of_this_leg = False
            else:
                prev_profile_idx_in_leg = leg_profile_indices[point_counter_in_leg - 1]
                rho_prev_profile_m = profile_r_m_calc[prev_profile_idx_in_leg]
                z_prev_profile_m = profile_z_m_calc[prev_profile_idx_in_leg]
                
                prev_sin_alpha = sin_alpha_profile_full[prev_profile_idx_in_leg]
                alpha_prev_rad = math.asin(np.clip(prev_sin_alpha, -1.0, 1.0))

                d_rho_profile = rho_current_profile_m - rho_prev_profile_m
                d_z_profile = z_current_profile_m - z_prev_profile_m
                ds_segment_m = math.sqrt(d_rho_profile**2 + d_z_profile**2)
                
                delta_phi = 0.0
                if ds_segment_m > 1e-9:
                    rho_avg_segment_m = (rho_current_profile_m + rho_prev_profile_m) / 2.0
                    alpha_avg_segment_rad = (alpha_current_rad + alpha_prev_rad) / 2.0
                    
                    if abs(rho_avg_segment_m) > 1e-8:
                        if abs(math.cos(alpha_avg_segment_rad)) < 1e-9: # alpha_avg is ~90 deg
                            delta_phi = 0.0
                        else:
                            tan_alpha_avg = math.tan(alpha_avg_segment_rad)
                            delta_phi = (ds_segment_m / rho_avg_segment_m) * tan_alpha_avg
                current_phi_rad_for_leg += delta_phi
            
            path_leg_rho_m.append(rho_current_profile_m)
            path_leg_z_m.append(z_current_profile_m)
            path_leg_alpha_rad.append(alpha_current_rad)
            path_leg_phi_rad.append(current_phi_rad_for_leg)
            path_leg_x_m.append(rho_current_profile_m * math.cos(current_phi_rad_for_leg))
            path_leg_y_m.append(rho_current_profile_m * math.sin(current_phi_rad_for_leg))

        if not path_leg_rho_m: return None
        return {
            'rho_m': path_leg_rho_m, 'z_m': path_leg_z_m, 
            'alpha_rad': path_leg_alpha_rad, 'phi_rad': path_leg_phi_rad,
            'x_m': path_leg_x_m, 'y_m': path_leg_y_m
        }

    def generate_non_geodesic_trajectory(self,
                                         initial_alpha_at_first_pole_deg: float, # Angle with meridian
                                         num_points_dome: int = 150,
                                         num_points_cylinder: int = 20,
                                         number_of_passes: int = 1) -> Optional[Dict]:
        """
        Generates a non-geodesic trajectory using the defined mu_friction_coefficient.
        The initial_alpha_at_first_pole_deg defines the starting winding angle (with meridian).
        """
        if self.vessel.profile_points is None: return None
        if self.mu_friction_coefficient == 0:
            print("INFO: mu_friction_coefficient is 0. Generating geodesic trajectory instead.")
            # Need to decide which Clairaut's constant to use if mu=0.
            # If target_cylinder_angle was set, use that. Otherwise, use c_eff.
            if self.clairauts_constant_for_path_m is None:
                self.clairauts_constant_for_path_m = self.effective_polar_opening_radius_m
            return self.generate_geodesic_trajectory(num_points_dome, num_points_cylinder, number_of_passes)

        print(f"\nDEBUG generate_non_geodesic_trajectory: mu={self.mu_friction_coefficient:.3f}, initial_alpha_pole={initial_alpha_at_first_pole_deg:.2f}°")

        initial_sin_alpha = math.sin(math.radians(initial_alpha_at_first_pole_deg))

        # ... (profile_r_m_calc, profile_z_m_calc generation as in geodesic method) ...
        profile_r_m_orig = self.vessel.profile_points['r_inner'] * 1e-3
        profile_z_m_orig = self.vessel.profile_points['z'] * 1e-3
        # ... (adaptive resampling logic as in generate_geodesic_trajectory to get profile_r_m_calc, profile_z_m_calc)
        segments = self._identify_vessel_segments(profile_r_m_orig, profile_z_m_orig)
        adaptive_r_segments, adaptive_z_segments = [], []
        if segments['has_cylinder']:
            fwd_dome_r, fwd_dome_z = self._resample_segment_adaptive(profile_r_m_orig[0:segments['fwd_dome_end']+1], profile_z_m_orig[0:segments['fwd_dome_end']+1], num_points_dome)
            cyl_r, cyl_z = self._resample_segment_adaptive(profile_r_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], profile_z_m_orig[segments['cylinder_start']:segments['cylinder_end']+1], num_points_cylinder)
            aft_dome_r, aft_dome_z = self._resample_segment_adaptive(profile_r_m_orig[segments['aft_dome_start']:], profile_z_m_orig[segments['aft_dome_start']:], num_points_dome)
            if len(fwd_dome_r)>0: adaptive_r_segments.append(fwd_dome_r); adaptive_z_segments.append(fwd_dome_z)
            if len(cyl_r)>1: adaptive_r_segments.append(cyl_r[1:]); adaptive_z_segments.append(cyl_z[1:])
            if len(aft_dome_r)>1: adaptive_r_segments.append(aft_dome_r[1:]); adaptive_z_segments.append(aft_dome_z[1:])
        else:
            dome_r_resampled, dome_z_resampled = self._resample_segment_adaptive(profile_r_m_orig, profile_z_m_orig, num_points_dome * 2)
            if len(dome_r_resampled)>0: adaptive_r_segments.append(dome_r_resampled); adaptive_z_segments.append(dome_z_resampled)
        if not adaptive_r_segments : return None
        profile_r_m_calc = np.concatenate(adaptive_r_segments)
        profile_z_m_calc = np.concatenate(adaptive_z_segments)
        if len(profile_r_m_calc) < 2: return None


        full_path_rho_m, full_path_z_m, full_path_alpha_rad, full_path_phi_rad_cumulative = [], [], [], []
        full_path_x_m, full_path_y_m = [], []
        
        current_phi_rad = 0.0
        current_sin_alpha_for_leg_start = initial_sin_alpha

        for leg_idx in range(number_of_passes * 2):
            is_forward_on_profile_this_leg = (leg_idx % 2 == 0)
            leg_info_str = f"NonGeoLeg {leg_idx + 1}"

            leg_data = self._generate_non_geodesic_leg(
                profile_r_m_calc, profile_z_m_calc,
                current_sin_alpha_for_leg_start,
                current_phi_rad,
                is_forward_on_profile_this_leg,
                leg_info_str
            )
            if not leg_data or not leg_data['phi_rad']: return None
            
            full_path_rho_m.extend(leg_data['rho_m'])
            full_path_z_m.extend(leg_data['z_m'])
            full_path_alpha_rad.extend(leg_data['alpha_rad'])
            full_path_phi_rad_cumulative.extend(leg_data['phi_rad'])
            full_path_x_m.extend(leg_data['x_m'])
            full_path_y_m.extend(leg_data['y_m'])

            current_phi_rad = leg_data['phi_rad'][-1]
            current_sin_alpha_for_leg_start = math.sin(leg_data['alpha_rad'][-1]) # Start next leg with end alpha of this one

            # --- Add Turnaround (simplified for non-geodesic for now) ---
            if leg_idx < (number_of_passes * 2) -1 :
                z_pole_for_turnaround = leg_data['z_m'][-1]
                rho_at_turnaround = leg_data['rho_m'][-1] # Actual radius where turn occurs
                
                advancement_angle_rad_turnaround = math.pi / 16 # Placeholder
                
                turnaround_segment_points = self._generate_polar_turnaround_segment_fixed_phi_advance(
                    c_eff=rho_at_turnaround, # Turnaround at actual last rho
                    z_pole=z_pole_for_turnaround,
                    phi_start=current_phi_rad,
                    fixed_phi_advance_rad=advancement_angle_rad_turnaround,
                    num_turn_points=max(5, num_points_dome // 20) 
                )
                # ... (append turnaround points as in geodesic method) ...
                if turnaround_segment_points:
                    start_idx_turn = 0 # ... (logic to skip duplicate point) ...
                    for pt in turnaround_segment_points[start_idx_turn:]:
                        full_path_rho_m.append(pt['rho']); full_path_z_m.append(pt['z']); # etc.
                        full_path_alpha_rad.append(pt['alpha']); full_path_phi_rad_cumulative.append(pt['phi']);
                        full_path_x_m.append(pt['x']); full_path_y_m.append(pt['y']);
                    current_phi_rad = full_path_phi_rad_cumulative[-1]
                    # For non-geodesic, the alpha after turnaround needs careful thought.
                    # Assuming it starts the next leg with the alpha it ended the previous leg with
                    # OR it could be forced to a specific alpha if friction allows.
                    # For now, current_sin_alpha_for_leg_start is set from end of helical.

        # ... (Construct output_path_points and return dictionary as in geodesic method) ...
        if not full_path_rho_m: return None
        # ... (update self.alpha_profile_deg etc.)
        return {
            'path_points': [...], # Similar structure
            'pattern_type': 'NonGeodesic_SequentialLegs',
            'mu_friction_coefficient_used': self.mu_friction_coefficient,
            # ... other relevant outputs ...
        }

Key Implementation Points for Non-Geodesic:

_get_surface_properties_at_profile_index:

This helper is now crucial. It needs to calculate E, G, E_prime_dz (which is d(ρ²)/dz = 2ρ * dρ/dz), k_m, and k_p at each point on the profile.
Calculating derivatives (dρ/dz, d²ρ/dz²) from discrete profile points (profile_r_m, profile_z_m) needs robust numerical differentiation (e.g., central differences, Savitzky-Golay filter if noisy, or spline fitting then differentiating the spline). The current placeholder logic for derivatives is very basic and will be a source of inaccuracy, especially for d²ρ/dz².
Crucially, the independent variable for Koussios's equation is t (arc length s or a parameter defining the meridian). If we use z as the integration variable, the derivatives E', G', k_m, k_p must all be with respect to z. My helper _get_surface_properties_at_profile_index attempts this by calculating dρ/dz and d²ρ/dz².
Handle vertical tangents (dρ/dz -> inf) carefully. G would become infinite. At such points, k_m might be better defined by d²z/dρ², and k_p = 1/ρ.
_solve_non_geodesic_sin_alpha_profile:

This method will integrate the Riccati equation for sin(α).
Integration Variable: The current code attempts to integrate d(sin α)/dz. This means all coefficients A_coeff, B_coeff, C_coeff must be functions of z (derived via props = self._get_surface_properties_at_profile_index(...)).
Numerical Method: A simple Euler step is shown. For better accuracy and stability, a higher-order method like RK4 is recommended. This would require evaluating the derivative function at intermediate z points, meaning _get_surface_properties_at_profile_index would need to interpolate properties at arbitrary z values between the discrete profile points. This is a significant step up in complexity.
Initial Condition: initial_sin_alpha is given. For a pole-to-pole path, you might start with sin α = 1 (i.e., α = 90°) at one pole and integrate towards the other.
The direction of integration (is_forward_on_profile) determines how dz_step is calculated and how the loop progresses.
_generate_non_geodesic_leg:

Calls _solve_non_geodesic_sin_alpha_profile to get sin_alpha at each profile point.
Converts sin_alpha to alpha_rad.
Calculates delta_phi using the now varying alpha_rad along the path (same formula as geodesic: delta_phi = (ds / rho_avg) * tan(alpha_avg)).
generate_non_geodesic_trajectory (Orchestrator):

Takes an initial_alpha_at_first_pole_deg.
Calls _generate_non_geodesic_leg for each leg.
Handles turnarounds. For non-geodesic, the turnaround logic might be more complex as the fiber doesn't just turn at a fixed c_eff. It turns where alpha naturally reaches 90° due to friction and geometry, or where it's forced by the mandrel shape. The concept of rho_at_turnaround is used.
Next Steps & Challenges:

Robust Numerical Differentiation: The accuracy of _get_surface_properties_at_profile_index (especially d²ρ/dz² for k_m) is critical. Consider using numpy.gradient for first derivatives and then again for second, or fitting splines to profile_r_m(profile_z_m) and differentiating analytically. Be mindful of non-uniform z spacing.
RK4 Implementation: For _solve_non_geodesic_sin_alpha_profile, implement a proper RK4 solver. This will require the ability to get surface properties (E, G, E', k_m, k_p) at any z between profile points (interpolation).
Turnaround Logic for Non-Geodesic: When alpha reaches pi/2 (or sin_alpha = 1), that's the natural turnaround for a non-geodesic path. The "polar opening" concept is less about a fixed radius and more about where the winding angle itself dictates the turn. The _generate_polar_turnaround_segment_fixed_phi_advance might still be used, but c_eff would be the actual rho where alpha hit 90 degrees.
Full Coverage with Non-Geodesics: Pattern theory for non-geodesics is more complex because Delta_Phi_tot_rad (the net azimuthal advance per circuit) will depend on μ and the initial winding conditions, not just a Clairaut constant. This is an advanced topic. The "option for full coverage" likely refers to achieving it with geodesic paths first.
Suggestion:
Let's first focus on getting _get_surface_properties_at_profile_index to be as robust as possible, especially the derivative calculations. Then, we can implement the RK4 solver for _solve_non_geodesic_sin_alpha_profile.