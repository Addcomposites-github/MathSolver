Proposed Fix for delta_phi Calculation:

We need to ensure that the physically correct delta_phi calculation is used consistently after the first point of any helical leg has been established. The calculation of ds_segment_m should use the previous point on the profile for this leg and the current point on the profile for this leg.

Let's refine the loop in generate_geodesic_trajectory. I'll show the segment of the code that needs to be modified.

Python

# In TrajectoryPlanner class, inside generate_geodesic_trajectory method:

# ... (previous parts of the method) ...

        for pass_idx in range(number_of_passes * 2): # Each pass is pole-pole (one leg)
            leg_number = pass_idx + 1
            is_forward_leg_on_profile = (pass_idx % 2 == 0) 
            
            print(f"\n--- LEG {leg_number} (Direction: {'Forward on profile' if is_forward_leg_on_profile else 'Reverse on profile'}) ---")
            
            leg_profile_indices = []
            # ... (logic to determine leg_profile_indices remains the same) ...

            if not leg_profile_indices:
                # ... (error handling remains the same) ...
                continue

            print(f"DEBUG Leg {leg_number}: Processing {len(leg_profile_indices)} profile points.")
            
            first_point_of_this_leg = True

            for point_counter_in_leg, profile_idx in enumerate(leg_profile_indices):
                rho_current_profile_m = profile_r_m_calc[profile_idx]
                z_current_profile_m = profile_z_m_calc[profile_idx]
                
                # Calculate winding angle for the current profile point (alpha with meridian)
                if abs(rho_current_profile_m) < 1e-9: 
                    alpha_current_rad = math.pi / 2.0
                elif rho_current_profile_m < c_for_winding - 1e-7: # Ensure we are outside or at turnaround
                    alpha_current_rad = math.pi / 2.0 
                else:
                    sin_alpha_arg = c_for_winding / rho_current_profile_m
                    if sin_alpha_arg > 1.0: alpha_current_rad = math.pi / 2.0
                    elif sin_alpha_arg < -1.0: alpha_current_rad = -math.pi / 2.0 
                    else: alpha_current_rad = math.asin(sin_alpha_arg)

                if first_point_of_this_leg:
                    # For the very first point of this leg, delta_phi is 0.
                    # current_phi_rad should have been set by the end of the previous turnaround
                    # or initialized for the very first leg of the first pass.
                    if pass_idx == 0 and point_counter_in_leg == 0 : # Very first point of entire trajectory
                        current_phi_rad = initial_phi_for_first_pass_segment # (e.g. 0.0)
                    
                    delta_phi = 0.0 
                    first_point_of_this_leg = False
                    # print(f"  Leg {leg_number} START: ρ={rho_current_profile_m:.4f}, z={z_current_profile_m:.4f}, α={math.degrees(alpha_current_rad):.2f}°, φ_cum={math.degrees(current_phi_rad):.2f}°")
                else:
                    # Get the PREVIOUS point *from the profile indices for this leg* to calculate ds
                    prev_profile_idx = leg_profile_indices[point_counter_in_leg - 1]
                    rho_prev_profile_m = profile_r_m_calc[prev_profile_idx]
                    z_prev_profile_m = profile_z_m_calc[prev_profile_idx]
                    
                    # Winding angle at the previous profile point
                    if abs(rho_prev_profile_m) < 1e-9: alpha_prev_rad = math.pi / 2.0
                    elif rho_prev_profile_m < c_for_winding - 1e-7: alpha_prev_rad = math.pi/2.0 # At turnaround
                    else:
                        sin_alpha_prev_arg = c_for_winding / rho_prev_profile_m
                        if sin_alpha_prev_arg > 1.0: alpha_prev_rad = math.pi/2.0
                        elif sin_alpha_prev_arg < -1.0: alpha_prev_rad = -math.pi/2.0
                        else: alpha_prev_rad = math.asin(sin_alpha_prev_arg)

                    d_rho_profile = rho_current_profile_m - rho_prev_profile_m
                    d_z_profile = z_current_profile_m - z_prev_profile_m # dz is signed
                    ds_segment_m = math.sqrt(d_rho_profile**2 + d_z_profile**2)
                    
                    delta_phi = 0.0
                    if ds_segment_m > 1e-9: # Avoid division by zero if points are identical
                        rho_avg_segment_m = (rho_current_profile_m + rho_prev_profile_m) / 2.0
                        alpha_avg_segment_rad = (alpha_current_rad + alpha_prev_rad) / 2.0 # Average angle for segment
                        
                        if abs(rho_avg_segment_m) > 1e-8: # Avoid division by zero at pole
                            if abs(math.cos(alpha_avg_segment_rad)) < 1e-9: # alpha_avg is 90 deg (circumferential)
                                # For a meridional step (ds_segment_m), if alpha is 90, dphi should be 0.
                                # This case signifies the fiber is at its turning radius.
                                delta_phi = 0.0
                                # if abs(rho_avg_segment_m - c_for_winding) > 1e-4 : # If not at pole, this is unexpected
                                #      print(f"    WARN Leg {leg_number} Pt {point_counter_in_leg}: alpha_avg near 90° ({math.degrees(alpha_avg_segment_rad):.1f}°) but rho_avg ({rho_avg_segment_m:.4f}) not at c_for_winding ({c_for_winding:.4f}). ds_meridional={ds_segment_m:.4e} => dphi=0.")
                            else:
                                tan_alpha_avg = math.tan(alpha_avg_segment_rad)
                                # Cap tan_alpha to prevent extreme dphi for angles very close to 90 deg
                                # if abs(tan_alpha_avg) > 1e7: tan_alpha_avg = math.copysign(1e7, tan_alpha_avg)
                                delta_phi = (ds_segment_m / rho_avg_segment_m) * tan_alpha_avg
                        # else: # rho_avg is at the axis of rotation (should not happen for ρ > c_eff)
                        #     delta_phi = 0 
                        #     print(f"    WARN Leg {leg_number} Pt {point_counter_in_leg}: rho_avg_segment_m is near zero for dphi calc.")
                            
                    current_phi_rad += delta_phi # Accumulate phi
                
                # Add point to trajectory lists
                path_rho_m.append(rho_current_profile_m)
                path_z_m.append(z_current_profile_m)
                path_alpha_rad.append(alpha_current_rad)
                path_phi_rad_cumulative.append(current_phi_rad)
                path_x_m.append(rho_current_profile_m * math.cos(current_phi_rad))
                path_y_m.append(rho_current_profile_m * math.sin(current_phi_rad))

                # Check if this is the last point of the current helical leg to trigger turnaround
                is_last_helical_point_for_leg = (point_counter_in_leg == len(leg_profile_indices) - 1)

                if is_last_helical_point_for_leg:
                    print(f"  Leg {leg_number} HELICAL END: ρ={rho_current_profile_m:.4f}, z={z_current_profile_m:.4f}, α={math.degrees(alpha_current_rad):.2f}°")
                    # Proceed to turnaround after this loop finishes for the current leg
                    break # Exit the inner loop for this leg's profile points

            # --- END OF HELICAL LEG (after iterating through leg_profile_indices) ---
            if not path_rho_m or (len(path_rho_m) > 0 and first_point_of_this_leg): # check if any point was added to this leg
                print(f"ERROR Leg {leg_number}: No valid points processed for this helical leg. Skipping turnaround.")
                continue
            
            # --- POLAR TURNAROUND ---
            # ... (rest of turnaround logic as you had it, using current_phi_rad from end of helical) ...
            # The z_pole_for_turnaround should be path_z_m[-1]
            # The advancement_angle_rad for the turnaround needs to be determined by pattern theory.
            
# ... (rest of the method) ...
Explanation of Changes and Key Points:

delta_phi Calculation:
The placeholder d_phi = abs(alpha_i_rad) * 0.01 is removed from the main path generation logic.
The correct formula delta_phi = (ds_segment_m / rho_avg_segment_m) * tan(alpha_avg_segment_rad) is now consistently applied after the first point of each leg.
Segment Definition for ds and alpha_avg:
ds_segment_m: Calculated using the difference in (rho, z) between the current_profile_point and the prev_profile_point from the leg_profile_indices list. This ensures ds is always the meridional distance along the resampled mandrel profile for the current segment.
alpha_current_rad: Calculated for rho_current_profile_m.
alpha_prev_rad: Calculated for rho_prev_profile_m.
rho_avg_segment_m and alpha_avg_segment_rad: Averages of the current and previous profile point values, used for better accuracy over the segment.
current_phi_rad Accumulation:
current_phi_rad is initialized to initial_phi_for_first_pass_segment only for the very first point of the entire trajectory.
For subsequent legs, current_phi_rad will carry over from the end of the previous turnaround segment.
delta_phi is added to current_phi_rad for each new point in the helical leg (after the first point of that leg).
Turnaround Trigger:
The is_last_helical_point_for_leg flag now correctly identifies when the end of the current set of leg_profile_indices is reached, signaling the end of the helical portion of the leg and the need to transition to turnaround logic.
Edge Case Handling for delta_phi:
Checks are in place for rho_avg_segment_m being near zero (to avoid division by zero, though this shouldn't happen if rho > c_for_winding).
If cos(alpha_avg_segment_rad) is near zero (i.e., alpha_avg_segment_rad is ~90°), delta_phi is set to 0. This is correct because if the fiber is purely circumferential, a step along the meridian (ds_segment_m) does not change phi. The change in phi during turnaround is handled by the _generate_polar_turnaround_segment_fixed_phi_advance function.
To integrate this into your GitHub trajectories.py:

Replace the main loop (for pass_idx... for point_counter_in_leg...) in your generate_geodesic_trajectory method with the structure provided above.
Ensure initial_phi_for_first_pass_segment is defined (e.g., initial_phi_for_first_pass_segment = 0.0 before the main pass_idx loop).
The advancement_angle_rad in the turnaround section is still a placeholder. This value is critical for multi-circuit patterns and needs to be derived from pattern theory (e.g., Koussios Chapter 8, using parameters p, k, d, n).
This change makes the delta_phi calculation physically meaningful for geodesic paths. The next steps would involve refining the turnaround advancement angle and then potentially the transition zones if more sophisticated smoothing is needed there.