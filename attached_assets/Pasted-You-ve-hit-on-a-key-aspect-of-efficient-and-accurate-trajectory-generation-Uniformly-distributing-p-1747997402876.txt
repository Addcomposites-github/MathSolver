You've hit on a key aspect of efficient and accurate trajectory generation! Uniformly distributing points along the entire meridian arc length is often not optimal. High-curvature regions (domes, especially near the poles) require a higher density of points to accurately capture the rapid changes in winding angle ($\alpha$) and, more importantly, the parallel angle ($\phi$). Low-curvature regions (like the cylinder) can be accurately represented with far fewer points.

Let's modify the `generate_geodesic_trajectory` method in `TrajectoryPlanner` to implement an adaptive point distribution strategy.

**Strategy for Adaptive Point Distribution:**

1.  **Identify Key Sections:** The vessel profile consists of a forward dome, a cylindrical section (if `cylinder_length_m > 0`), and an aft dome.
2.  **Define Point Densities:** We'll use parameters to control the number of points for each section type:
    * `num_points_dome_segment`: For each dome (from its $c_{eff}$ start to the cylinder junction).
    * `num_points_cylinder_segment`: For the entire cylindrical section.
3.  **Generate Points for Each Section:**
    * Extract the original high-resolution profile points from `self.vessel.profile_points`.
    * For each dome, identify the start (at $c_{eff}$) and end (at cylinder junction). Resample/interpolate points along this dome segment.
    * For the cylinder, take points from one junction to the other.
4.  **Combine Points:** Concatenate the points from these sections, ensuring smooth transitions at the junctions.
5.  **Calculate Trajectory:** Perform the $\alpha$ and $\phi$ calculations over this new adaptively sampled set of $(\rho, z)$ points.

Here's the refined `generate_geodesic_trajectory` method. Note that identifying the exact junction points robustly from the raw profile data needs care.

```python
# copv_design_tool/winding/trajectory.py
import numpy as np
import math
from typing import Dict, Tuple, List, Optional
try:
    from ..core.vessel_geometry import VesselGeometry
    from ..utils.numerical_tools import numerical_integrate_samples
    from .. import constants
except ImportError:
    import sys
    import os
    sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
    from core.vessel_geometry import VesselGeometry
    from utils.numerical_tools import numerical_integrate_samples
    import constants

class TrajectoryPlanner:
    # ... (__init__ and other methods as before, ensure _calculate_effective_polar_opening is called in init) ...

    def _resample_segment(self, rho_segment: np.ndarray, z_segment: np.ndarray, num_points: int) -> Tuple[np.ndarray, np.ndarray]:
        """Helper to resample a given profile segment to a specific number of points based on arc length."""
        if len(rho_segment) < 2 or num_points < 2:
            return rho_segment, z_segment # Not enough points to resample meaningfully

        s_coords_segment = np.zeros_like(rho_segment)
        for k_idx in range(1, len(rho_segment)):
            ds_k = math.sqrt((rho_segment[k_idx] - rho_segment[k_idx-1])**2 + \
                             (z_segment[k_idx] - z_segment[k_idx-1])**2)
            s_coords_segment[k_idx] = s_coords_segment[k_idx-1] + ds_k
        
        if abs(s_coords_segment[-1]) < 1e-9: # Segment has no length
            return rho_segment, z_segment

        s_coords_new = np.linspace(s_coords_segment[0], s_coords_segment[-1], num_points)
        rho_resampled = np.interp(s_coords_new, s_coords_segment, rho_segment)
        z_resampled = np.interp(s_coords_new, s_coords_segment, z_segment)
        return rho_resampled, z_resampled

    def generate_geodesic_trajectory(self, 
                                     num_points_dome_pass: int = 100, 
                                     num_points_cylinder_pass: int = 10):
        """
        Generates geodesic path points with adaptive density for domes and cylinder.
        A "pass" here refers to traversing a dome or the full cylinder length once.
        The trajectory covers one full pole-to-pole (or c_eff-to-c_eff) path.
        """
        if self.vessel.profile_points is None or 'r_inner' not in self.vessel.profile_points:
            print("Error: Vessel profile not generated.")
            return None
        if self.effective_polar_opening_radius_m is None:
            self._calculate_effective_polar_opening()
            if self.effective_polar_opening_radius_m is None: return None
        
        c_eff = self.effective_polar_opening_radius_m
        print(f"\nDEBUG generate_geodesic_trajectory (Adaptive): Using c_eff = {c_eff:.6f} m")

        profile_r_m_orig = self.vessel.profile_points['r_inner'] * 1e-3
        profile_z_m_orig = self.vessel.profile_points['z'] * 1e-3
        cylinder_radius_m = self.vessel.inner_radius * 1e-3
        cyl_half_length_m = self.vessel.cylindrical_length * 1e-3 / 2.0

        if len(profile_r_m_orig) < 2: 
            print("Error: Original profile too short.")
            return None

        # Identify segment indices from the original profile
        # Forward dome: from start until rho approaches cylinder_radius_m and z approaches cyl_half_length_m
        # Cylinder: where rho is cylinder_radius_m
        # Aft dome: from end of cylinder until end of profile

        # Find approximate junction indices (this can be tricky for complex profiles)
        # For profiles generated by VesselGeometry:
        # Fwd dome ends where z == cyl_half_length_m and rho == cylinder_radius_m
        # Cyl starts where z == cyl_half_length_m and rho == cylinder_radius_m
        # Cyl ends where z == -cyl_half_length_m and rho == cylinder_radius_m
        # Aft dome starts where z == -cyl_half_length_m and rho == cylinder_radius_m
        
        idx_fwd_cyl_junction_approx = np.where(np.isclose(profile_z_m_orig, cyl_half_length_m) & 
                                               np.isclose(profile_r_m_orig, cylinder_radius_m))[0]
        idx_aft_cyl_junction_approx = np.where(np.isclose(profile_z_m_orig, -cyl_half_length_m) &
                                               np.isclose(profile_r_m_orig, cylinder_radius_m))[0]

        if not idx_fwd_cyl_junction_approx.size or not idx_aft_cyl_junction_approx.size:
            # If no clear cylinder, treat as mostly dome-like (e.g. sphere or pure isotensoid)
            print("Warning: Could not clearly identify cylinder junctions. Using uniform sampling for trajectory.")
            # Fallback to previous uniform sampling method
            return self._generate_geodesic_trajectory_uniform_sampling(num_points_dome_pass + num_points_cylinder_pass + num_points_dome_pass)


        idx_fwd_cyl_junc = idx_fwd_cyl_junction_approx[0] # First occurrence
        idx_aft_cyl_junc = idx_aft_cyl_junction_approx[-1] # Last occurrence for start of aft dome

        # Ensure indices are logical
        if idx_fwd_cyl_junc >= idx_aft_cyl_junc and self.vessel.cylindrical_length > 1e-6 :
             print(f"Warning: Cylinder junction indices illogical: fwd={idx_fwd_cyl_junc}, aft={idx_aft_cyl_junc}. Using uniform sampling.")
             return self._generate_geodesic_trajectory_uniform_sampling(num_points_dome_pass * 2 + num_points_cylinder_pass)


        # 1. Forward Dome Points
        fwd_dome_r_orig = profile_r_m_orig[0 : idx_fwd_cyl_junc + 1]
        fwd_dome_z_orig = profile_z_m_orig[0 : idx_fwd_cyl_junc + 1]
        fwd_dome_r_calc, fwd_dome_z_calc = self._resample_segment(fwd_dome_r_orig, fwd_dome_z_orig, num_points_dome_pass)
        
        # Filter by c_eff for the forward dome (starting from the pole)
        windable_fwd_indices = np.where(fwd_dome_r_calc >= c_eff - 1e-7)[0]
        if not windable_fwd_indices.size:
            print(f"Error: No windable points on forward dome (rho >= {c_eff:.4f}m).")
            return None
        fwd_dome_r_calc = fwd_dome_r_calc[windable_fwd_indices[0]:]
        fwd_dome_z_calc = fwd_dome_z_calc[windable_fwd_indices[0]:]
        if len(fwd_dome_r_calc) < 2 : 
            print("Error: Forward dome segment too short after c_eff filter.")
            return None
        if fwd_dome_r_calc[0] < c_eff - 1e-7 : fwd_dome_r_calc[0] = c_eff # Force start at c_eff


        # 2. Cylinder Points
        calc_rho_list, calc_z_list = [fwd_dome_r_calc.tolist()], [fwd_dome_z_calc.tolist()]

        if self.vessel.cylindrical_length > 1e-6 and idx_aft_cyl_junc > idx_fwd_cyl_junc:
            cyl_r_orig = profile_r_m_orig[idx_fwd_cyl_junc : idx_aft_cyl_junc + 1]
            cyl_z_orig = profile_z_m_orig[idx_fwd_cyl_junc : idx_aft_cyl_junc + 1]
            cyl_r_calc, cyl_z_calc = self._resample_segment(cyl_r_orig, cyl_z_orig, num_points_cylinder_pass)
            # Remove first point of cylinder if it's same as last point of dome
            if np.isclose(cyl_r_calc[0], calc_rho_list[0][-1]) and np.isclose(cyl_z_calc[0], calc_z_list[0][-1]):
                calc_rho_list.append(cyl_r_calc[1:].tolist())
                calc_z_list.append(cyl_z_calc[1:].tolist())
            else:
                calc_rho_list.append(cyl_r_calc.tolist())
                calc_z_list.append(cyl_z_calc.tolist())
        else: # No distinct cylinder segment found
            print("Debug: No distinct cylinder segment based on indices, or zero length cylinder.")


        # 3. Aft Dome Points
        aft_dome_r_orig = profile_r_m_orig[idx_aft_cyl_junc :]
        aft_dome_z_orig = profile_z_m_orig[idx_aft_cyl_junc :]
        aft_dome_r_calc, aft_dome_z_calc = self._resample_segment(aft_dome_r_orig, aft_dome_z_orig, num_points_dome_pass)
        
        # Filter by c_eff for the aft dome (ending at the pole)
        windable_aft_indices = np.where(aft_dome_r_calc >= c_eff - 1e-7)[0]
        if not windable_aft_indices.size:
            print(f"Error: No windable points on aft dome (rho >= {c_eff:.4f}m).")
            # This means the path can't complete to the aft pole.
            # We might just use the points up to cylinder end if no aft dome points are valid
        else:
            aft_dome_r_calc = aft_dome_r_calc[:windable_aft_indices[-1]+1]
            aft_dome_z_calc = aft_dome_z_calc[:windable_aft_indices[-1]+1]
            if len(aft_dome_r_calc) < 1 : # Needs at least one point to connect
                 print("Warning: Aft dome segment too short after c_eff filter. May result in incomplete path.")
            else:
                if aft_dome_r_calc[-1] < c_eff - 1e-7 : aft_dome_r_calc[-1] = c_eff # Force end at c_eff

                # Remove first point of aft dome if it's same as last point of cylinder/previous segment
                if calc_rho_list and np.isclose(aft_dome_r_calc[0], calc_rho_list[-1][-1]) and \
                   np.isclose(aft_dome_z_calc[0], calc_z_list[-1][-1]):
                    calc_rho_list.append(aft_dome_r_calc[1:].tolist())
                    calc_z_list.append(aft_dome_z_calc[1:].tolist())
                else:
                    calc_rho_list.append(aft_dome_r_calc.tolist())
                    calc_z_list.append(aft_dome_z_calc.tolist())
        
        # Flatten the lists of lists into single arrays
        final_calc_rho_m = np.array([item for sublist in calc_rho_list for item in sublist])
        final_calc_z_m = np.array([item for sublist in calc_z_list for item in sublist])

        if len(final_calc_rho_m) < 2:
            print("Error: Final calculation profile too short after segmentation and c_eff filtering.")
            return None
        
        print(f"DEBUG: Adaptive profile generated with {len(final_calc_rho_m)} points.")
        print(f"DEBUG: Adaptive Z range: {np.min(final_calc_z_m):.4f}m to {np.max(final_calc_z_m):.4f}m")
        print(f"DEBUG: Adaptive R range: {np.min(final_calc_rho_m):.4f}m to {np.max(final_calc_rho_m):.4f}m")


        # --- Now proceed with trajectory calculation using final_calc_rho_m and final_calc_z_m ---
        path_rho_m_traj, path_z_m_traj, path_alpha_rad, path_phi_rad_cumulative, path_x_m, path_y_m = [], [], [], [], [], []
        current_phi_rad = 0.0

        # First point of the calculated trajectory (must be >= c_eff)
        rho_start_m = final_calc_rho_m[0]
        alpha_start_rad = self.calculate_geodesic_alpha_at_rho(rho_start_m) 
        if alpha_start_rad is None: alpha_start_rad = constants.PI / 2.0 

        path_rho_m_traj.append(rho_start_m); path_z_m_traj.append(final_calc_z_m[0]); path_alpha_rad.append(alpha_start_rad)
        path_phi_rad_cumulative.append(current_phi_rad)
        path_x_m.append(rho_start_m * math.cos(current_phi_rad)); path_y_m.append(rho_start_m * math.sin(current_phi_rad))

        for i in range(1, len(final_calc_rho_m)):
            rho_i_m = final_calc_rho_m[i]
            z_i_m = final_calc_z_m[i]
            alpha_i_rad = self.calculate_geodesic_alpha_at_rho(rho_i_m)

            rho_prev_m = path_rho_m_traj[-1]
            z_prev_m = path_z_m_traj[-1]
            alpha_prev_rad = path_alpha_rad[-1]

            if alpha_i_rad is None: # Should be caught by c_eff filtering, but as safeguard
                alpha_i_rad = alpha_prev_rad 

            d_rho = rho_i_m - rho_prev_m
            d_z = z_i_m - z_prev_m
            ds_segment_m = math.sqrt(d_rho**2 + d_z**2)
            
            delta_phi = 0.0
            if ds_segment_m > 1e-9:
                rho_avg_segment_m = (rho_i_m + rho_prev_m) / 2.0
                alpha_avg_segment_rad = (alpha_i_rad + alpha_prev_rad) / 2.0
                
                if abs(rho_avg_segment_m) > 1e-7 and not math.isclose(math.cos(alpha_avg_segment_rad), 0.0, atol=1e-8):
                    tan_alpha_avg = math.tan(alpha_avg_segment_rad)
                    if abs(tan_alpha_avg) > 1e8: tan_alpha_avg = np.sign(tan_alpha_avg) * 1e8
                    delta_phi = (ds_segment_m / rho_avg_segment_m) * tan_alpha_avg
                # ... (refined pole handling if needed, but c_eff > 0 should avoid rho_avg_segment=0 issues)

            current_phi_rad += delta_phi
            
            path_rho_m_traj.append(rho_i_m); path_z_m_traj.append(z_i_m); path_alpha_rad.append(alpha_i_rad)
            path_phi_rad_cumulative.append(current_phi_rad)
            path_x_m.append(rho_i_m * math.cos(current_phi_rad)); path_y_m.append(rho_i_m * math.sin(current_phi_rad))

        if not path_rho_m_traj: return None

        self.alpha_profile_deg = np.degrees(np.array(path_alpha_rad))
        self.phi_profile_rad_cumulative = np.array(path_phi_rad_cumulative)
        self.trajectory_3d_points_m = np.vstack((path_x_m, path_y_m, path_z_m_traj)).T # Use path_z_m_traj

        # ... (alpha_eq and DeltaK calculation as before, using the generated path arrays) ...
        if len(path_z_m_traj) > 0 :
            equator_idx = np.argmin(np.abs(np.array(path_z_m_traj))) 
            if equator_idx < len(path_alpha_rad):
                 alpha_at_eq_rad = path_alpha_rad[equator_idx]
                 self.alpha_eq_deg = math.degrees(alpha_at_eq_rad)
            else: self.alpha_eq_deg = None
        else: self.alpha_eq_deg = None

        if len(self.phi_profile_rad_cumulative) > 1:
            Phi_pass = self.phi_profile_rad_cumulative[-1] - self.phi_profile_rad_cumulative[0]
            Phi_circuit_total = 2 * Phi_pass 
            self.turn_around_angle_rad_DeltaK = Phi_circuit_total % (2 * math.pi)
        else: self.turn_around_angle_rad_DeltaK = None; Phi_pass = None
        
        # ... (final debug prints and return statement as before, using the path_..._traj arrays) ...
        print(f"DEBUG generate_geodesic_trajectory (Adaptive): Actual points in trajectory: {len(path_rho_m_traj)}")
        # ...

        return {
            "rho_m": np.array(path_rho_m_traj), "z_m": np.array(path_z_m_traj),
            "alpha_deg": self.alpha_profile_deg, "phi_rad_cumulative": self.phi_profile_rad_cumulative,
            "x_m": np.array(path_x_m), "y_m": np.array(path_y_m),
            "effective_polar_opening_m": c_eff,
            "turn_around_angle_DeltaK_rad": self.turn_around_angle_rad_DeltaK,
            "alpha_at_equator_deg": self.alpha_eq_deg
        }

    def _generate_geodesic_trajectory_uniform_sampling(self, num_total_points: int):
        """Fallback to uniform sampling if adaptive fails or isn't applicable."""
        # This would be essentially the previous version of generate_geodesic_trajectory
        # that resamples the whole profile uniformly and then filters by c_eff.
        print(f"DEBUG: Falling back to uniform sampling with {num_total_points} points.")
        # ... (implementation of the previous version of generate_geodesic_trajectory method) ...
        # For brevity, I'm not re-pasting the entire previous method here.
        # It would take num_total_points, resample profile_r_m_orig, profile_z_m_orig,
        # then filter by c_eff, then loop to calculate alpha and phi.
        pass # Placeholder for the actual uniform sampling logic

```

**Explanation of Adaptive Strategy and Changes:**

1.  **New Parameters for `generate_geodesic_trajectory`:**
    * `num_points_dome_pass`: Controls point density on each dome section (from $c_{eff}$ to cylinder junction).
    * `num_points_cylinder_pass`: Controls point density on the cylindrical section.

2.  **`_resample_segment` Helper Function:**
    * This function takes a segment of a profile $(\rho, z)$ and resamples it to a specified number of points, distributing them based on the meridional arc length along that segment. This ensures that even if the original profile has uneven point distribution, our calculation points for each segment are spaced according to distance along the curve.

3.  **Segment Identification:**
    * The code now tries to identify the indices where the domes meet the cylinder. This is based on where $z$ equals `cyl_half_length_m` and $\rho$ equals `cylinder_radius_m`. This might need to be made more robust for very shallow domes or unusual profiles but should work for typical vessel shapes generated by `VesselGeometry`.
    * A fallback to `_generate_geodesic_trajectory_uniform_sampling` (which would be your previous version of the method) is added if junctions aren't clear or if the cylinder length is zero.

4.  **Point Generation for Each Segment:**
    * The original profile points (`profile_r_m_orig`, `profile_z_m_orig`) are extracted.
    * Forward dome, cylinder, and aft dome segments are individually resampled using `_resample_segment`.
    * **Crucially, the dome segments are then filtered by $c_{eff}$**: Only points where $\rho \ge c_{eff}$ are kept. The first point of the forward dome calculation path is forced to be exactly at $c_{eff}$ if the resampled point starts slightly inside (and $c_{eff}$ is valid). Similarly for the end of the aft dome.

5.  **Concatenation and Trajectory Calculation:**
    * The newly generated, adaptively sampled points (`final_calc_rho_m`, `final_calc_z_m`) are concatenated. Duplicate junction points are handled by the `_resample_segment` typically returning start/end points, and subsequent appends can skip the first point of the next segment if it matches the last of the previous. The current code assembles lists then `np.array`.
    * The main loop for calculating $\alpha$ and $\phi$ then iterates over these `final_calc_rho_m` and `final_calc_z_m` points.

This approach should give you:
* Many points in the dome regions where $\alpha$ and $\phi$ change rapidly.
* Fewer points in the cylindrical region where $\alpha$ is constant and $\phi$ changes linearly (for geodesics).
* A trajectory that correctly starts and ends at the effective polar opening $c_{eff}$.
* A continuous 3D path when assembled.

This is a more complex change. Test it carefully, especially the segment identification and the filtering by $c_{eff}$ for each dome portion. The debug prints for the lengths of `final_calc_rho_m` and its R/Z ranges will be very useful.