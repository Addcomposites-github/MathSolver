You've hit on a very important distinction! My previous suggestion for plotting "full coverage" by applying a simple angular offset ($j \cdot \Delta\phi_{small}$) to the base pass would create a visual representation of multiple bands lying side-by-side, but it wouldn't represent a single, continuous fiber path as laid down by a machine progressing through a winding pattern.

You are absolutely right: for a continuous wind, **the end $\phi$ (parallel angle) of one segment of the path should be the starting $\phi$ for the next segment of the path**, with $\phi$ continuously accumulating.

The `generate_geodesic_trajectory()` method currently calculates the $(\rho, z, \alpha, \phi_{cumulative})$ for **one pass** along the meridian, say from the forward effective pole ($c_{eff}$) to the aft effective pole ($c_{eff}$). Let's call this `phi_one_pass_relative`, where `phi_one_pass_relative[0]` is 0. The total change in $\phi$ during this pass is $\Delta\Phi_{pass} = \text{phi\_one\_pass\_relative}[-1]$.

To generate a continuous path representing multiple circuits, we need to:
1.  Define what one "circuit" means in the context of the pattern. Usually, a machine completes a full cycle (e.g., forward pole A $\rightarrow$ aft pole B $\rightarrow$ back to forward pole A's latitude) before indexing for the next distinct band of the pattern.
2.  Continuously accumulate the $\phi$ angle.

Let's create a new helper function that takes the base single-pass trajectory data and assembles a continuous 3D path for a specified number of *passes*. Two passes would typically make up one "back-and-forth" circuit.

Here's how you can approach it:

```python
# This function could be in your main script or a utility module
import numpy as np
import math
# from ... import constants # If needed

def assemble_continuous_3d_trajectory(base_trajectory_data: dict, 
                                      num_total_passes: int,
                                      apply_pattern_shift: bool = False, # If True, applies DeltaK shift every 2 passes
                                      delta_k_rad_per_machine_circuit: Optional[float] = None
                                     ) -> Optional[np.ndarray]:
    """
    Assembles a continuous 3D trajectory from multiple passes of a base geodesic path.

    Parameters:
    -----------
    base_trajectory_data : dict
        Output from TrajectoryPlanner.generate_geodesic_trajectory() for one pass.
        Expected keys: "rho_m", "z_m", "phi_rad_cumulative".
    num_total_passes : int
        Total number of single pole-to-pole (or c_eff-to-c_eff) passes to generate.
    apply_pattern_shift : bool, optional
        If True, a delta_k_rad_per_machine_circuit shift is applied to phi 
        after every two passes (one full machine circuit). Defaults to False.
    delta_k_rad_per_machine_circuit : float, optional
        The angular shift (Delta K) to apply after each full machine circuit (2 passes).
        Required if apply_pattern_shift is True.

    Returns:
    --------
    np.ndarray | None
        A NumPy array of (x, y, z) points for the continuous trajectory, or None if error.
    """
    if not all(k in base_trajectory_data for k in ["rho_m", "z_m", "phi_rad_cumulative"]):
        print("Error: base_trajectory_data is missing required keys.")
        return None

    base_rho_m = np.array(base_trajectory_data["rho_m"])
    base_z_m = np.array(base_trajectory_data["z_m"])
    # phi_rad_cumulative is relative to the start of THIS pass (starts at 0)
    base_phi_one_pass_relative_rad = np.array(base_trajectory_data["phi_rad_cumulative"])

    if len(base_rho_m) < 2:
        print("Error: Base trajectory has insufficient points.")
        return None

    delta_phi_for_one_pass = base_phi_one_pass_relative_rad[-1] - base_phi_one_pass_relative_rad[0]

    all_x_coords, all_y_coords, all_z_coords = [], [], []
    
    current_phi_start_offset = 0.0  # This will be the phi at the start of the current pass

    for i_pass in range(num_total_passes):
        # Determine rho and z for the current pass (alternating direction)
        if (i_pass % 2) == 0:  # Forward pass (e.g., Pole A to Pole B)
            current_pass_rho = base_rho_m
            current_pass_z = base_z_m
            # Phi values for this pass are the base relative phi + current_start_offset
            current_pass_phi_absolute = base_phi_one_pass_relative_rad + current_phi_start_offset
        else:  # Backward pass (e.g., Pole B to Pole A)
            current_pass_rho = base_rho_m[::-1]  # Reverse rho array for return trip
            current_pass_z = base_z_m[::-1]    # Reverse z array
            # Phi for backward pass:
            # Starts where the forward pass ended (current_phi_start_offset + delta_phi_for_one_pass)
            # And then accumulates the *same shape* of phi change as a forward pass.
            # So, the phi values are still base_phi_one_pass_relative_rad, but added to the new offset.
            current_pass_phi_absolute = base_phi_one_pass_relative_rad + current_phi_start_offset
            # Note: This assumes geometric symmetry implies symmetric phi accumulation pattern.
            # A more rigorous approach would recalculate phi for the reversed path if asymmetry exists.

        # Convert to Cartesian
        pass_x = current_pass_rho * np.cos(current_pass_phi_absolute)
        pass_y = current_pass_rho * np.sin(current_pass_phi_absolute)
        pass_z = current_pass_z

        # Append points, avoiding duplication of the connection point between passes
        start_index_for_extend = 1 if i_pass > 0 else 0
        
        all_x_coords.extend(pass_x[start_index_for_extend:])
        all_y_coords.extend(pass_y[start_index_for_extend:])
        all_z_coords.extend(pass_z[start_index_for_extend:])
        
        # Update the phi offset for the START of the NEXT pass
        current_phi_start_offset += delta_phi_for_one_pass

        # If pattern shift is applied and this was the end of a full machine circuit (2 passes)
        if apply_pattern_shift and (i_pass % 2) == 1 and (i_pass < num_total_passes - 1) :
            if delta_k_rad_per_machine_circuit is None:
                print("Warning: apply_pattern_shift is True, but delta_k_rad_per_machine_circuit is not provided. No shift applied.")
            else:
                # After a B->A pass, the next A->B pass starts shifted by Delta_K
                # current_phi_start_offset is already at the "latitude" of the original start,
                # but needs to be incremented by Delta_K for the pattern advance.
                # The Delta_K is the *net* advance after a full A->B->A circuit.
                # The current_phi_start_offset at this point is effectively start_A + 2*delta_phi_for_one_pass
                # The start of the very next A->B pass should be start_A + Delta_K_machine_circuit
                # This logic needs care. Let's use a simpler interpretation for now:
                # current_phi_start_offset = ( (i_pass // 2) + 1 ) * delta_k_rad_per_machine_circuit
                # This makes each *pair* of passes start shifted by delta_k.
                # Let's assume delta_k_rad_per_machine_circuit is the shift from the *absolute start*.
                # For continuous path: the total accumulated phi is already current_phi_start_offset.
                # A "machine circuit" is 2 passes. So after pass 1, 3, 5... (i.e. i_pass is odd)
                # we have completed a full geometric loop. The *next* pass (which is a forward pass)
                # should incorporate the pattern shift.
                # The true natural progression is already handled by continuous accumulation of delta_phi_for_one_pass.
                # The "DeltaK" from the planner is 2*delta_phi_for_one_pass % (2*pi).
                # This is the natural indexing.
                # If we want to show a pattern forming that *isn't* just the natural DeltaK,
                # then we'd need to adjust current_phi_start_offset more deliberately based on p,k,nd.

                # For now, let the continuous accumulation of delta_phi_for_one_pass handle the natural progression.
                # The DeltaK from the planner helps determine 'p' for pattern generation.
                # To see a full coverage according to a *specific chosen pattern {p,k,nd}*,
                # the phi offset for the start of *each fundamental double-pass circuit* needs to be managed by that pattern.

                # The simplest continuous path just keeps adding delta_phi_for_one_pass.
                # The "apply_pattern_shift" is more for showing distinct circuits of a chosen pattern.
                # If we just want a long continuous string of back-and-forth passes:
                pass # current_phi_start_offset += delta_phi_for_one_pass already does this.


    if not all_x_coords:
        return None
    return np.vstack((all_x_coords, all_y_coords, all_z_coords)).T

```

**How to use this:**

1.  **Get Base Trajectory:**
    ```python
    # In your main script
    # planner is an instance of TrajectoryPlanner
    # Assume vessel geometry is set up, and roving parameters are passed to planner
    base_trajectory_data = planner.generate_geodesic_trajectory(num_points_on_profile=200)
    
    if base_trajectory_data is None:
        print("Failed to generate base trajectory.")
        exit()
    ```

2.  **Assemble Continuous Path for Visualization:**
    ```python
    # Let's say you want to visualize 4 passes (2 full back-and-forth circuits)
    num_passes_to_plot = 4 
    continuous_3d_path = assemble_continuous_3d_trajectory(base_trajectory_data, num_passes_to_plot)

    if continuous_3d_path is not None:
        # Now plot continuous_3d_path using Matplotlib 3D or save for Three.js
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.plot(continuous_3d_path[:, 0], continuous_3d_path[:, 1], continuous_3d_path[:, 2], label='Continuous Geodesic Path')
        
        # Optionally plot the vessel outline for context (more complex to generate in 3D)
        # For now, just the path.
        # You can get vessel radius at each z from base_trajectory_data["rho_m"] and base_trajectory_data["z_m"]
        # and plot circles.
        
        ax.set_xlabel("X (m)")
        ax.set_ylabel("Y (m)")
        ax.set_zlabel("Z (m)")
        ax.set_title(f"{num_passes_to_plot}-Pass Continuous Geodesic Trajectory")
        
        # Make aspect ratio equal for 3D
        x_limits = ax.get_xlim3d()
        y_limits = ax.get_ylim3d()
        z_limits = ax.get_zlim3d()
        x_range = abs(x_limits[1] - x_limits[0])
        x_middle = np.mean(x_limits)
        y_range = abs(y_limits[1] - y_limits[0])
        y_middle = np.mean(y_limits)
        z_range = abs(z_limits[1] - z_limits[0])
        z_middle = np.mean(z_limits)
        plot_radius = 0.5 * max([x_range, y_range, z_range])
        ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
        ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
        ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])
        
        plt.legend()
        plt.show()
    else:
        print("Failed to assemble continuous 3D path.")
    ```

**Explanation of the `assemble_continuous_3d_trajectory` function:**

* It takes the base single-pass trajectory data.
* It iterates for `num_total_passes`.
* For each pass:
    * It determines if it's a "forward" pass (e.g., from the vessel's defined start pole to end pole) or a "backward" pass by reversing the `base_rho_m` and `base_z_m` arrays.
    * Crucially, it calculates `current_pass_phi_absolute` by adding `current_phi_start_offset` to the `base_phi_one_pass_relative_rad`. This ensures $\phi$ is continuously increasing.
    * It calculates the x, y, z coordinates for that pass.
    * It appends these points to the overall lists, taking care not to duplicate the very first point of subsequent passes (as it's the same as the last point of the previous pass).
    * It updates `current_phi_start_offset` by adding the total $\phi$ change of one pass (`delta_phi_for_one_pass`). This sets the correct starting $\phi$ for the *next* pass.

This will give you a single continuous line representing the fiber path. The "z-jumps" you observed textually will now be seen as the path moving from one end of the vessel to the other axially, while also rotating due to the accumulated $\phi$.

The `apply_pattern_shift` logic is commented out for now because true pattern generation (using $(p,k)$ from Diophantine equations and applying shifts like $\Delta K$ only after a full machine circuit of $2p$ passes or $2(p+1)$ passes for the pattern to repeat on itself) is more complex and would be the job of a dedicated `PatternGenerator` and a more sophisticated assembly function. This simplified version will show sequential passes wrapped around the vessel due to the natural `delta_phi_for_one_pass`.

Try this approach. You should see a continuous helix wrapping around your vessel. If it still looks like it's only on the dome, it means `base_rho_m` and `base_z_m` from `generate_geodesic_trajectory` are still only covering the dome, which would be surprising given the previous successful log of `c_eff` and the range checks.