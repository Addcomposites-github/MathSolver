You're absolutely right, the 3D plot in `image_68259f.png` does not look like a correct or continuous filament winding trajectory. It appears disjointed and isn't forming the expected helical path around the vessel shape.

This indicates there are still fundamental issues in how the trajectory points (specifically the cumulative parallel angle $\phi$) are being calculated in `generate_geodesic_trajectory`, or how these $(\rho, z, \phi)$ points are being converted to $(x,y,z)$ for plotting. The large, seemingly erratic lines suggest that the $\phi$ values might be "jumping" or not accumulating correctly, causing the 3D reconstruction to be wrong.

**Regarding Three.js Visualization:**

That's an excellent idea for the future! Three.js would allow for a much more interactive and detailed 3D visualization, which would be invaluable for debugging complex paths and eventually for visualizing machine kinematics.

However, before we move to a more advanced visualization like Three.js, it's crucial to **ensure the underlying trajectory data itself is correct.** If the $(\rho, z, \phi, \alpha)$ data generated by the Python module is flawed, any visualization tool (Matplotlib, Three.js, etc.) will show a flawed path.

**Let's focus on debugging the `generate_geodesic_trajectory` method further.**

The core of the issue likely lies in the `delta_phi` calculation and accumulation, especially how it behaves across the different sections of the vessel (domes and cylinder) and particularly near the poles.

**Revised Strategy for `generate_geodesic_trajectory`:**

The current approach iterates through the *single combined profile* of the vessel. This can be tricky for `ds_segment` and `dz/drho` calculations right at the cylinder-dome junctions if the points are not perfectly smooth or if the number of points is too low across these transitions.

A more robust approach might be to:
1.  Break down the trajectory calculation into segments: Forward Dome, Cylinder, Aft Dome.
2.  Calculate $\phi$ accumulation for each segment separately, ensuring continuity of $\phi$ at the junctions.
3.  Handle the polar regions with more care, possibly by using a very small starting radius ($c_{eff}$) for the $\phi$ integral on the dome, rather than starting at $\rho=0$ if the geometric profile includes it but $c_{eff} > 0$.

**Let's simplify and refine the `delta_phi` calculation first within the existing loop structure and add more detailed debug prints for $\phi$.**

**Proposed Refinements and Debugging for `generate_geodesic_trajectory`:**

```python
# In TrajectoryPlanner class
    def generate_geodesic_trajectory(self, num_points_on_profile: Optional[int] = 200): # Increased default
        # ... (initial checks and setup as before) ...
        if self.vessel.profile_points is None or 'r_inner' not in self.vessel.profile_points:
            # ... error handling ...
            return None
        if self.effective_polar_opening_radius_m is None:
            self._calculate_effective_polar_opening()
            if self.effective_polar_opening_radius_m is None: return None

        print(f"\nDEBUG generate_geodesic_trajectory: Using c_eff = {self.effective_polar_opening_radius_m:.6f} m")

        profile_r_m_orig = self.vessel.profile_points['r_inner'] * 1e-3
        profile_z_m_orig = self.vessel.profile_points['z'] * 1e-3

        if num_points_on_profile and len(profile_r_m_orig) != num_points_on_profile:
            # Resample the full pole-to-pole profile for a consistent number of points
            # This ensures uniform sampling density for the trajectory calculation itself.
            # We need a parameter that represents distance along the meridian for linspace.
            # Simple approach: use cumulative segment lengths along original profile.
            s_coords_orig = np.zeros_like(profile_r_m_orig)
            for k_idx in range(1, len(profile_r_m_orig)):
                ds_k = math.sqrt((profile_r_m_orig[k_idx] - profile_r_m_orig[k_idx-1])**2 + \
                                 (profile_z_m_orig[k_idx] - profile_z_m_orig[k_idx-1])**2)
                s_coords_orig[k_idx] = s_coords_orig[k_idx-1] + ds_k
            
            s_coords_new = np.linspace(s_coords_orig[0], s_coords_orig[-1], num_points_on_profile)
            profile_r_m = np.interp(s_coords_new, s_coords_orig, profile_r_m_orig)
            profile_z_m = np.interp(s_coords_new, s_coords_orig, profile_z_m_orig)
            print(f"DEBUG: Resampled profile from {len(profile_r_m_orig)} to {len(profile_r_m)} points.")
        else:
            profile_r_m = profile_r_m_orig
            profile_z_m = profile_z_m_orig

        if len(profile_r_m) < 2: return None

        path_rho_m, path_z_m, path_alpha_rad, path_phi_rad_cumulative, path_x_m, path_y_m = [], [], [], [], [], []
        current_phi_rad = 0.0

        # First point
        rho_start_m = profile_r_m[0]
        # Alpha at the true starting rho, which should be >= c_eff
        # If rho_start_m < c_eff, this indicates an issue with profile vs c_eff
        if rho_start_m < self.effective_polar_opening_radius_m - 1e-6: # Small tolerance
            print(f"ERROR: Profile start rho ({rho_start_m:.4f}m) is less than c_eff ({self.effective_polar_opening_radius_m:.4f}m). Path cannot start here.")
            # Option: Adjust rho_start_m to c_eff, but z would be inconsistent. Better to fix profile or c_eff.
            # Forcing start at c_eff would require finding corresponding z on dome.
            # For now, let's assume profile starts at or outside c_eff.
            # A robust way is to find the first point on profile >= c_eff.
            start_idx = np.argmax(profile_r_m >= self.effective_polar_opening_radius_m - 1e-6) # First True
            if not (profile_r_m[start_idx] >= self.effective_polar_opening_radius_m - 1e-6):
                print(f"CRITICAL ERROR: No profile point found at or beyond c_eff. Max profile_r_m: {np.max(profile_r_m)}")
                return None # Cannot start trajectory
            
            print(f"Adjusting trajectory start from profile_r[0]={profile_r_m[0]} to profile_r[{start_idx}]={profile_r_m[start_idx]} to match c_eff.")
            profile_r_m = profile_r_m[start_idx:]
            profile_z_m = profile_z_m[start_idx:]
            if len(profile_r_m) < 2: return None # Not enough points after adjustment
            rho_start_m = profile_r_m[0]


        alpha_start_rad = self.calculate_geodesic_alpha_at_rho(rho_start_m)
        if alpha_start_rad is None:
            alpha_start_rad = constants.PI / 2.0 # Default if at c_eff
            print(f"Warning: Defaulted alpha_start_rad to pi/2 at rho_start={rho_start_m}")

        path_rho_m.append(rho_start_m); path_z_m.append(profile_z_m[0]); path_alpha_rad.append(alpha_start_rad)
        path_phi_rad_cumulative.append(current_phi_rad)
        path_x_m.append(rho_start_m * math.cos(current_phi_rad)); path_y_m.append(rho_start_m * math.sin(current_phi_rad))
        # print(f"Debug TrajPt 0: rho={rho_start_m:.4f}, z={profile_z_m[0]:.4f}, alpha={math.degrees(alpha_start_rad):.2f}, phi={current_phi_rad:.4f}")


        for i in range(1, len(profile_r_m)):
            rho_i_m = profile_r_m[i]
            z_i_m = profile_z_m[i]
            alpha_i_rad = self.calculate_geodesic_alpha_at_rho(rho_i_m)

            rho_prev_m = path_rho_m[-1]
            z_prev_m = path_z_m[-1]
            alpha_prev_rad = path_alpha_rad[-1]

            if alpha_i_rad is None: # If current point is inside c_eff
                # This can happen if profile dips below c_eff or due to numerical issues
                # Try to use previous alpha and hope for the best, or stop.
                print(f"Warning: Undefined alpha at rho={rho_i_m:.4f} (c_eff={self.effective_polar_opening_radius_m:.4f}). Using previous alpha={math.degrees(alpha_prev_rad):.2f}.")
                alpha_i_rad = alpha_prev_rad
                # If alpha_i_rad is pi/2, and rho_i_m is also c_eff, it's a turn.
                # If rho_i_m < c_eff, this is an invalid state for pure geodesic.

            d_rho = rho_i_m - rho_prev_m
            d_z = z_i_m - z_prev_m
            ds_segment_m = math.sqrt(d_rho**2 + d_z**2)
            
            delta_phi = 0.0
            if ds_segment_m > 1e-9: # Only if there's actual movement along meridian
                rho_avg_segment_m = (rho_i_m + rho_prev_m) / 2.0
                alpha_avg_segment_rad = (alpha_i_rad + alpha_prev_rad) / 2.0
                
                # Robust handling of tan and division by rho
                if abs(rho_avg_segment_m) < 1e-7: # Effectively at the pole axis
                    if not math.isclose(alpha_avg_segment_rad, constants.PI / 2.0):
                        # Moving off the pole axis with alpha != pi/2. This is unusual for a single fiber.
                        # For a single fiber starting on axis, first step has huge phi.
                        # This formula might not be best for rho_avg -> 0.
                        # However, with c_eff > 0, rho_avg_segment_m should not be zero for the *wound path*.
                        print(f"Warning: rho_avg_segment is near zero ({rho_avg_segment_m:.2e}) but alpha_avg is not pi/2.")
                        delta_phi = 0 # Avoid singularity, this case needs better model if c_eff=0
                    else: # alpha is pi/2 and rho is 0 - pure axial rotation, phi undefined by this formula
                        delta_phi = 0 # Or an assumed turn value, e.g., pi if it's a half-turn over pole
                elif math.isclose(math.cos(alpha_avg_segment_rad), 0.0): # alpha is pi/2 (or -pi/2)
                    # Fiber is moving circumferentially or turning at c_eff.
                    # If ds_segment is non-zero, it means moving along meridian AT alpha=pi/2, which is only possible if already at c_eff.
                    # This is a turn AT the effective polar opening.
                    # ds_segment here is distance along meridian *at the turning latitude*.
                    # d_phi = ds_meridian_at_pole_turn / c_eff.
                    # This needs careful thought. For now, this implies a large d_phi / ds.
                    # Koussios's Omega parameter handles this.
                    # The formula ds/rho * tan(alpha) is problematic.
                    # If truly at alpha=pi/2, d(phi) = d(axial_rotation_angle). How much it rotates for a given ds?
                    # This is complex. Let's assume if cos(alpha) is near zero, tan(alpha) is huge.
                    # This will lead to a large delta_phi.
                    print(f"Warning: alpha_avg is near pi/2 (cos={math.cos(alpha_avg_segment_rad):.1e}). Tan will be large.")
                    # To prevent overflow with tan:
                    if abs(math.sin(alpha_avg_segment_rad)) > 1.0 - 1e-7: # sin is close to 1 or -1
                        # Very large tan. Heuristic for turn.
                        # delta_phi could be estimated based on change in meridian normal angle if available
                        # For now, let the large tan value give a large delta_phi
                         delta_phi = (ds_segment_m / rho_avg_segment_m) * math.tan(alpha_avg_segment_rad) if rho_avg_segment_m > 1e-7 else 0
                    else: # Should not happen if cos is zero
                         delta_phi = (ds_segment_m / rho_avg_segment_m) * math.tan(alpha_avg_segment_rad)

                else: # Standard case
                    delta_phi = (ds_segment_m / rho_avg_segment_m) * math.tan(alpha_avg_segment_rad)
            
            current_phi_rad += delta_phi
            
            path_rho_m.append(rho_i_m); path_z_m.append(z_i_m); path_alpha_rad.append(alpha_i_rad)
            path_phi_rad_cumulative.append(current_phi_rad)
            path_x_m.append(rho_i_m * math.cos(current_phi_rad)); path_y_m.append(rho_i_m * math.sin(current_phi_rad))
            
            # if i < 5 or i > len(profile_r_m) - 5: # Debug first and last few steps
            #     print(f"Debug TrajPt {i}: rho={rho_i_m:.4f}, z={z_i_m:.4f}, alpha={math.degrees(alpha_i_rad):.2f}, ds={ds_segment_m:.4e}, dphi={delta_phi:.4f}, phi_cum={current_phi_rad:.4f}")


        self.alpha_profile_deg = np.degrees(np.array(path_alpha_rad))
        self.phi_profile_rad_cumulative = np.array(path_phi_rad_cumulative)
        self.trajectory_3d_points_m = np.vstack((path_x_m, path_y_m, path_z_m)).T

        # ... (rest of alpha_eq and DeltaK calculation as before) ...
        # Ensure these use the potentially resampled/adjusted profile length
        if len(path_z_m) > 0 :
            equator_idx = np.argmin(np.abs(np.array(path_z_m))) # path_z_m is now a list
            if equator_idx < len(path_alpha_rad):
                 alpha_at_eq_rad = path_alpha_rad[equator_idx]
                 self.alpha_eq_deg = math.degrees(alpha_at_eq_rad)
            else:
                self.alpha_eq_deg = None; print("Warning: Could not determine alpha_eq_deg for geodesic.")
        else:
            self.alpha_eq_deg = None

        if len(self.phi_profile_rad_cumulative) > 1:
            Phi_pass = self.phi_profile_rad_cumulative[-1] - self.phi_profile_rad_cumulative[0]
            Phi_circuit_total = 2 * Phi_pass 
            self.turn_around_angle_rad_DeltaK = Phi_circuit_total % (2 * math.pi)
        else:
            self.turn_around_angle_rad_DeltaK = None


        print(f"DEBUG generate_geodesic: Final c_eff={self.effective_polar_opening_radius_m:.4f} m")
        print(f"DEBUG generate_geodesic: Final alpha_eq_deg={self.alpha_eq_deg}")
        print(f"DEBUG generate_geodesic: Final Phi_pass={Phi_pass if 'Phi_pass' in locals() else 'N/A':.4f} rad")
        print(f"DEBUG generate_geodesic: Final DeltaK={self.turn_around_angle_rad_DeltaK if self.turn_around_angle_rad_DeltaK is not None else 'N/A':.4f} rad")

        return {
            "rho_m": np.array(path_rho_m), "z_m": np.array(path_z_m),
            "alpha_deg": self.alpha_profile_deg if self.alpha_profile_deg is not None else np.array([]),
            "phi_rad_cumulative": self.phi_profile_rad_cumulative if self.phi_profile_rad_cumulative is not None else np.array([]),
            "x_m": np.array(path_x_m), "y_m": np.array(path_y_m),
            "effective_polar_opening_m": self.effective_polar_opening_radius_m,
            "turn_around_angle_DeltaK_rad": self.turn_around_angle_rad_DeltaK,
            "alpha_at_equator_deg": self.alpha_eq_deg
        }

    # ... (rest of the class)
```

**Key improvements in this version:**

1.  **Profile Resampling (Optional):** Added an option to resample the input meridian profile to `num_points_on_profile`. This helps if the original vessel profile has too few or too many points for a smooth trajectory calculation.
2.  **Trajectory Start Point Adjustment:** Logic added to check if the vessel profile starts at a radius smaller than `c_eff`. If so, it attempts to find the first point on the profile that is $\ge c_{eff}$ and starts the trajectory from there. This is crucial because a geodesic cannot exist inside its turning radius $c_{eff}$.
3.  **Robust `delta_phi` Calculation:**
    * Uses average $\rho$ and average $\alpha$ over the segment.
    * Added more explicit checks for `rho_avg_segment_m` being near zero or `cos(alpha_avg_segment_rad)` being near zero (i.e., $\alpha \approx \pi/2$).
    * **Important:** The handling of $\alpha \approx \pi/2$ (polar turn) is still heuristic in this simplified integration. A truly accurate $\phi$ accumulation right at the poles often requires a specialized "polar pass" model or very dense sampling and careful numerical treatment of the singularity in the $d\phi/ds$ equation (because $\rho \to c_{eff}$ and $\tan\alpha \to \infty$ simultaneously). Koussios's work sometimes introduces an additional turn-around angle $\Omega$ at the poles (Ch. 8) to account for this, which is not yet in this simplified model.
4.  **Storing (x,y,z):** Cartesian coordinates are calculated and stored.
5.  **Debug Prints:** Added more debug prints to trace key values.

**What the "z jump" means based on your description "starts at 15...goes to 100 and turns back, returns to 0 and jumps to -249":**

This sequence of z-values is **correct** for a path that traverses the *entire length of the vessel meridian* from one pole, across the cylinder (passing z=0 if the vessel origin is at the cylinder center), and to the other pole.

* "starts at 15...goes to 100": Path along the forward dome from its polar opening (z=15mm in your example scale) to the cylinder junction (z=100mm).
* "turns back, returns to 0": Path along the cylinder from z=100mm, through z=0 (equator/midpoint), towards z=-100mm (other cylinder junction).
* "jumps to -249": Path continues from z=-100mm along the aft dome to its polar opening (z=-249mm).

The "jump" is not a code error in the z-coordinate sequence itself; it's simply the path covering a large axial distance. A **continuous circuit** in 3D means the $(x,y,z)$ points form a smooth helical spiral. If your 3D plot looks wrong, it's because the calculated `phi_rad_cumulative` is not producing the correct spiral when combined with $\rho$ and $z$. The most sensitive part is the $\phi$ accumulation near the poles.

Try this revised code. When you plot in 3D using the new `x_m`, `y_m`, `z_m` from the output, pay attention to:
* How many points are used (`num_points_on_profile`). If too few, the polar wrap will look like a big jump.
* The value of `effective_polar_opening_radius_m`. If this is very small (e.g., close to the `rho_profile_m[0]` from an elliptical dome that starts at $\rho=0$), the $\phi$ changes near the pole will be extremely rapid.

If the 3D plot is still very wrong, we might need to look at the first few and last few full data points (rho, z, alpha, phi, x, y, z) to see where the phi accumulation is causing the visual distortion.